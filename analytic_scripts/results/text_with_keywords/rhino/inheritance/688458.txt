BUG REPORT COMMENTS:
When the property table in ScriptableObject is grown the existing Slot objects are copied to a new slots array. Even though the copyTable() method and other methods mutating slot data are synchronized, slots may be read during resizing from the unsynchronized getSlot() method. Since copyTable() may null out a slot's `next` field this can result in defined slots not being found and the corresponding property to be undefined.

See http://groups.google.com/group/mozilla-rhino/browse_frm/thread/1f30ec809bb7d41c for the original report.
This patch creates clones of the Slot instances when resizing the property table. We're using the ordered list to clone slots in order to preserve property order.

The other option for fixing this bug would have been to synchronize getSlot(), but since read access is far more frequent than resizing that doesn't seem like a good idea.
This patch removes deleted slots from the ordered list right when they are deleted. This makes delete O(n) which should be acceptable since it is not a very frequent operation.
Committed the last patch.

https://github.com/mozilla/rhino/commit/83678e6e932049780d9a9afa0ba2583ba7865081
Unfortunately my patch introduced another race condition. After slots are cloned, writes to the original slots from other threads will be lost. It seems like the only sane way to keep the object consistent in a multi-threaded environment during table resizing short of synchronizing reads is to keep existing slots after all. I'm working on a new patch.

After trying different approaches I think I found one that works well. 

This patch introduces a Slot subclass called RelinkedSlot that wraps the original slot and allows it to keep its identity while providing a new `next` link that doesn't interfere with the one of the original slot. RelinkedSlot wrappers are only used when a slot actually has the `next` field set, so overhead shouldn't be that bad. 

Another benefit is that we can keep our ordered slot list and don't have to rebuild it during table growth like we did with the cloning patch.

Committed patch and test case.

