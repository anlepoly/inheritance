BUG REPORT COMMENTS:
(In reply to comment #8)
> If I use this 
> class MyFile extends FileOutputStream {
>     public MyFile(File file) throws FileNotFoundException {
>         super(file);
>         // TODO Auto-generated constructor stub
>     }
>     public MyFile write(int b, int a) throws IOException {
>         // TODO Auto-generated method stub
>         return this;
>     }
>          void foo() { new MyFile(new File("")).write(1, 1).close();}    
> }
> 
> I still see the resource leak warning even though close() has been called. I
> don't know if its easy to implement a check for this though. I leave it upto
> you to see if you want to look at it.

I humbly decline. The fix for this bug is based on the support to associate a FakedTrackingVariable to an AllocationExpression in order to investigate the directly enclosing syntactic context. However this expression:
   new MyFile(new File("")).write(1, 1)
is beyond the field of vision of the analysis. How would we know that this expression represents the same instance as the AllocationExpression? I do not intend to implement a complete theorem prover :)

