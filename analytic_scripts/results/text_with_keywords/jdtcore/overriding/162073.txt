BUG REPORT COMMENTS:
I20061003-0800
On the following test case, the compiler complains on X, contending that foo's return type is incompatible with I#foo, J#foo. This is wrong because X#foo has no parameter at all and cannot override J#foo.
interface I {
  <T extends Exception & Cloneable> T foo(Number n);
}
interface J extends I {
  XX foo(Number n);
}
public abstract class X implements J {
  void foo() {
  }
}
abstract class XX extends Exception implements Cloneable {}

Added AmbiguousMethodTest#32 (inactive) and 33.
The error is not about X#foo at all (even if its presence conditions the behavior). It is kicked by the compatibility check on methods inherited from different paths. On the following variant, adding a complete foo implementation on X solves the issue - which should not be needed:
interface I {
  <T extends Exception & Cloneable> T foo(Number n);
}
interface J extends I {
  XX foo(Number n);
}
public abstract class X implements J {
  void foo() {
  }
  XX foo (Number n) {
    return null;
  }
}
abstract class XX ex

