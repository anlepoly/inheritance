<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>458361</bug_id>
          
          <creation_ts>2015-01-25 12:15:00 -0500</creation_ts>
          <short_desc>[1.8][null] reconciler throws NPE in ProblemReporter.illegalReturnRedefinition()</short_desc>
          <delta_ts>2015-01-27 08:05:08 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.5</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M5</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Stephan Herrmann">stephan.herrmann</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>manpalat</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2509950</commentid>
    <comment_count>0</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 12:15:43 -0500</bug_when>
    <thetext>Feeding source similar to this:

//---
public interface MyMap&lt;K,V&gt; extends Map&lt;K,V&gt; {
    @Override
    public @Nullable V get(@Nullable Object key);
    ...
}
//---

Into the reconciler causes:

NullPointerException: 
    SourceElementParser$1(ProblemReporter).illegalReturnRedefinition(AbstractMethodDeclaration, MethodBinding, char[][]) line: 9375 
    ImplicitNullAnnotationVerifier.checkNullSpecInheritance(MethodBinding, AbstractMethodDeclaration, boolean, boolean, boolean, MethodBinding, MethodBinding[], Scope, ImplicitNullAnnotationVerifier$InheritedNonNullnessInfo[]) line: 299    
    ImplicitNullAnnotationVerifier.checkImplicitNullAnnotations(MethodBinding, AbstractMethodDeclaration, boolean, Scope) line: 115 
    SourceTypeBinding.createArgumentBindings(MethodBinding, CompilerOptions) line: 2007 
    SourceTypeBinding.resolveTypesFor(MethodBinding) line: 1974 
    SourceTypeBinding.methods() line: 1467  
    SourceTypeBinding.faultInTypesForFieldsAndMethods() line: 856   
    CompilationUnitScope.faultInTypes() line: 445   
    CompilationUnitProblemFinder(Compiler).resolve(CompilationUnitDeclaration, ICompilationUnit, boolean, boolean, boolean) line: 958   
    CompilationUnitProblemFinder.process(CompilationUnit, SourceElementParser, WorkingCopyOwner, HashMap, boolean, int, IProgressMonitor) line: 197 
    CompilationUnit.buildStructure(OpenableElementInfo, IProgressMonitor, Map, IResource) line: 194 
    CompilationUnit(Openable).generateInfos(Object, HashMap, IProgressMonitor) line: 259    
    CompilationUnit(JavaElement).openWhenClosed(Object, boolean, IProgressMonitor) line: 579    
    CompilationUnit.makeConsistent(int, boolean, int, HashMap, IProgressMonitor) line: 1082 
    ReconcileWorkingCopyOperation.makeConsistent(CompilationUnit) line: 171 
    ReconcileWorkingCopyOperation.executeOperation() line: 90   
    ReconcileWorkingCopyOperation(JavaModelOperation).run(IProgressMonitor) line: 729   
    ReconcileWorkingCopyOperation(JavaModelOperation).runOperation(IProgressMonitor) line: 789  
    CompilationUnit.reconcile(int, int, WorkingCopyOwner, IProgressMonitor) line: 1247  
    JavaReconcilingStrategy.reconcile(ICompilationUnit, boolean) line: 126  
    JavaReconcilingStrategy.access$0(JavaReconcilingStrategy, ICompilationUnit, boolean) line: 108  
    JavaReconcilingStrategy$1.run() line: 89    
    SafeRunner.run(ISafeRunnable) line: 42  
    JavaReconcilingStrategy.reconcile(boolean) line: 87 
    JavaReconcilingStrategy.reconcile(IRegion) line: 151    
    JavaCompositeReconcilingStrategy(CompositeReconcilingStrategy).reconcile(IRegion) line: 86  
    JavaCompositeReconcilingStrategy.reconcile(IRegion) line: 104   
    JavaReconciler(MonoReconciler).process(DirtyRegion) line: 77    
    AbstractReconciler$BackgroundThread.run() line: 206 


Passing null for nonNullAnnotationName doesn&apos;t look like a good idea.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509951</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 12:16:11 -0500</bug_when>
    <thetext>Should be simple to fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509956</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 12:40:43 -0500</bug_when>
    <thetext>Immediate fix is trivial indeed, but now we report:

The return type is incompatible with &apos;@NonNull T&apos; returned from Collection&lt;T&gt;.get(int) (mismatching null constraints)

This is bogus, the super method has no @NonNull T, but T is a free type variable, which should be spelled out in the error.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509964</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 13:38:39 -0500</bug_when>
    <thetext>One more thing is fishy:

CompilerOption.useNullTypeAnnotations was uninitialized, although LookupEnvironment.usesNullTypeAnnotations() had been called (which initializes this field)!

Why? CompilationUnit.buildStructure() creates a SourceElementParser with one instance of CompilerOptions and passes this on to its ProblemReporter. Then CompilationUnitProblemFinder.process() creates another instance of ComilerOptions, to be used during compilation.

=&gt; Compiler (LookupEnvironment) and ProblemReporter work on different instances of CompilerOptions, hence the lazy initialization of useNullTypeAnnotations has no affect on those options used by the shared ProblemReporter.

I have a fix under test by *sharing* the same CompilerOptions instance between parser and compiler. If that doesn&apos;t fly, we may want to update ProblemReporter#options similar to ProblemReporter#referenceContext. Let&apos;s see...

THIS, btw, was the reason the NPE only occurred during reconcile, not during building.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509965</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 13:46:55 -0500</bug_when>
    <thetext>By avoiding the duplication of CompilerOptions, it is now impossible to reproduce the NPE - which indicates that passing null happened on a soundish assumption :)

Still, avoiding the null in the first place is of course much more robust and requires less hand-waving should we have to revisit this area during future maintenance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509969</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-25 14:20:32 -0500</bug_when>
    <thetext>Changes pushed to gerrit:   https://git.eclipse.org/r/40329

For posterity: the CompilerOptions issue caused a little ripple: CUPF needs to access Parser#options. I decided to change &quot;protected&quot; to &quot;public final&quot;, requiring follow-up changes in different parsers. In two cases this revealed that options were initialized redundantly (which is now illegal), where obviously the same instance was used both times.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2510402</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-26 15:08:46 -0500</bug_when>
    <thetext>No the change around the CompilerOptions caused regressions:

Test Result (3 failures / +3)

    org.eclipse.jdt.core.tests.dom.ASTConverterTestAST3_2.test0697
    org.eclipse.jdt.core.tests.dom.ASTConverterTestAST4_2.test0697
    org.eclipse.jdt.core.tests.dom.ASTConverterTestAST8_2.test0697
    
Instead of investigating why s.o. would depend on not sharing CompilerOptions I reverted that part, and replaced the field access (CompilerOptions#useNullTypeAnnotations) with a corresponding query that is similar to the lazy computation in LookupEnvironment, where the latter only performs more initialization.

Back to gerrit.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2510482</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-26 19:09:02 -0500</bug_when>
    <thetext>Released for 4.5 M5 via commit e62068644543b99c745f832b9263b49ff6b3d0ba</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2510711</commentid>
    <comment_count>8</comment_count>
    <who name="Manoj Palat Away Until May 11 2015">manpalat</who>
    <bug_when>2015-01-27 08:05:08 -0500</bug_when>
    <thetext>Verified for Eclipse Mars 4.5 M5 Build id: I20150126-2000</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>