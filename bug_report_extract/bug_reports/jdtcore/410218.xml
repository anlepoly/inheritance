<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>410218</bug_id>
          
          <creation_ts>2013-06-07 12:50:00 -0400</creation_ts>
          <short_desc>Optional warning for arguments of &quot;unexpected&quot; types to Map#get(Object), Collection#remove(Object) et al.</short_desc>
          <delta_ts>2015-04-08 10:04:16 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.3</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>REOPENED</bug_status>
          <resolution></resolution>
          
          <see_also>https://bugs.eclipse.org/bugs/show_bug.cgi?id=415306</see_also>
    
    <see_also>https://git.eclipse.org/r/43735</see_also>
    
    <see_also>https://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=689526016f6ab442680e718d2760fc44e79dd9b5</see_also>
    
    <see_also>https://git.eclipse.org/r/43851</see_also>
    
    <see_also>https://git.eclipse.org/r/43974</see_also>
    
    <see_also>https://git.eclipse.org/r/43976</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>4.6</target_milestone>
          
          <blocked>461999</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Markus Keller">markus_keller</reporter>
          <assigned_to name="JDT-Core-Inbox">jdt-core-inbox</assigned_to>
          <cc>daniel_megert</cc>
    
    <cc>eclipse</cc>
    
    <cc>entheh</cc>
    
    <cc>filip_wieladek</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
    
    <cc>troy</cc>
          
          <votes>1</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2269995</commentid>
    <comment_count>0</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-06-07 12:50:53 -0400</bug_when>
    <thetext>Add an optional compiler warning if arguments of &quot;unexpected&quot; types are passed to java.util.Map#get/remove(Object), Collection#contains/remove(Object), Collection#retain/remove/containsAll(Collection&lt;?&gt;), List#indexOf(Object), etc.

Example:

	Set&lt;Short&gt; set = new HashSet&lt;&gt;();
	short one = 1;
	set.add(one);

	set.remove(&quot;ONE&quot;); // bad (wrong type)
	set.remove(1); // bad (tries to remove &quot;Integer 1&quot;)
	System.out.println(set); // shows that the &quot;Short 1&quot; is still in!

	set.remove(one); // ok
	System.out.println(set);

The calls marked as &quot;// bad&quot; compile without error, although they often hide a programming error that would have been caught at compile time if these accessor methods would not accept all types, but just the type variable E (or K or Collection&lt;? extends E&gt; etc.).

Unfortunately, the affected accessor methods cannot be determined in a generic way, so we need an explicit list of special methods and their &quot;expected&quot; argument types. For method invocations of a special method, the compiler can then also check whether a variant with the &quot;expected&quot; signature would also be applicable. If it&apos;s not applicable, then a warning should be issued.


Some background:
http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic
http://stackoverflow.com/questions/104799/why-arent-java-collections-remove-methods-generic
http://smallwig.blogspot.ch/2007/12/why-does-setcontains-take-object-not-e.html</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270058</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-06-07 14:41:55 -0400</bug_when>
    <thetext>I wholeheartedly agree.

I assigned the bug to me, but I won&apos;t start right away, so if s.o. else
has cycles to spare and is interested in this bug please let me know.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271134</commentid>
    <comment_count>2</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-06-11 09:07:41 -0400</bug_when>
    <thetext>*** Bug 358209 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271136</commentid>
    <comment_count>3</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-06-11 09:08:31 -0400</bug_when>
    <thetext>*** Bug 389014 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2386025</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-04-08 04:54:51 -0400</bug_when>
    <thetext>Stephan, do you expect to work on this for Luna ? ISTM, this is best addressed
in the start of Mars ? If you agree, please retarget. Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2388344</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-04-12 09:53:46 -0400</bug_when>
    <thetext>Since an optional warning requires additional API it is too late already for 4.4, right?

(Other than that, implementation _might_ be straight forward and simple).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2487191</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-11-21 13:51:26 -0500</bug_when>
    <thetext>Linking to bug 415306, which requests special/similar warnings for equals() of certain well known types.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2528118</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-08 18:54:36 -0400</bug_when>
    <thetext>I have a draft implementation in my workspace.

An example warning message would be:

----------
1. WARNING in X.java (at line 8)
	if (set.contains(&quot;ONE&quot;)) // bad
	                 ^^^^^
Discouraged invocation of method contains(Object), this argument should have type Short to match the declaring type Collection&lt;Short&gt;
----------


Here&apos;s another example I used for experiments:

void test(Map&lt;? extends Number, Number&gt; m) {
	if (m.containsKey(&quot;ONE&quot;)) // bad
		m.remove(&quot;ONE&quot;); // bad
}

Recognizing this as bad is easy, too. Question is: what would a user have to write to avoid the new warning? Literally, the &quot;expected&quot; type would be a capture, a value of which is quite difficult to obtain.

My initial feeling was, that we may want to silence the warning if the mismatch between &quot;expected&quot; and actual type is only a matter of captures. OTOH, if those methods were declared using a type variable, the strict interpretation would be mandatory, of course. But users will not like the warning if it creates situations that are hard to get right and may still do the right thing.

What do you think: is it a relevant concern to avoid warnings involving captures?


More questions: 

What should be the default value for this new diagnostic? Warning? Ignore?

I think we want to make it suppressable with @SW, right? Which token? Should we introduce a new token? (Bug 389014 proposed &quot;rawtypes&quot; :-/).

Bug 358209 requests a distinction of potentially incompatible vs. incompatible. Should we? I don&apos;t have a strong opinion on this, but surfacing both levels as separate options in the UI feels like overkill to me.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2528128</commentid>
    <comment_count>8</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-08 20:05:01 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #7)
&gt; Here&apos;s another example I used for experiments:
&gt; 
&gt; void test(Map&lt;? extends Number, Number&gt; m) {
&gt; 	if (m.containsKey(&quot;ONE&quot;)) // bad
&gt; 		m.remove(&quot;ONE&quot;); // bad
&gt; }
&gt; 
&gt; Recognizing this as bad is easy, too. Question is: what would a user have to
&gt; write to avoid the new warning? Literally, the &quot;expected&quot; type would be a
&gt; capture, a value of which is quite difficult to obtain.

This particular example is obviously wrong because a String cannot ever be a Number. If you replaced &quot;ONE&quot; with 1, then it becomes more interesting, because the ? could be Integer for some invocations. Still, it seems unclean for a generic method to include specific functionality, so I wouldn&apos;t object to inflicting some SuppressWarnings pain on people who are doing this.

I&apos;m curious, what are the rules about casting - would a compile-time cast from the capture type [or equivalent type variable] to Integer be accepted? What about the other way? This is relevant if the &apos;incompatible&apos; vs &apos;potentially incompatible&apos; distinction is preserved (see further down).

&gt; My initial feeling was, that we may want to silence the warning if the
&gt; mismatch between &quot;expected&quot; and actual type is only a matter of captures.
&gt; OTOH, if those methods were declared using a type variable, the strict
&gt; interpretation would be mandatory, of course. But users will not like the
&gt; warning if it creates situations that are hard to get right and may still do
&gt; the right thing.
&gt; 
&gt; What do you think: is it a relevant concern to avoid warnings involving
&gt; captures?

Personally I would say not, because this (your example tweaked to use only Numbers):

void test(Map&lt;? extends Number, Number&gt; m) {
	if (m.containsKey(1)) // [potentially?] bad
		m.remove(1); // [potentially?] bad
}

has exactly the same level of potential wrongness as this:

void test(Map&lt;Short, Number&gt; m) {
	if (m.containsKey(1)) // bad
		m.remove(1); // bad
}

And in fact, it&apos;s less obvious that the first example is wrong, so perhaps the warning is even more useful there.

In a real use case, perhaps test() should be taking the &apos;1&apos; as an extra argument (and using a type parameter):

void test&lt;T extends Number&gt;(Map&lt;T, Number&gt; m, T removeMe)

&gt; More questions: 
&gt; 
&gt; What should be the default value for this new diagnostic? Warning? Ignore?

Warning!!! It&apos;s so rare to need to pass a strange type deliberately. Oh by the way though, perhaps if the method is just a wrapper like the following, then you might want to suppress the warning (I don&apos;t see any need to make this optional).

class MySet&lt;T&gt; implements Set&lt;T&gt; {
    public bool contains(Object t) { //implements Set&lt;T&gt;
        return wrappedList.contains(t); //bad but unavoidable
    }
}

&gt; I think we want to make it suppressable with @SW, right? Which token? Should
&gt; we introduce a new token? (Bug 389014 proposed &quot;rawtypes&quot; :-/).

Not rawtypes :) Those methods were declared in terms of Object instead of T for a non-rawtypes-related reason: for example, HashSet&lt;T&gt;.equals(TreeSet&lt;T&gt;) can return true, and therefore so can HashSet&lt;HashSet&lt;T&gt;&gt;.contains(TreeSet&lt;T&gt;). It&apos;s just that those cases are much rarer than the common case of passing the wrong key by accident.

I can&apos;t see an existing token that&apos;s correct - not even &quot;unchecked&quot; since this has nothing to do with heap pollution. Meanwhile, &quot;serial&quot; and &quot;sync-override&quot; are very specific, so it looks as if it&apos;s fine to make a new very specific one. Perhaps something like &quot;keytypes&quot;?

&gt; Bug 358209 requests a distinction of potentially incompatible vs.
&gt; incompatible. Should we? I don&apos;t have a strong opinion on this, but
&gt; surfacing both levels as separate options in the UI feels like overkill to
&gt; me.

That was my proposal, and it&apos;s to do with the HashSet&lt;T&gt;.equals(TreeSet&lt;T&gt;) case above.

So if you write this:
    HashSet&lt;HashSet&lt;T&gt;&gt;.Contains(TreeSet&lt;T&gt;)
then the new warning will kick in because a TreeSet&lt;T&gt; cannot be a HashSet&lt;T&gt;. However, my reasoning was, if you cast it like this:
    HashSet&lt;HashSet&lt;T&gt;&gt;.Contains((Set&lt;T&gt;)TreeSet&lt;T&gt;)
then it can be classed as only &apos;potentially incompatible&apos;, and perhaps users will disable the &apos;potentially&apos; warning if they need to do this.

Surfacing the two options might not be overkill if you do it using an indented checkbox:

Incorrect key type passed to Map.get et al [Ignore/Warning/Error]
  [X] Allow arguments that could be cast to the correct type

Then it still looks like a single concept and doesn&apos;t use up too much space.

Here&apos;s another thought actually: perhaps we don&apos;t even need the &apos;potentially&apos; case, i.e. if the argument could be cast to the correct key type then no warning. That would also save you having to write a special case for wrappers.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2529708</commentid>
    <comment_count>9</comment_count>
      <attachid>251444</attachid>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-10 19:38:59 -0400</bug_when>
    <thetext>Created attachment 251444
draft

(In reply to Missing name from comment #8)

Thanks, Anonymous, for detailed comments.

I see that my considerations about captures were a bit off. Just because it&apos;s hard to supply an argument of the required type doesn&apos;t make for a good excuse :)

Instead I now included a distinction between
 - argument can be casted to the &quot;expected&quot; type -&gt; softly discouraged
 - argument cannot be casted to the &quot;expected&quot; type -&gt; strongly discouraged
In deviation from standard casting rules I&apos;m admitting a boxing operation before the compatibility check.


&gt; &gt; What should be the default value for this new diagnostic? Warning? Ignore?
&gt; 
&gt; Warning!!! It&apos;s so rare to need to pass a strange type deliberately.

That&apos;s my take, too. Let&apos;s see if anyone objects.
 
&gt; Oh by
&gt; the way though, perhaps if the method is just a wrapper like the following,
&gt; then you might want to suppress the warning (I don&apos;t see any need to make
&gt; this optional).
&gt;
&gt; class MySet&lt;T&gt; implements Set&lt;T&gt; {
&gt;     public bool contains(Object t) { //implements Set&lt;T&gt;
&gt;         return wrappedList.contains(t); //bad but unavoidable
&gt;     }
&gt; }

That&apos;s actually a situation for which we need a good story, if we want to enable the warning by default.

 * It doesn&apos;t make much sense to insert an unchecked cast &quot;(T) t&quot;.

 * @SW would be the natural answer, if this occurs infrequently.

 * We could also treat j.l.Object as a tolerable catch-all (In that case users should know that they don&apos;t know what they are doing). Would that be part 3 of the option??

 
&gt; &gt; I think we want to make it suppressable with @SW, right? Which token? Should
&gt; &gt; we introduce a new token? (Bug 389014 proposed &quot;rawtypes&quot; :-/).
&gt; 
&gt; Not rawtypes :) Those methods were declared in terms of Object instead of T
&gt; for a non-rawtypes-related reason: for example,
&gt; HashSet&lt;T&gt;.equals(TreeSet&lt;T&gt;) can return true, and therefore so can
&gt; HashSet&lt;HashSet&lt;T&gt;&gt;.contains(TreeSet&lt;T&gt;). It&apos;s just that those cases are
&gt; much rarer than the common case of passing the wrong key by accident.
&gt; 
&gt; I can&apos;t see an existing token that&apos;s correct - not even &quot;unchecked&quot; since
&gt; this has nothing to do with heap pollution. Meanwhile, &quot;serial&quot; and
&gt; &quot;sync-override&quot; are very specific, so it looks as if it&apos;s fine to make a new
&gt; very specific one. Perhaps something like &quot;keytypes&quot;?

I agree that none of the existing tokens really match. &quot;keytypes&quot; would cover only the K from Map, not the V and T arguments. Still taking bets.

Let me brainstorm a bit what it really *is*, before condensing into a short token: the library methods are &quot;over generalized&quot;, resulting in &quot;dangerous signatures&quot;, which falsely admit arguments that semantically don&apos;t match.

&quot;problem-signature&quot;
 
&gt; That was my proposal, and it&apos;s to do with the HashSet&lt;T&gt;.equals(TreeSet&lt;T&gt;)
&gt; case above.
&gt; 
&gt; So if you write this:
&gt;     HashSet&lt;HashSet&lt;T&gt;&gt;.Contains(TreeSet&lt;T&gt;)
&gt; then the new warning will kick in because a TreeSet&lt;T&gt; cannot be a
&gt; HashSet&lt;T&gt;. However, my reasoning was, if you cast it like this:
&gt;     HashSet&lt;HashSet&lt;T&gt;&gt;.Contains((Set&lt;T&gt;)TreeSet&lt;T&gt;)
&gt; then it can be classed as only &apos;potentially incompatible&apos;, and perhaps users
&gt; will disable the &apos;potentially&apos; warning if they need to do this.

We&apos;re slightly mixing two things here: the reason that both types are admissible is in the implementation of their equals methods. The fact that both have a non-trivial common super type has little to do with this (except, that Set&lt;T&gt; indeed happens to establish this contract of equality).

Obviously, inserting a cast to j.l.Object is the escape door, allowing to soften all warnings to &quot;potential&quot;. That&apos;s in fact similar to how nested casts can circumvent the checks for uncastable types.

 
&gt; Surfacing the two options might not be overkill if you do it using an
&gt; indented checkbox:
&gt; 
&gt; Incorrect key type passed to Map.get et al [Ignore/Warning/Error]
&gt;   [X] Allow arguments that could be cast to the correct type
&gt; 
&gt; Then it still looks like a single concept and doesn&apos;t use up too much space.

Looks good.

At the bottom line, to me the wording seems to be the hard part. This concerns the @SW token and also the warning messages. 

Tests in the attachment show the following messages in action:

1200 = Discouraged argument for method {0}, should be of type {1} to match the declaring type {2}
1201 = Discouraged argument for method {0}, provided type {1} is definitely incompatible to type {2}. Declaring type is {3}


Here&apos;s an alternative pair of proposals:

1200 = Invoking method {0} with an argument of type {1} is discouraged. Should use {2} to meet the semantics of declaring type {3}
1201 = Invoking method {0} with an argument of type {1} cannot meet the semantics of declaring type {3}. Recommended type: {2}


I really want to show: (a) what&apos;s wrong, (b) what should it be instead, and (c) why. For the &quot;why&quot; I&apos;m including the declaring type (that&apos;s where we see the effective parameterization).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530281</commentid>
    <comment_count>10</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-11 16:50:58 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #9)
&gt; Instead I now included a distinction between
&gt;  - argument can be casted to the &quot;expected&quot; type -&gt; softly discouraged
&gt;  - argument cannot be casted to the &quot;expected&quot; type -&gt; strongly discouraged
&gt; In deviation from standard casting rules I&apos;m admitting a boxing operation
&gt; before the compatibility check.

Sounds good on the face of it; I&apos;m sure you&apos;ve thought about boxing in more depth than I have. By the way, not sure if you used it in any messages, but we just say &apos;cast&apos;, not &apos;casted&apos; (it&apos;s irregular).

&gt; &gt; class MySet&lt;T&gt; implements Set&lt;T&gt; {
&gt; &gt;     public bool contains(Object t) { //implements Set&lt;T&gt;
&gt; &gt;         return wrappedList.contains(t); //bad but unavoidable
&gt; &gt;     }
&gt; &gt; }
&gt; 
&gt; That&apos;s actually a situation for which we need a good story, if we want to
&gt; enable the warning by default.
&gt; 
&gt;  * It doesn&apos;t make much sense to insert an unchecked cast &quot;(T) t&quot;.
&gt; 
&gt;  * @SW would be the natural answer, if this occurs infrequently.
&gt; 
&gt;  * We could also treat j.l.Object as a tolerable catch-all (In that case
&gt; users should know that they don&apos;t know what they are doing). Would that be
&gt; part 3 of the option??

The Object solution would affect people who have Map&lt;String,Object&gt; - which does happen, though it&apos;s not that common. Still, what I had in mind is you could check if the argument is a field access expression which resolves to an affected parameter of an affected method. If that&apos;s not too onerous then I think it is better. I can&apos;t think of any cases it doesn&apos;t catch; can you?

&gt; I agree that none of the existing tokens really match. &quot;keytypes&quot; would
&gt; cover only the K from Map, not the V and T arguments. Still taking bets.

Good point.

&gt; Let me brainstorm a bit what it really *is*, before condensing into a short
&gt; token: the library methods are &quot;over generalized&quot;, resulting in &quot;dangerous
&gt; signatures&quot;, which falsely admit arguments that semantically don&apos;t match.
&gt; 
&gt; &quot;problem-signature&quot;

Too general I&apos;d say, and it also draws attention to the signature (not in the user&apos;s control) rather than the invocation (which is).

Generalising directly from &quot;keytypes&quot;, &quot;argtypes&quot; is closer but it&apos;s still too general.

What these methods all have in common is that they never store the Object you pass in, they just use it for comparisons. Not sure if that helps us at all.

I just had a read of http://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic too in the hope of some ideas, perhaps some terminology we haven&apos;t thought of. I haven&apos;t found a great deal, but terms like liberal, restrictive...

&quot;liberal-arg-type&quot;?

Another way we could look at it is, while there is a reason why these strange argument types are accepted, they are &quot;unlikely&quot; to be correct.

&quot;unlikely-arg-type&quot;?

If more cases are found in the future that have nothing to do with this but are still examples of someone passing an argument of a type that seems unlikely to be right, then I think it could share @SW quite validly with this one.

Aside: it&apos;s reassuring to see how many people have upvoted the comments we agree with :)

&gt; &gt; So if you write this:
&gt; &gt;     HashSet&lt;HashSet&lt;T&gt;&gt;.Contains(TreeSet&lt;T&gt;)
&gt; &gt; then the new warning will kick in because a TreeSet&lt;T&gt; cannot be a
&gt; &gt; HashSet&lt;T&gt;. However, my reasoning was, if you cast it like this:
&gt; &gt;     HashSet&lt;HashSet&lt;T&gt;&gt;.Contains((Set&lt;T&gt;)TreeSet&lt;T&gt;)
&gt; &gt; then it can be classed as only &apos;potentially incompatible&apos;, and perhaps users
&gt; &gt; will disable the &apos;potentially&apos; warning if they need to do this.
&gt; 
&gt; We&apos;re slightly mixing two things here: the reason that both types are
&gt; admissible is in the implementation of their equals methods. The fact that
&gt; both have a non-trivial common super type has little to do with this
&gt; (except, that Set&lt;T&gt; indeed happens to establish this contract of equality).

Not sure I understand which two things we&apos;re mixing. I think the Set&lt;T&gt; example is merely to explain why someone decided to make these methods take Object instead of T in the first place. It&apos;s also definitely the case that &apos;type cannot be implicitly cast&apos; and &apos;ditto explicitly&apos; are heuristics, and that they don&apos;t take Set&lt;T&gt; into account. (We could do something messy like check if Set&lt;T&gt;.equals() exists and HashSet&lt;T&gt;.equals() doesn&apos;t, but that&apos;s not foolproof since HashSet&lt;T&gt;.equals() might exist to optimise the &apos;two HashSets&apos; case without changing semantics, for example. I think our heuristics plus @SW are good enough.)

&gt; Obviously, inserting a cast to j.l.Object is the escape door, allowing to
&gt; soften all warnings to &quot;potential&quot;. That&apos;s in fact similar to how nested
&gt; casts can circumvent the checks for uncastable types.

Yep :) but it&apos;s messy if it happens a lot, so @SW is still useful - someone might have a valid reason to use it on a whole method or class.

&gt; &gt; Surfacing the two options might not be overkill if you do it using an
&gt; &gt; indented checkbox:
&gt; &gt; 
&gt; &gt; Incorrect key type passed to Map.get et al [Ignore/Warning/Error]
&gt; &gt;   [X] Allow arguments that could be cast to the correct type
&gt; &gt; 
&gt; &gt; Then it still looks like a single concept and doesn&apos;t use up too much space.
&gt; 
&gt; Looks good.

Cool :) Though now I&apos;m thinking, &apos;Unlikely key type&apos; may be better?

&gt; At the bottom line, to me the wording seems to be the hard part. This
&gt; concerns the @SW token and also the warning messages. 
&gt; 
&gt; Tests in the attachment show the following messages in action:
&gt; 
&gt; 1200 = Discouraged argument for method {0}, should be of type {1} to match
&gt; the declaring type {2}
&gt; 1201 = Discouraged argument for method {0}, provided type {1} is definitely
&gt; incompatible to type {2}. Declaring type is {3}

These are much easier to understand with examples, so I guess that would be:

1200 = Discouraged argument for method get(Object), should be of type String to match the declaring type Map&lt;String, Integer&gt;
1201 = Discouraged argument for method get(Object), provided type Class is definitely incompatible to type String. Declaring type is Map&lt;String, Integer&gt;

&gt; Here&apos;s an alternative pair of proposals:
&gt; 
&gt; 1200 = Invoking method {0} with an argument of type {1} is discouraged.
&gt; Should use {2} to meet the semantics of declaring type {3}
&gt; 1201 = Invoking method {0} with an argument of type {1} cannot meet the
&gt; semantics of declaring type {3}. Recommended type: {2}

1200 = Invoking method get(Object) with an argument of type Object is discouraged. Should use String to meet the semantics of declaring type Map&lt;String, Integer&gt;
1201 = Invoking method get(Object) with an argument of type Class cannot meet the semantics of declaring type Map&lt;String, Integer&gt;. Recommended type: String

&gt; I really want to show: (a) what&apos;s wrong, (b) what should it be instead, and
&gt; (c) why. For the &quot;why&quot; I&apos;m including the declaring type (that&apos;s where we see
&gt; the effective parameterization).

Yes, it makes sense. I like the second proposal for 1200 the most (since it includes the current argument type), and would perhaps tweak 1201 so we can get the recommended type out before the declaring type. Here&apos;s a new proposal (sorry for leaving the examples in, it just makes it easier to discuss and refine):

1200 = Invoking method get(Object) with an argument of type Object is discouraged. Should use String to meet the semantics of declaring type Map&lt;String, Integer&gt;
1201 = Invoking method get(Object) with an argument of type Class is unlikely to be correct. Should use String to meet the semantics of declaring type Map&lt;String, Integer&gt;, or consider adding a cast to Object* if correct

* That&apos;s the most specific common supertype, and obviously if they do it then they&apos;ll get warning 1200 if enabled.

By the way, if someone does this:
  class MyVerySpecificMap implements Map&lt;String, Integer&gt;
then that will obscure the message, so it may be worth degenerating the &apos;declaring type&apos; (for message purposes) to the built-in collection interface that originally declared the problematic method - i.e. the message says Map&lt;String, Integer&gt; instead of MyVerySpecificMap.

Oh, in the interests of succinctness, you could also remove the words &apos;declaring type&apos; and &apos;method&apos; if you want - it&apos;s pretty obvious once it&apos;s got examples.

Hope that helps :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530288</commentid>
    <comment_count>11</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-11 16:58:27 -0400</bug_when>
    <thetext>&gt; &gt; &gt; Incorrect key type passed to Map.get et al [Ignore/Warning/Error]
&gt; &gt; &gt;   [X] Allow arguments that could be cast to the correct type
&gt; 
&gt; Cool :) Though now I&apos;m thinking, &apos;Unlikely key type&apos; may be better?

Make that &apos;Unlikely argument type&apos;!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530290</commentid>
    <comment_count>12</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-11 16:59:16 -0400</bug_when>
    <thetext>(In reply to Missing name from comment #11)
&gt; &gt; &gt; &gt; Incorrect key type passed to Map.get et al [Ignore/Warning/Error]
&gt; &gt; &gt; &gt;   [X] Allow arguments that could be cast to the correct type
&gt; &gt; 
&gt; &gt; Cool :) Though now I&apos;m thinking, &apos;Unlikely key type&apos; may be better?
&gt; 
&gt; Make that &apos;Unlikely argument type&apos;!

And &apos;to the expected type&apos; perhaps?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530331</commentid>
    <comment_count>13</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-11 19:23:17 -0400</bug_when>
    <thetext>(In reply to Ben Davis from comment #10)
&gt; By the way, if someone does this:
&gt;   class MyVerySpecificMap implements Map&lt;String, Integer&gt;
&gt; then that will obscure the message, so it may be worth degenerating the
&gt; &apos;declaring type&apos; (for message purposes) to the built-in collection interface
&gt; that originally declared the problematic method - i.e. the message says
&gt; Map&lt;String, Integer&gt; instead of MyVerySpecificMap.

That&apos;s exactly what the implementation in attachment 251444 does :)
I don&apos;t yet have tests matching your exact situation, but for all tests using Set&lt;Short&gt; the message mentions the &apos;declaring type Collection&lt;Short&gt;&apos;. This is done by searching the super type that is a parameterization of one of the well-known trouble makers (Collection and Map, so far)

 
&gt; Oh, in the interests of succinctness, you could also remove the words
&gt; &apos;declaring type&apos; and &apos;method&apos; if you want - it&apos;s pretty obvious once it&apos;s
&gt; got examples.

And the previous point is exactly the reason why I say &apos;declaring type&apos;. Still users will complain: why is the message talking about Map&lt;String,Integer&gt;? I don&apos;t see this type anywhere in the flagged code. I want to give at least some hint where to look.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530542</commentid>
    <comment_count>14</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-12 08:55:47 -0400</bug_when>
    <thetext>(In reply to Ben Davis from comment #10)
&gt; &gt;  * We could also treat j.l.Object as a tolerable catch-all (In that case
&gt; &gt; users should know that they don&apos;t know what they are doing). Would that be
&gt; &gt; part 3 of the option??
&gt; 
&gt; The Object solution would affect people who have Map&lt;String,Object&gt;.

I&apos;m not sure which effect you have in mind? For such map asking containsValue(x) is always OK, with or without any special rule for j.l.Object, but anyway I wouldn&apos;t include this rule just now.

&gt; Still, what I had in mind is you
&gt; could check if the argument is a field access expression which resolves to
&gt; an affected parameter of an affected method. If that&apos;s not too onerous then
&gt; I think it is better.

too complex, IMHO.
 
&gt; Another way we could look at it is, while there is a reason why these
&gt; strange argument types are accepted, they are &quot;unlikely&quot; to be correct.
&gt; 
&gt; &quot;unlikely-arg-type&quot;?

I like this best, so far.

Accordingly, the UI proposal would now be s.t. like

Unlikely argument type for Map.get() et al [Ignore/Warning/Error]
  [X] Allow arguments that could be cast to the expected type

(I don&apos;t think we want to say &quot;argument type passed to&quot;).

Maybe &quot;allow&quot; has too strong indication of legality wrt JLS? &quot;Ignore&quot; might be more correct, but also more confusing. I think &quot;accept&quot; would strike a good balance.

I&apos;d leave the following as a possible future addition:
  [X] Accept arguments of type java.lang.Object


As for the warning messages, we seem to agree on:

1200 = Invoking method {0} with an argument of type {1} is discouraged. Should use {2} to meet the semantics of declaring type {3}

For the stronger message, my initial thought was that uncastable types are definitely wrong. As the Set example shows, this isn&apos;t even true. Hence, &quot;uncastability&quot; is only an even stronger indication of an error, not a proof.

From that, 1201 could either just emphasize like in &quot;strongly discouraged&quot;, or harp more on a connection to the UI option, perhaps by saying:

1201 = Discouraged invocation of method {0}. Argument type {1} cannot be cast to the likely type {2} according to the declaring type {3}.

If this agreeable, we could assimilate 1200 by saying

1200 = Discouraged invocation of method {0}. Argument type {1} is incompatible to the likely type {2} according to the declaring type {3}.

I&apos;ll add tests, which spell these out with examples in my next patch.

I was also playing with different orders of parts of the message, but I think the current order succeeds in putting the most important parts first.


&gt; 1201 = Invoking method get(Object) with an argument of type Class is
&gt; unlikely to be correct. Should use String to meet the semantics of declaring
&gt; type Map&lt;String, Integer&gt;, or consider adding a cast to Object* if correct
&gt; 
&gt; * That&apos;s the most specific common supertype, and obviously if they do it
&gt; then they&apos;ll get warning 1200 if enabled.

The &quot;or&quot; part is too much, IMHO. I&apos;m not even sure if we want to *recommend* that workaround using a cast.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530566</commentid>
    <comment_count>15</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-12 09:35:28 -0400</bug_when>
    <thetext>(Replying to both posts at once)

&gt; &gt; Map&lt;String, Integer&gt; instead of MyVerySpecificMap.
&gt; 
&gt; That&apos;s exactly what the implementation in attachment 251444 [details] does :)

Great, I hadn&apos;t checked :)

&gt; I don&apos;t yet have tests matching your exact situation, but for all tests
&gt; using Set&lt;Short&gt; the message mentions the &apos;declaring type
&gt; Collection&lt;Short&gt;&apos;. This is done by searching the super type that is a
&gt; parameterization of one of the well-known trouble makers (Collection and
&gt; Map, so far)

I&apos;m sure it will work.
 
&gt; &gt; Oh, in the interests of succinctness, you could also remove the words
&gt; &gt; &apos;declaring type&apos; and &apos;method&apos; if you want - it&apos;s pretty obvious once it&apos;s
&gt; &gt; got examples.
&gt; 
&gt; And the previous point is exactly the reason why I say &apos;declaring type&apos;.
&gt; Still users will complain: why is the message talking about
&gt; Map&lt;String,Integer&gt;? I don&apos;t see this type anywhere in the flagged code. I
&gt; want to give at least some hint where to look.

You&apos;re right, it won&apos;t entirely solve the problem you&apos;re trying to solve. But I think most people will get it with either version (come on, they KNOW about the Map&lt;A,B&gt; they&apos;re using that the warning mentioned), and my feelings about keeping/removing the words are as weak as gravity :)

&gt; &gt; The Object solution would affect people who have Map&lt;String,Object&gt;.
&gt; 
&gt; I&apos;m not sure which effect you have in mind? For such map asking
&gt; containsValue(x) is always OK, with or without any special rule for
&gt; j.l.Object, but anyway I wouldn&apos;t include this rule just now.

I was thinking of the case where someone accidentally passes a value to a function that expects a key. Since the values are Objects, they&apos;d miss out on a warning. Granted they&apos;re already subject to the opposite risk (passing a key where a value was expected), but there&apos;s no sense in making it worse.

&gt; &gt; Still, what I had in mind is you
&gt; &gt; could check if the argument is a field access expression which resolves to
&gt; &gt; an affected parameter of an affected method. If that&apos;s not too onerous then
&gt; &gt; I think it is better.
&gt; 
&gt; too complex, IMHO.

Shrug. Wouldn&apos;t stop me, but OK :)

&gt; &gt; Another way we could look at it is, while there is a reason why these
&gt; &gt; strange argument types are accepted, they are &quot;unlikely&quot; to be correct.
&gt; &gt; 
&gt; &gt; &quot;unlikely-arg-type&quot;?
&gt; 
&gt; I like this best, so far.
&gt; 
&gt; Accordingly, the UI proposal would now be s.t. like
&gt; 
&gt; Unlikely argument type for Map.get() et al [Ignore/Warning/Error]
&gt;   [X] Allow arguments that could be cast to the expected type
&gt; 
&gt; (I don&apos;t think we want to say &quot;argument type passed to&quot;).

More succinctness - good :)

&gt; Maybe &quot;allow&quot; has too strong indication of legality wrt JLS? &quot;Ignore&quot; might
&gt; be more correct, but also more confusing. I think &quot;accept&quot; would strike a
&gt; good balance.

I noticed that too but was too tired (and felt I&apos;d spammed enough) to explore it. I agree - change it to &apos;Accept&apos;.

&gt; I&apos;d leave the following as a possible future addition:
&gt;   [X] Accept arguments of type java.lang.Object

Hardcoded to accept those for now? Mainly so we don&apos;t screw container wrappers up.

&gt; As for the warning messages, we seem to agree on:
&gt; 
&gt; 1200 = Invoking method {0} with an argument of type {1} is discouraged.
&gt; Should use {2} to meet the semantics of declaring type {3}
&gt; 
&gt; For the stronger message, my initial thought was that uncastable types are
&gt; definitely wrong. As the Set example shows, this isn&apos;t even true. Hence,
&gt; &quot;uncastability&quot; is only an even stronger indication of an error, not a proof.
&gt; 
&gt; From that, 1201 could either just emphasize like in &quot;strongly discouraged&quot;,
&gt; or harp more on a connection to the UI option, perhaps by saying:
&gt; 
&gt; 1201 = Discouraged invocation of method {0}. Argument type {1} cannot be
&gt; cast to the likely type {2} according to the declaring type {3}.
&gt; 
&gt; If this agreeable, we could assimilate 1200 by saying
&gt; 
&gt; 1200 = Discouraged invocation of method {0}. Argument type {1} is
&gt; incompatible to the likely type {2} according to the declaring type {3}.
&gt; 
&gt; I&apos;ll add tests, which spell these out with examples in my next patch.

That all sounds good, except grammatically it needs to be &apos;incompatible with&apos;. Or if you want to be clearer, I think &apos;not convertible to&apos; would convey the right meaning.

&gt; I was also playing with different orders of parts of the message, but I
&gt; think the current order succeeds in putting the most important parts first.

Agreed - that was what motivated my suggestion for 1201.

&gt; The &quot;or&quot; part is too much, IMHO. I&apos;m not even sure if we want to *recommend*
&gt; that workaround using a cast.

Fair point - leave it out. @SW is probably better than casting in such cases.

:)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530570</commentid>
    <comment_count>16</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-12 09:39:20 -0400</bug_when>
    <thetext>Playing further with the &apos;not convertible&apos; thing, we could consider saying &apos;not convertible&apos; for one and &apos;not convertible even with a cast&apos; for the other?

So you&apos;d have

1200 = Discouraged invocation of method {0}. Argument type {1} is not convertible to the likely type {2} according to the declaring type {3}.

1201 = Discouraged invocation of method {0}. Argument type {1} is not convertible to the likely type {2} according to the declaring type {3}, even with a cast.

Nah, don&apos;t like it. Stick with what you&apos;ve got. (Posting anyway just in case you do want to explore this.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530652</commentid>
    <comment_count>17</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-12 11:48:10 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43735</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530660</commentid>
    <comment_count>18</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-12 11:57:10 -0400</bug_when>
    <thetext>Shifted from linguistics back to engineering :)

(In reply to Eclipse Genie from comment #17)
&gt; New Gerrit change created: https://git.eclipse.org/r/43735

@Markus, do you want to comment on added API (constants in JavaCore and IProblem - plus new @SW token) and message wording?

I also Cc&apos;d you on bug 461999, marked that one as M7, though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530666</commentid>
    <comment_count>19</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-12 12:05:50 -0400</bug_when>
    <thetext>For better accessibility, here&apos;s the list of methods recognized by the change:

Collection.contains(Object)
Collection.remove(Object)

Collection.containsAll(Collection&lt;?&gt;)
Collection.removeAll(Collection&lt;?&gt;)
Collection.retainAll(Collection&lt;?&gt;)

List.indexOf(Object)
List.lastIndexOf(Object)

Map.containsKey(Object)
Map.get(Object)

Map.containsValue(Object)


Methods are also recognized via any sub-type of the above.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530747</commentid>
    <comment_count>20</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-12 15:06:37 -0400</bug_when>
    <thetext>A failure in BatchCompilerTest reminded me, that hasTypeBit() may trigger super type traversal, thus making lookup more eager than strictly necessary. I reduced this effect to the minimum by first comparing selectors and only then checking the receiver type.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530850</commentid>
    <comment_count>21</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-12 18:57:02 -0400</bug_when>
    <thetext>Gerrit change https://git.eclipse.org/r/43735 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=689526016f6ab442680e718d2760fc44e79dd9b5</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2530852</commentid>
    <comment_count>22</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-12 19:01:31 -0400</bug_when>
    <thetext>Released for 4.5 M6.

Let me know if I missed s.t. relevant.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531358</commentid>
    <comment_count>23</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-14 10:30:24 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43851</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531360</commentid>
    <comment_count>24</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-14 10:35:30 -0400</bug_when>
    <thetext>(In reply to Eclipse Genie from comment #23)
&gt; New Gerrit change created: https://git.eclipse.org/r/43851

This changes one of the options from [E/W/I] to [Enable/Disable] to better support the intended way to surface this in the options/preferences UI.

We still use two IProblems, just the way they are controlled via JavaCore options is changed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531387</commentid>
    <comment_count>25</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-14 12:12:39 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #24)
&gt; (In reply to Eclipse Genie from comment #23)
&gt; &gt; New Gerrit change created: https://git.eclipse.org/r/43851
&gt; 
&gt; This changes one of the options from [E/W/I] to [Enable/Disable] to better
&gt; support the intended way to surface this in the options/preferences UI.
&gt; 
&gt; We still use two IProblems, just the way they are controlled via JavaCore
&gt; options is changed.

Pushed directly via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=27e2724327c75ddbe7646447a4af212947b149ed to accommodate tiny javadoc corrections.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531540</commentid>
    <comment_count>26</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-15 12:12:19 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43884</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531544</commentid>
    <comment_count>27</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-15 12:27:51 -0400</bug_when>
    <thetext>(In reply to Eclipse Genie from comment #26)
&gt; New Gerrit change created: https://git.eclipse.org/r/43884

No, Genie. That commit is not for this bug, it just mentions this bug&apos;s number in its title.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531620</commentid>
    <comment_count>28</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-15 20:10:20 -0400</bug_when>
    <thetext>Gerrit change https://git.eclipse.org/r/43884 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=92a55fb8c61c817a37bdd13d873f8eba50e25d7d</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2531621</commentid>
    <comment_count>29</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-15 20:11:38 -0400</bug_when>
    <thetext>(In reply to Eclipse Genie from comment #28)
&gt; Gerrit change https://git.eclipse.org/r/43884 was merged to [master].
&gt; Commit:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/
&gt; ?id=92a55fb8c61c817a37bdd13d873f8eba50e25d7d

No, Genie. That commit is not for this bug, it just mentions this bug&apos;s number in its title.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532234</commentid>
    <comment_count>30</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2015-03-16 13:05:14 -0400</bug_when>
    <thetext>We should not enable new experimental options by default and let users be the guinea pigs.

The jdt.core repo contains about 20 such problems, and jdt.ui over 100. We first have scrutinize at least these invocations and be sure they are really problematic. That will also tell us if we should provide Quick Fixes for common problem patterns.

Stephan, can you please disable the main option for M6?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532351</commentid>
    <comment_count>31</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-16 16:41:37 -0400</bug_when>
    <thetext>Some analysis of reported warnings:

org.eclipse.jdt.core
total: 8 warnings
- 2 real bugs
- 6 cases pass a value of a super type of the expected type
  This is a (probably unconscious) shorthand for an instanceof check plus cast


Let&apos;s check if just flipping the sub-option gives an even better ratio:

- 2 warning are of the severe form &quot;cannot be cast&quot;
- 6 warnings say &quot;is incompatible with&quot;

Unfortunately, only 1 of the 2 bugs is in the &quot;uncastable&quot; group.

The other &quot;uncastable&quot; problem concerns a removeAll() invocation, where we could possibly relax the warning by comparing element types instead of collection types.

OTOH, we have a bug that escapes the weaker form of the warning. This happens, because an interface is involved, and hence types are considered as castable although totally unrelated.

That would mean for the small sample of o.e.j.core by flipping the sub-option we could reduce the number of reports to 1, with 0 false positives but 1 false negative.


It probably depends on how you look at the 6 cases that are not strictly bugs (from a cursory look most of the warnings in jdt.ui also fit into this group). I personally think those reports are still interesting, but I know that many users will not agree.

=====

When I started working on this bug I didn&apos;t expect this to be controversial (otherwise I would have started earlier), but seeing the request to disable by default I will simply revert this feature for Mars and start a discussion early after Mars. This will give us time to sharpen the analysis for the best possible hit-ratio.


I don&apos;t want to publish yet another warning that is off-by-default and is wasted to most users. Remember, switching the default after initial release doesn&apos;t reach any users that already persisted the preferences in their projects.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532353</commentid>
    <comment_count>32</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-16 16:44:15 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43973</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532360</commentid>
    <comment_count>33</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-16 16:55:40 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43974</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532382</commentid>
    <comment_count>34</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-16 17:30:06 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/43976</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532386</commentid>
    <comment_count>35</comment_count>
    <who name="Ben Davis">entheh</who>
    <bug_when>2015-03-16 17:40:06 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #31)
&gt; The other &quot;uncastable&quot; problem concerns a removeAll() invocation, where we
&gt; could possibly relax the warning by comparing element types instead of
&gt; collection types.

Absolutely - it&apos;s very common for example to go Set&lt;T&gt;.removeAll(List&lt;T&gt;), e.g. if we were iterating over the set and couldn&apos;t modify it until we finished. Definitely worth refining.

&gt; OTOH, we have a bug that escapes the weaker form of the warning. This
&gt; happens, because an interface is involved, and hence types are considered as
&gt; castable although totally unrelated.

Presumably because the compiler can&apos;t rule out that the class may have a subtype that implements the interface. One possible, pretty simple, refinement could be, &quot;Accept arguments that are a supertype of the expected type.&quot;

&gt; I don&apos;t want to publish yet another warning that is off-by-default and is
&gt; wasted to most users. Remember, switching the default after initial release
&gt; doesn&apos;t reach any users that already persisted the preferences in their
&gt; projects.

Agreed!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532389</commentid>
    <comment_count>36</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-03-16 17:53:50 -0400</bug_when>
    <thetext>Gerrit change https://git.eclipse.org/r/43973 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.ui.git/commit/?id=cfca412f57f26eae63a2010e2327c439d2554f16</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532392</commentid>
    <comment_count>37</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-03-16 18:02:10 -0400</bug_when>
    <thetext>(In reply to Ben Davis from comment #35)
&gt; (In reply to Stephan Herrmann from comment #31)
&gt; &gt; The other &quot;uncastable&quot; problem concerns a removeAll() invocation, where we
&gt; &gt; could possibly relax the warning by comparing element types instead of
&gt; &gt; collection types.
&gt; 
&gt; Absolutely - it&apos;s very common for example to go Set&lt;T&gt;.removeAll(List&lt;T&gt;),
&gt; e.g. if we were iterating over the set and couldn&apos;t modify it until we
&gt; finished. Definitely worth refining.

It&apos;s not about Set&lt;T&gt; vs. List&lt;T&gt; (both conform to Collection&lt;T&gt;), but about Collection&lt;Super&gt; vs. Collection&lt;Sub&gt;. A Collection&lt;Super&gt; is not castable to Collection&lt;Sub&gt;, but each contained element Super, is castable to Sub - which may be enough for the invocation to do s.t. useful.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2532406</commentid>
    <comment_count>38</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2015-03-16 18:43:47 -0400</bug_when>
    <thetext>A fix to add when this is resurrected:

Javadoc of org.eclipse.jdt.core.JavaCore.COMPILER_PB_DISCOURAGED_INVOCATION_ACCEPT_CASTABLE_ARGUMENT had typos in &quot;Possible values&quot; and &quot;Default&quot;:
Said e.g. &quot;enable&quot; instead of &quot;enabled&quot;.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="1"
              isprivate="0"
          >
            <attachid>251444</attachid>
            <date>2015-03-10 19:38:00 -0400</date>
            <delta_ts>2015-03-10 19:38:59 -0400</delta_ts>
            <desc>draft</desc>
            <filename>Bug-410218--Optional-warning-for-arguments-of-unexpe.patch</filename>
            <type>text/plain</type>
            <size>21194</size>
            <attacher name="Stephan Herrmann">stephan.herrmann</attacher>
            
              <data encoding="base64">ZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLmNvbXBpbGVyL3NyYy9vcmcv
ZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9uL1Byb2dyYW1taW5nUHJv
YmxlbXNUZXN0LmphdmEgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS50ZXN0cy5jb21waWxlci9zcmMv
b3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9Qcm9ncmFtbWlu
Z1Byb2JsZW1zVGVzdC5qYXZhCmluZGV4IGI5NzMzM2MuLmJhZDZhZTkgMTAwNjQ0Ci0tLSBhL29y
Zy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLmNvbXBpbGVyL3NyYy9vcmcvZWNsaXBzZS9qZHQvY29y
ZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9uL1Byb2dyYW1taW5nUHJvYmxlbXNUZXN0LmphdmEK
KysrIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9lY2xpcHNl
L2pkdC9jb3JlL3Rlc3RzL2NvbXBpbGVyL3JlZ3Jlc3Npb24vUHJvZ3JhbW1pbmdQcm9ibGVtc1Rl
c3QuamF2YQpAQCAtNDAsNyArNDAsNyBAQAogICAJLy8gT25seSB0aGUgaGlnaGVzdCBjb21wbGlh
bmNlIGxldmVsIGlzIHJ1bjsgYWRkIHRoZSBWTSBhcmd1bWVudAogICAJLy8gLURjb21wbGlhbmNl
PTEuNCAoZm9yIGV4YW1wbGUpIHRvIGxvd2VyIGl0IGlmIG5lZWRlZAogICAJc3RhdGljIHsKLS8v
ICAgIAlURVNUU19OQU1FUyA9IG5ldyBTdHJpbmdbXSB7ICJ0ZXN0MDA1NSIgfTsKKyAgICAJVEVT
VFNfTkFNRVMgPSBuZXcgU3RyaW5nW10geyAidGVzdEJ1ZzQxMDIxOCIgfTsKIC8vCQlURVNUU19O
VU1CRVJTID0gbmV3IGludFtdIHsgNTYgfTsKIC8vICAJVEVTVFNfUkFOR0UgPSBuZXcgaW50W10g
eyAxLCAtMSB9OwogICAJfQpAQCAtMjcwMyw0ICsyNzAzLDE1MiBAQAogCQl0cnVlLypzaG91bGRG
bHVzaE91dHB1dERpcmVjdG9yeSovLAogCQljdXN0b21PcHRpb25zKTsKIH0KKy8vIENvbGxlY3Rp
b246IGNvbnRhaW5zICYgcmVtb3ZlCitwdWJsaWMgdm9pZCB0ZXN0QnVnNDEwMjE4YSgpIHsKKwlp
ZiAodGhpcy5jb21wbGlhbmNlTGV2ZWwgPCBDbGFzc0ZpbGVDb25zdGFudHMuSkRLMV81KQorCQly
ZXR1cm47CisJcnVuTmVnYXRpdmVUZXN0KAorCQluZXcgU3RyaW5nW10geworCQkJIlguamF2YSIs
CisJCQkiaW1wb3J0IGphdmEudXRpbC4qO1xuIiArCisJCQkiY2xhc3MgWCB7XG4iICsKKwkJCSIg
IHZvaWQgdGVzdCgpIHtcbiIgKworCQkJIglTZXQ8U2hvcnQ+IHNldCA9IG5ldyBIYXNoU2V0PFNo
b3J0PigpO1xuIiArIAorCQkJIglzaG9ydCBvbmUgPSAxO1xuIiArIAorCQkJIglzZXQuYWRkKG9u
ZSk7XG4iICsgCisJCQkiXG4iICsgCisJCQkiCWlmIChzZXQuY29udGFpbnMoXCJPTkVcIikpIC8v
IGJhZFxuIiArCisJCQkiCQlzZXQucmVtb3ZlKFwiT05FXCIpOyAvLyBiYWRcbiIgKyAKKwkJCSIJ
aWYgKHNldC5jb250YWlucygxKSkgLy8gYmFkXG4iICsKKwkJCSIJCXNldC5yZW1vdmUoMSk7IC8v
IGJhZCAodHJpZXMgdG8gcmVtb3ZlIFwiSW50ZWdlciAxXCIpXG4iICsgCisJCQkiCVN5c3RlbS5v
dXQucHJpbnRsbihzZXQpOyAvLyBzaG93cyB0aGF0IHRoZSBcIlNob3J0IDFcIiBpcyBzdGlsbCBp
biFcbiIgKyAKKwkJCSJcbiIgKyAKKwkJCSIJaWYgKHNldC5jb250YWlucyhvbmUpKSAvLyBva1xu
IiArCisJCQkiCQlzZXQucmVtb3ZlKG9uZSk7IC8vIG9rXG4iICsgCisJCQkiCWlmIChzZXQuY29u
dGFpbnMoU2hvcnQudmFsdWVPZihvbmUpKSkgLy8gb2tcbiIgKworCQkJIgkJc2V0LnJlbW92ZShT
aG9ydC52YWx1ZU9mKG9uZSkpOyAvLyBva1xuIiArIAorCQkJIglTeXN0ZW0ub3V0LnByaW50bG4o
c2V0KTtcbiIgKworCQkJIiAgfVxuIiArCisJCQkifVxuIgorCQl9LAorCQkiLS0tLS0tLS0tLVxu
IiArIAorCQkiMS4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDgpXG4iICsgCisJCSIJaWYgKHNl
dC5jb250YWlucyhcIk9ORVwiKSkgLy8gYmFkXG4iICsgCisJCSIJICAgICAgICAgICAgICAgICBe
Xl5eXlxuIiArIAorCQkiRGlzY291cmFnZWQgYXJndW1lbnQgZm9yIG1ldGhvZCBjb250YWlucyhP
YmplY3QpLCBwcm92aWRlZCB0eXBlIFN0cmluZyBpcyBkZWZpbml0ZWx5IGluY29tcGF0aWJsZSB0
byB0eXBlIFNob3J0LiBEZWNsYXJpbmcgdHlwZSBpcyBDb2xsZWN0aW9uPFNob3J0PlxuIiArIAor
CQkiLS0tLS0tLS0tLVxuIiArIAorCQkiMi4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDkpXG4i
ICsgCisJCSIJc2V0LnJlbW92ZShcIk9ORVwiKTsgLy8gYmFkXG4iICsgCisJCSIJICAgICAgICAg
ICBeXl5eXlxuIiArIAorCQkiRGlzY291cmFnZWQgYXJndW1lbnQgZm9yIG1ldGhvZCByZW1vdmUo
T2JqZWN0KSwgcHJvdmlkZWQgdHlwZSBTdHJpbmcgaXMgZGVmaW5pdGVseSBpbmNvbXBhdGlibGUg
dG8gdHlwZSBTaG9ydC4gRGVjbGFyaW5nIHR5cGUgaXMgQ29sbGVjdGlvbjxTaG9ydD5cbiIgKyAK
KwkJIi0tLS0tLS0tLS1cbiIgKyAKKwkJIjMuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSAxMClc
biIgKyAKKwkJIglpZiAoc2V0LmNvbnRhaW5zKDEpKSAvLyBiYWRcbiIgKyAKKwkJIgkgICAgICAg
ICAgICAgICAgIF5cbiIgKyAKKwkJIkRpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgY29u
dGFpbnMoT2JqZWN0KSwgcHJvdmlkZWQgdHlwZSBpbnQgaXMgZGVmaW5pdGVseSBpbmNvbXBhdGli
bGUgdG8gdHlwZSBTaG9ydC4gRGVjbGFyaW5nIHR5cGUgaXMgQ29sbGVjdGlvbjxTaG9ydD5cbiIg
KyAKKwkJIi0tLS0tLS0tLS1cbiIgKyAKKwkJIjQuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSAx
MSlcbiIgKyAKKwkJIglzZXQucmVtb3ZlKDEpOyAvLyBiYWQgKHRyaWVzIHRvIHJlbW92ZSBcIklu
dGVnZXIgMVwiKVxuIiArIAorCQkiCSAgICAgICAgICAgXlxuIiArIAorCQkiRGlzY291cmFnZWQg
YXJndW1lbnQgZm9yIG1ldGhvZCByZW1vdmUoT2JqZWN0KSwgcHJvdmlkZWQgdHlwZSBpbnQgaXMg
ZGVmaW5pdGVseSBpbmNvbXBhdGlibGUgdG8gdHlwZSBTaG9ydC4gRGVjbGFyaW5nIHR5cGUgaXMg
Q29sbGVjdGlvbjxTaG9ydD5cbiIgKyAKKwkJIi0tLS0tLS0tLS1cbiIpOworfQorLy8gSGFzaFNl
dCB2cy4gVHJlZVNldCBvcjogcG90ZW50aWFsIHZzLiBkZWZpbml0ZSBidWcKK3B1YmxpYyB2b2lk
IHRlc3RCdWc0MTAyMThiKCkgeworCWlmICh0aGlzLmNvbXBsaWFuY2VMZXZlbCA8IENsYXNzRmls
ZUNvbnN0YW50cy5KREsxXzUpCisJCXJldHVybjsKKwlydW5OZWdhdGl2ZVRlc3QoCisJCW5ldyBT
dHJpbmdbXSB7CisJCQkiWC5qYXZhIiwKKwkJCSJpbXBvcnQgamF2YS51dGlsLio7XG4iICsKKwkJ
CSJjbGFzcyBYIHtcbiIgKworCQkJIiAgPFQ+IHZvaWQgdGVzdChTZXQ8SGFzaFNldDxUPj4gaHNz
LCBUcmVlU2V0PFQ+IHRzKSB7XG4iICsKKwkJCSIJaWYgKGhzcy5jb250YWlucyh0cykpIC8vIGJh
ZFxuIiArCisJCQkiCQloc3MucmVtb3ZlKHRzKTsgLy8gYmFkXG4iICsgCisJCQkiCWlmIChoc3Mu
Y29udGFpbnMoKFNldDxUPil0cykpIC8vIGxlc3MgYmFkXG4iICsKKwkJCSIJCWhzcy5yZW1vdmUo
KFNldDxUPil0cyk7IC8vIGxlc3MgYmFkXG4iICsgCisJCQkiICB9XG4iICsKKwkJCSJ9XG4iCisJ
CX0sCisJCSItLS0tLS0tLS0tXG4iICsgCisJCSIxLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUg
NClcbiIgKyAKKwkJIglpZiAoaHNzLmNvbnRhaW5zKHRzKSkgLy8gYmFkXG4iICsgCisJCSIJICAg
ICAgICAgICAgICAgICBeXlxuIiArIAorCQkiRGlzY291cmFnZWQgYXJndW1lbnQgZm9yIG1ldGhv
ZCBjb250YWlucyhPYmplY3QpLCBwcm92aWRlZCB0eXBlIFRyZWVTZXQ8VD4gaXMgZGVmaW5pdGVs
eSBpbmNvbXBhdGlibGUgdG8gdHlwZSBIYXNoU2V0PFQ+LiBEZWNsYXJpbmcgdHlwZSBpcyBDb2xs
ZWN0aW9uPEhhc2hTZXQ8VD4+XG4iICsgCisJCSItLS0tLS0tLS0tXG4iICsgCisJCSIyLiBFUlJP
UiBpbiBYLmphdmEgKGF0IGxpbmUgNSlcbiIgKyAKKwkJIgloc3MucmVtb3ZlKHRzKTsgLy8gYmFk
XG4iICsgCisJCSIJICAgICAgICAgICBeXlxuIiArIAorCQkiRGlzY291cmFnZWQgYXJndW1lbnQg
Zm9yIG1ldGhvZCByZW1vdmUoT2JqZWN0KSwgcHJvdmlkZWQgdHlwZSBUcmVlU2V0PFQ+IGlzIGRl
ZmluaXRlbHkgaW5jb21wYXRpYmxlIHRvIHR5cGUgSGFzaFNldDxUPi4gRGVjbGFyaW5nIHR5cGUg
aXMgQ29sbGVjdGlvbjxIYXNoU2V0PFQ+PlxuIiArIAorCQkiLS0tLS0tLS0tLVxuIiArIAorCQki
My4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDYpXG4iICsgCisJCSIJaWYgKGhzcy5jb250YWlu
cygoU2V0PFQ+KXRzKSkgLy8gbGVzcyBiYWRcbiIgKyAKKwkJIgkgICAgICAgICAgICAgICAgIF5e
Xl5eXl5eXl5cbiIgKyAKKwkJIkRpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgY29udGFp
bnMoT2JqZWN0KSwgc2hvdWxkIGJlIG9mIHR5cGUgSGFzaFNldDxUPiB0byBtYXRjaCB0aGUgZGVj
bGFyaW5nIHR5cGUgQ29sbGVjdGlvbjxIYXNoU2V0PFQ+PlxuIiArIAorCQkiLS0tLS0tLS0tLVxu
IiArIAorCQkiNC4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDcpXG4iICsgCisJCSIJaHNzLnJl
bW92ZSgoU2V0PFQ+KXRzKTsgLy8gbGVzcyBiYWRcbiIgKyAKKwkJIgkgICAgICAgICAgIF5eXl5e
Xl5eXl5cbiIgKyAKKwkJIkRpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgcmVtb3ZlKE9i
amVjdCksIHNob3VsZCBiZSBvZiB0eXBlIEhhc2hTZXQ8VD4gdG8gbWF0Y2ggdGhlIGRlY2xhcmlu
ZyB0eXBlIENvbGxlY3Rpb248SGFzaFNldDxUPj5cbiIgKyAKKwkJIi0tLS0tLS0tLS1cbiIpOwor
fQorLy8gTWFwOiBjb250YWlucyogJiByZW1vdmUKK3B1YmxpYyB2b2lkIHRlc3RCdWc0MTAyMThj
KCkgeworCWlmICh0aGlzLmNvbXBsaWFuY2VMZXZlbCA8IENsYXNzRmlsZUNvbnN0YW50cy5KREsx
XzUpCisJCXJldHVybjsKKwlydW5OZWdhdGl2ZVRlc3QoCisJCW5ldyBTdHJpbmdbXSB7CisJCQki
WC5qYXZhIiwKKwkJCSJpbXBvcnQgamF2YS51dGlsLio7XG4iICsKKwkJCSJjbGFzcyBYIHtcbiIg
KworCQkJIiAgdm9pZCB0ZXN0KE1hcDw/IGV4dGVuZHMgTnVtYmVyLCBOdW1iZXI+IG0pIHtcbiIg
KworCQkJIglpZiAobS5jb250YWluc0tleShcIk9ORVwiKSkgLy8gYmFkXG4iICsgCisJCQkiCQlt
LnJlbW92ZShcIk9ORVwiKTsgLy8gYmFkXG4iICsKKwkJCSIJaWYgKG0uY29udGFpbnNWYWx1ZShc
Ik9ORVwiKSkgLy8gYmFkXG4iICsgCisJCQkiCQltLnJlbW92ZShcIk9ORVwiKTsgLy8gYmFkXG4i
ICsgCisJCQkiCXNob3J0IG9uZSA9IDE7XG4iICsKKwkJCSIJaWYgKG0uY29udGFpbnNLZXkob25l
KSkgLy8gYWxtb3N0IG9rXG4iICsKKwkJCSIJCW0ucmVtb3ZlKG9uZSk7IC8vIGFsbW9zdCBva1xu
IiArCisJCQkiCWlmIChtLmNvbnRhaW5zVmFsdWUoU2hvcnQudmFsdWVPZihvbmUpKSkgLy8gb2tc
biIgKyAKKwkJCSIJCW0ucmVtb3ZlKFNob3J0LnZhbHVlT2Yob25lKSk7IC8vIGFsbW9zdCBva1xu
IiArIAorCQkJIiAgfVxuIiArCisJCQkifVxuIgorCQl9LAorCQkiLS0tLS0tLS0tLVxuIiArIAor
CQkiMS4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDQpXG4iICsgCisJCSIJaWYgKG0uY29udGFp
bnNLZXkoXCJPTkVcIikpIC8vIGJhZFxuIiArIAorCQkiCSAgICAgICAgICAgICAgICAgIF5eXl5e
XG4iICsgCisJCSJEaXNjb3VyYWdlZCBhcmd1bWVudCBmb3IgbWV0aG9kIGNvbnRhaW5zS2V5KE9i
amVjdCksIHByb3ZpZGVkIHR5cGUgU3RyaW5nIGlzIGRlZmluaXRlbHkgaW5jb21wYXRpYmxlIHRv
IHR5cGUgY2FwdHVyZSMxLW9mID8gZXh0ZW5kcyBOdW1iZXIuIERlY2xhcmluZyB0eXBlIGlzIE1h
cDxjYXB0dXJlIzEtb2YgPyBleHRlbmRzIE51bWJlcixOdW1iZXI+XG4iICsgCisJCSItLS0tLS0t
LS0tXG4iICsgCisJCSIyLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgNSlcbiIgKyAKKwkJIglt
LnJlbW92ZShcIk9ORVwiKTsgLy8gYmFkXG4iICsgCisJCSIJICAgICAgICAgXl5eXl5cbiIgKyAK
KwkJIkRpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgcmVtb3ZlKE9iamVjdCksIHByb3Zp
ZGVkIHR5cGUgU3RyaW5nIGlzIGRlZmluaXRlbHkgaW5jb21wYXRpYmxlIHRvIHR5cGUgY2FwdHVy
ZSMyLW9mID8gZXh0ZW5kcyBOdW1iZXIuIERlY2xhcmluZyB0eXBlIGlzIE1hcDxjYXB0dXJlIzIt
b2YgPyBleHRlbmRzIE51bWJlcixOdW1iZXI+XG4iICsgCisJCSItLS0tLS0tLS0tXG4iICsgCisJ
CSIzLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgNilcbiIgKyAKKwkJIglpZiAobS5jb250YWlu
c1ZhbHVlKFwiT05FXCIpKSAvLyBiYWRcbiIgKyAKKwkJIgkgICAgICAgICAgICAgICAgICAgIF5e
Xl5eXG4iICsgCisJCSJEaXNjb3VyYWdlZCBhcmd1bWVudCBmb3IgbWV0aG9kIGNvbnRhaW5zVmFs
dWUoT2JqZWN0KSwgcHJvdmlkZWQgdHlwZSBTdHJpbmcgaXMgZGVmaW5pdGVseSBpbmNvbXBhdGli
bGUgdG8gdHlwZSBOdW1iZXIuIERlY2xhcmluZyB0eXBlIGlzIE1hcDxjYXB0dXJlIzMtb2YgPyBl
eHRlbmRzIE51bWJlcixOdW1iZXI+XG4iICsgCisJCSItLS0tLS0tLS0tXG4iICsgCisJCSI0LiBF
UlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgNylcbiIgKyAKKwkJIgltLnJlbW92ZShcIk9ORVwiKTsg
Ly8gYmFkXG4iICsgCisJCSIJICAgICAgICAgXl5eXl5cbiIgKyAKKwkJIkRpc2NvdXJhZ2VkIGFy
Z3VtZW50IGZvciBtZXRob2QgcmVtb3ZlKE9iamVjdCksIHByb3ZpZGVkIHR5cGUgU3RyaW5nIGlz
IGRlZmluaXRlbHkgaW5jb21wYXRpYmxlIHRvIHR5cGUgY2FwdHVyZSM0LW9mID8gZXh0ZW5kcyBO
dW1iZXIuIERlY2xhcmluZyB0eXBlIGlzIE1hcDxjYXB0dXJlIzQtb2YgPyBleHRlbmRzIE51bWJl
cixOdW1iZXI+XG4iICsgCisJCSItLS0tLS0tLS0tXG4iICsgCisJCSI1LiBFUlJPUiBpbiBYLmph
dmEgKGF0IGxpbmUgOSlcbiIgKyAKKwkJIglpZiAobS5jb250YWluc0tleShvbmUpKSAvLyBhbG1v
c3Qgb2tcbiIgKyAKKwkJIgkgICAgICAgICAgICAgICAgICBeXl5cbiIgKyAKKwkJIkRpc2NvdXJh
Z2VkIGFyZ3VtZW50IGZvciBtZXRob2QgY29udGFpbnNLZXkoT2JqZWN0KSwgc2hvdWxkIGJlIG9m
IHR5cGUgY2FwdHVyZSM1LW9mID8gZXh0ZW5kcyBOdW1iZXIgdG8gbWF0Y2ggdGhlIGRlY2xhcmlu
ZyB0eXBlIE1hcDxjYXB0dXJlIzUtb2YgPyBleHRlbmRzIE51bWJlcixOdW1iZXI+XG4iICsgCisJ
CSItLS0tLS0tLS0tXG4iICsgCisJCSI2LiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgMTApXG4i
ICsgCisJCSIJbS5yZW1vdmUob25lKTsgLy8gYWxtb3N0IG9rXG4iICsgCisJCSIJICAgICAgICAg
Xl5eXG4iICsgCisJCSJEaXNjb3VyYWdlZCBhcmd1bWVudCBmb3IgbWV0aG9kIHJlbW92ZShPYmpl
Y3QpLCBzaG91bGQgYmUgb2YgdHlwZSBjYXB0dXJlIzYtb2YgPyBleHRlbmRzIE51bWJlciB0byBt
YXRjaCB0aGUgZGVjbGFyaW5nIHR5cGUgTWFwPGNhcHR1cmUjNi1vZiA/IGV4dGVuZHMgTnVtYmVy
LE51bWJlcj5cbiIgKyAKKwkJIi0tLS0tLS0tLS1cbiIgKyAKKwkJIjcuIEVSUk9SIGluIFguamF2
YSAoYXQgbGluZSAxMilcbiIgKyAKKwkJIgltLnJlbW92ZShTaG9ydC52YWx1ZU9mKG9uZSkpOyAv
LyBhbG1vc3Qgb2tcbiIgKyAKKwkJIgkgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5cbiIgKyAK
KwkJIkRpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgcmVtb3ZlKE9iamVjdCksIHNob3Vs
ZCBiZSBvZiB0eXBlIGNhcHR1cmUjOC1vZiA/IGV4dGVuZHMgTnVtYmVyIHRvIG1hdGNoIHRoZSBk
ZWNsYXJpbmcgdHlwZSBNYXA8Y2FwdHVyZSM4LW9mID8gZXh0ZW5kcyBOdW1iZXIsTnVtYmVyPlxu
IiArIAorCQkiLS0tLS0tLS0tLVxuIik7Cit9CiB9ClwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmls
ZQpkaWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2Uv
amR0L2NvcmUvY29tcGlsZXIvSVByb2JsZW0uamF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2Nv
bXBpbGVyL29yZy9lY2xpcHNlL2pkdC9jb3JlL2NvbXBpbGVyL0lQcm9ibGVtLmphdmEKaW5kZXgg
ZDMwMTM1Zi4uZTcwYjBhZCAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGls
ZXIvb3JnL2VjbGlwc2UvamR0L2NvcmUvY29tcGlsZXIvSVByb2JsZW0uamF2YQorKysgYi9vcmcu
ZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvY29yZS9jb21waWxlci9J
UHJvYmxlbS5qYXZhCkBAIC0xODQ1LDQgKzE4NDUsOSBAQAogCS8qKiBAZGVwcmVjYXRlZCAtIHBy
b2JsZW0gaXMgbm8gbG9uZ2VyIGdlbmVyYXRlZCAoaW1wbGVtZW50YXRpb24gaXNzdWUgaGFzIGJl
ZW4gcmVzb2x2ZWQpCiAJICogQHNpbmNlIDMuMTAgKi8KIAlpbnQgTGFtYmRhU2hhcGVDb21wdXRh
dGlvbkVycm9yID0gMTEwMTsKKwkKKwkvKiogQHNpbmNlIDMuMTEgKi8KKwlpbnQgRGlzY291cmFn
ZWRJbnZvY2F0aW9uT2ZEYW5nZXJvdXNTaWduYXR1cmUgPSAxMjAwOworCS8qKiBAc2luY2UgMy4x
MSAqLworCWludCBTdHJvbmdseURpc2NvdXJhZ2VkSW52b2NhdGlvbk9mRGFuZ2Vyb3VzU2lnbmF0
dXJlID0gMTIwMTsKIH0KZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVy
L29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTWVzc2FnZVNlbmQuamF2YSBi
L29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9j
b21waWxlci9hc3QvTWVzc2FnZVNlbmQuamF2YQppbmRleCA2YzJhZGU5Li5hZTg2OTBiIDEwMDY0
NAotLS0gYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50
ZXJuYWwvY29tcGlsZXIvYXN0L01lc3NhZ2VTZW5kLmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0
LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9NZXNz
YWdlU2VuZC5qYXZhCkBAIC04NCw2ICs4NCw3IEBACiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0Lmlu
dGVybmFsLmNvbXBpbGVyLmxvb2t1cC5NaXNzaW5nVHlwZUJpbmRpbmc7CiBpbXBvcnQgb3JnLmVj
bGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5QYXJhbWV0ZXJpemVkR2VuZXJpY01l
dGhvZEJpbmRpbmc7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxv
b2t1cC5QYXJhbWV0ZXJpemVkTWV0aG9kQmluZGluZzsKK2ltcG9ydCBvcmcuZWNsaXBzZS5qZHQu
aW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlBhcmFtZXRlcml6ZWRUeXBlQmluZGluZzsKIGltcG9y
dCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlBvbHlQYXJhbWV0ZXJp
emVkR2VuZXJpY01ldGhvZEJpbmRpbmc7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFs
LmNvbXBpbGVyLmxvb2t1cC5Qb2x5VHlwZUJpbmRpbmc7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0
LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5Qb2x5bW9ycGhpY01ldGhvZEJpbmRpbmc7CkBAIC0x
NTUsNiArMTU2LDI2IEBACiAJCQkJCWZvciAoaW50IGo9MDsgajxsZW47IGorKykKIAkJCQkJCXJl
Y29yZENhbGxpbmdDbG9zZShjdXJyZW50U2NvcGUsIGZsb3dDb250ZXh0LCBmbG93SW5mbywgdGhp
cy5hcmd1bWVudHNbal0pOwogCQkJCQlicmVhazsKKwkJCQl9CisJCQl9CisJCX0KKwl9CisJaWYg
KGNvbXBpbGVyT3B0aW9ucy5hbmFseXNlRGFuZ2Vyb3VzU2lnbmF0dXJlcyAmJiB0aGlzLmJpbmRp
bmcuaXNWYWxpZEJpbmRpbmcoKSkgeworCQlUeXBlQmluZGluZ1tdIHNpZ25hdHVyZVJlcGxhY2Vt
ZW50ID0gZGV0ZWN0QW5kUmVwbGFjZURhbmdlcm91c1NpZ25hdHVyZShjdXJyZW50U2NvcGUpOwor
CQlpZiAoc2lnbmF0dXJlUmVwbGFjZW1lbnQgIT0gbnVsbCkgeworCQkJaW50IGxlbiA9IHRoaXMu
YXJndW1lbnRUeXBlcy5sZW5ndGg7CisJCQlmb3IgKGludCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7
CisJCQkJVHlwZUJpbmRpbmcgZXhwZWN0ZWRBcmd1bWVudFR5cGUgPSBzaWduYXR1cmVSZXBsYWNl
bWVudFtpXTsKKwkJCQlUeXBlQmluZGluZyBhcmd1bWVudFR5cGUgPSB0aGlzLmFyZ3VtZW50VHlw
ZXNbaV07CisJCQkJaWYgKGFyZ3VtZW50VHlwZS5pc0Jhc2VUeXBlKCkpCisJCQkJCWFyZ3VtZW50
VHlwZSA9IGN1cnJlbnRTY29wZS5ib3hpbmcoYXJndW1lbnRUeXBlKTsKKwkJCQlpZiAoIWFyZ3Vt
ZW50VHlwZS5pc0NvbXBhdGlibGVXaXRoKGV4cGVjdGVkQXJndW1lbnRUeXBlLCBjdXJyZW50U2Nv
cGUpKSB7CisJCQkJCWlmICghY2hlY2tDYXN0VHlwZXNDb21wYXRpYmlsaXR5KGN1cnJlbnRTY29w
ZSwgZXhwZWN0ZWRBcmd1bWVudFR5cGUsIGFyZ3VtZW50VHlwZSwgdGhpcy5hcmd1bWVudHNbaV0p
KQorCQkJCQkJY3VycmVudFNjb3BlLnByb2JsZW1SZXBvcnRlcigpLnN0cm9uZ2x5RGlzY291cmFn
ZWRJbnZvY2F0aW9uT2ZEYW5nZXJvdXNTaWduYXR1cmUodGhpcy5iaW5kaW5nLCB0aGlzLmFyZ3Vt
ZW50c1tpXSwKKwkJCQkJCQkJZXhwZWN0ZWRBcmd1bWVudFR5cGUsIHNpZ25hdHVyZVJlcGxhY2Vt
ZW50W2xlbl0pOworCQkJCQllbHNlCisJCQkJCQljdXJyZW50U2NvcGUucHJvYmxlbVJlcG9ydGVy
KCkuZGlzY291cmFnZWRJbnZvY2F0aW9uT2ZEYW5nZXJvdXNTaWduYXR1cmUodGhpcy5iaW5kaW5n
LCB0aGlzLmFyZ3VtZW50c1tpXSwKKwkJCQkJCQkJZXhwZWN0ZWRBcmd1bWVudFR5cGUsIHNpZ25h
dHVyZVJlcGxhY2VtZW50W2xlbl0pOwogCQkJCX0KIAkJCX0KIAkJfQpAQCAtMjk0LDYgKzMxNSwz
NyBAQAogCX0KIAlyZXR1cm4gMDsKIH0KK1R5cGVCaW5kaW5nW10gZGV0ZWN0QW5kUmVwbGFjZURh
bmdlcm91c1NpZ25hdHVyZShTY29wZSBzY29wZSkgeworCVR5cGVCaW5kaW5nW10gcGFyYW1ldGVy
cyA9IHRoaXMuYmluZGluZy5wYXJhbWV0ZXJzOworCWlmICh0aGlzLmFjdHVhbFJlY2VpdmVyVHlw
ZS5oYXNUeXBlQml0KFR5cGVJZHMuQml0TWFwKSkgeworCQlpZiAocGFyYW1ldGVycy5sZW5ndGgg
PT0gMSAmJiBwYXJhbWV0ZXJzWzBdLmlkID09IFR5cGVJZHMuVF9KYXZhTGFuZ09iamVjdCkgewor
CQkJaWYgKENoYXJPcGVyYXRpb24uZXF1YWxzKHRoaXMuc2VsZWN0b3IsIFR5cGVDb25zdGFudHMu
UkVNT1ZFKQorCQkJCQl8fCBDaGFyT3BlcmF0aW9uLmVxdWFscyh0aGlzLnNlbGVjdG9yLCBUeXBl
Q29uc3RhbnRzLkNPTlRBSU5TX0tFWSkpCisJCQl7CisJCQkJUmVmZXJlbmNlQmluZGluZyBtYXBU
eXBlID0gdGhpcy5hY3R1YWxSZWNlaXZlclR5cGUuZmluZFN1cGVyVHlwZU9yaWdpbmF0aW5nRnJv
bShUeXBlSWRzLlRfSmF2YVV0aWxNYXAsIGZhbHNlKTsKKwkJCQlpZiAobWFwVHlwZSBpbnN0YW5j
ZW9mIFBhcmFtZXRlcml6ZWRUeXBlQmluZGluZykKKwkJCQkJcmV0dXJuIG5ldyBUeXBlQmluZGlu
Z1tdIHsgKChQYXJhbWV0ZXJpemVkVHlwZUJpbmRpbmcpbWFwVHlwZSkudHlwZUFyZ3VtZW50cygp
WzBdLCBtYXBUeXBlIH07CisJCQl9CisJCQlpZiAoQ2hhck9wZXJhdGlvbi5lcXVhbHModGhpcy5z
ZWxlY3RvciwgVHlwZUNvbnN0YW50cy5DT05UQUlOU19WQUxVRSkpCisJCQl7CisJCQkJUmVmZXJl
bmNlQmluZGluZyBtYXBUeXBlID0gdGhpcy5hY3R1YWxSZWNlaXZlclR5cGUuZmluZFN1cGVyVHlw
ZU9yaWdpbmF0aW5nRnJvbShUeXBlSWRzLlRfSmF2YVV0aWxNYXAsIGZhbHNlKTsKKwkJCQlpZiAo
bWFwVHlwZSBpbnN0YW5jZW9mIFBhcmFtZXRlcml6ZWRUeXBlQmluZGluZykKKwkJCQkJcmV0dXJu
IG5ldyBUeXBlQmluZGluZ1tdIHsgKChQYXJhbWV0ZXJpemVkVHlwZUJpbmRpbmcpbWFwVHlwZSku
dHlwZUFyZ3VtZW50cygpWzFdLCBtYXBUeXBlIH07CisJCQl9CisJCX0KKwl9IGVsc2UgaWYgKHRo
aXMuYWN0dWFsUmVjZWl2ZXJUeXBlLmhhc1R5cGVCaXQoVHlwZUlkcy5CaXRDb2xsZWN0aW9uKSkg
eworCQlpZiAocGFyYW1ldGVycy5sZW5ndGggPT0gMSAmJiBwYXJhbWV0ZXJzWzBdLmlkID09IFR5
cGVJZHMuVF9KYXZhTGFuZ09iamVjdCkgeworCQkJaWYgKENoYXJPcGVyYXRpb24uZXF1YWxzKHRo
aXMuc2VsZWN0b3IsIFR5cGVDb25zdGFudHMuUkVNT1ZFKQorCQkJCQl8fCBDaGFyT3BlcmF0aW9u
LmVxdWFscyh0aGlzLnNlbGVjdG9yLCBUeXBlQ29uc3RhbnRzLkNPTlRBSU5TKSkKKwkJCXsKKwkJ
CQlSZWZlcmVuY2VCaW5kaW5nIG1hcFR5cGUgPSB0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZS5maW5k
U3VwZXJUeXBlT3JpZ2luYXRpbmdGcm9tKFR5cGVJZHMuVF9KYXZhVXRpbENvbGxlY3Rpb24sIGZh
bHNlKTsKKwkJCQlpZiAobWFwVHlwZS5pc1BhcmFtZXRlcml6ZWRUeXBlKCkpCisJCQkJCXJldHVy
biBuZXcgVHlwZUJpbmRpbmdbXSB7ICgoUGFyYW1ldGVyaXplZFR5cGVCaW5kaW5nKW1hcFR5cGUp
LnR5cGVBcmd1bWVudHMoKVswXSwgbWFwVHlwZSB9OworCQkJfQorCQl9CisJfQorCXJldHVybiBu
dWxsOyAvLyBub3QgcmVwbGFjaW5nCit9CiBwcml2YXRlIEZsb3dJbmZvIGFuYWx5c2VCb29sZWFu
QXNzZXJ0aW9uKEJsb2NrU2NvcGUgY3VycmVudFNjb3BlLCBFeHByZXNzaW9uIGFyZ3VtZW50LAog
CQlGbG93Q29udGV4dCBmbG93Q29udGV4dCwgRmxvd0luZm8gZmxvd0luZm8sIGJvb2xlYW4gd2Fz
SW5zaWRlQXNzZXJ0LCBib29sZWFuIHBhc3NPblRydWUpCiB7CmRpZmYgLS1naXQgYS9vcmcuZWNs
aXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIv
aW1wbC9Db21waWxlck9wdGlvbnMuamF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVy
L29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9pbXBsL0NvbXBpbGVyT3B0aW9ucy5q
YXZhCmluZGV4IGExYzJhMjQuLmIyMWVkZGUgMTAwNjQ0Ci0tLSBhL29yZy5lY2xpcHNlLmpkdC5j
b3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9pbXBsL0NvbXBp
bGVyT3B0aW9ucy5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9l
Y2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9pbXBsL0NvbXBpbGVyT3B0aW9ucy5qYXZhCkBA
IC00NjYsNiArNDY2LDggQEAKIAkvKiogTm90IGRpcmVjdGx5IGNvbmZpZ3VyYWJsZSwgZGVyaXZl
ZCBmcm9tIG90aGVyIG9wdGlvbnMgYnkgTG9va3VwRW52aXJvbm1lbnQudXNlc051bGxUeXBlQW5u
b3RhdGlvbnMoKSAqLwogCXB1YmxpYyBCb29sZWFuIHVzZU51bGxUeXBlQW5ub3RhdGlvbnMgPSBu
dWxsOwogCisJcHVibGljIGJvb2xlYW4gYW5hbHlzZURhbmdlcm91c1NpZ25hdHVyZXMgPSB0cnVl
OyAvLyBGSVhNRTogY29uZmlndXJhYmxlCisKIAkvLyBrZWVwIGluIHN5bmMgd2l0aCB3YXJuaW5n
VG9rZW5Ub0lycml0YW50IGFuZCB3YXJuaW5nVG9rZW5Gcm9tSXJyaXRhbnQKIAlwdWJsaWMgZmlu
YWwgc3RhdGljIFN0cmluZ1tdIHdhcm5pbmdUb2tlbnMgPSB7CiAJCSJhbGwiLCAvLyROT04tTkxT
LTEkCmRpZmYgLS1naXQgYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBz
ZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1BhcmFtZXRlcml6ZWRUeXBlQmluZGluZy5q
YXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVy
bmFsL2NvbXBpbGVyL2xvb2t1cC9QYXJhbWV0ZXJpemVkVHlwZUJpbmRpbmcuamF2YQppbmRleCA5
NDliZDJlLi4zYWZkYjFkIDEwMDY0NAotLS0gYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxl
ci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1BhcmFtZXRlcml6ZWRU
eXBlQmluZGluZy5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9l
Y2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAvUGFyYW1ldGVyaXplZFR5cGVCaW5k
aW5nLmphdmEKQEAgLTg3LDYgKzg3LDcgQEAKIAkJaWYgKGVuY2xvc2luZ1R5cGUgIT0gbnVsbCAm
JiBlbmNsb3NpbmdUeXBlLmhhc051bGxUeXBlQW5ub3RhdGlvbnMoKSkKIAkJCXRoaXMudGFnQml0
cyB8PSBUYWdCaXRzLkhhc051bGxUeXBlQW5ub3RhdGlvbjsKIAkJdGhpcy50YWdCaXRzIHw9ICBU
YWdCaXRzLkhhc1VucmVzb2x2ZWRUeXBlVmFyaWFibGVzOyAvLyBjbGVhcmVkIGluIHJlc29sdmUo
KQorCQl0aGlzLnR5cGVCaXRzID0gdHlwZS50eXBlQml0czsKIAl9CiAKIAkvKioKZGlmZiAtLWdp
dCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9sb29rdXAvUmVmZXJlbmNlQmluZGluZy5qYXZhIGIvb3JnLmVjbGlwc2UuamR0
LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9S
ZWZlcmVuY2VCaW5kaW5nLmphdmEKaW5kZXggNjFjYjlmOS4uYjFjMGY1YSAxMDA2NDQKLS0tIGEv
b3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2Nv
bXBpbGVyL2xvb2t1cC9SZWZlcmVuY2VCaW5kaW5nLmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0
LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9S
ZWZlcmVuY2VCaW5kaW5nLmphdmEKQEAgLTQ5NywxMyArNDk3LDIxIEBACiAJCQkJCQlpZiAoQ2hh
ck9wZXJhdGlvbi5lcXVhbHMocGFja2FnZU5hbWUsIFR5cGVDb25zdGFudHMuVVRJTCkpIHsKIAkJ
CQkJCQlzd2l0Y2ggKHR5cGVOYW1lWzBdKSB7CiAJCQkJCQkJCWNhc2UgJ0MnIDoKLQkJCQkJCQkJ
CWlmIChDaGFyT3BlcmF0aW9uLmVxdWFscyh0eXBlTmFtZSwgVHlwZUNvbnN0YW50cy5KQVZBX1VU
SUxfQ09MTEVDVElPTlsyXSkpCisJCQkJCQkJCQlpZiAoQ2hhck9wZXJhdGlvbi5lcXVhbHModHlw
ZU5hbWUsIFR5cGVDb25zdGFudHMuSkFWQV9VVElMX0NPTExFQ1RJT05bMl0pKSB7CiAJCQkJCQkJ
CQkJdGhpcy5pZCA9IFR5cGVJZHMuVF9KYXZhVXRpbENvbGxlY3Rpb247CisJCQkJCQkJCQkJdGhp
cy50eXBlQml0cyB8PSBUeXBlSWRzLkJpdENvbGxlY3Rpb247CisJCQkJCQkJCQl9CQkJCQkJCQkJ
CQogCQkJCQkJCQkJcmV0dXJuOwogCQkJCQkJCQljYXNlICdJJyA6CiAJCQkJCQkJCQlpZiAoQ2hh
ck9wZXJhdGlvbi5lcXVhbHModHlwZU5hbWUsIFR5cGVDb25zdGFudHMuSkFWQV9VVElMX0lURVJB
VE9SWzJdKSkKIAkJCQkJCQkJCQl0aGlzLmlkID0gVHlwZUlkcy5UX0phdmFVdGlsSXRlcmF0b3I7
CiAJCQkJCQkJCQlyZXR1cm47CisJCQkJCQkJCWNhc2UgJ00nIDoKKwkJCQkJCQkJCWlmIChDaGFy
T3BlcmF0aW9uLmVxdWFscyh0eXBlTmFtZSwgVHlwZUNvbnN0YW50cy5KQVZBX1VUSUxfTUFQWzJd
KSkgeworCQkJCQkJCQkJCXRoaXMuaWQgPSBUeXBlSWRzLlRfSmF2YVV0aWxNYXA7CisJCQkJCQkJ
CQkJdGhpcy50eXBlQml0cyB8PSBUeXBlSWRzLkJpdE1hcDsKKwkJCQkJCQkJCX0KKwkJCQkJCQkJ
CXJldHVybjsKIAkJCQkJCQkJY2FzZSAnTycgOgogCQkJCQkJCQkJaWYgKENoYXJPcGVyYXRpb24u
ZXF1YWxzKHR5cGVOYW1lLCBUeXBlQ29uc3RhbnRzLkpBVkFfVVRJTF9PQkpFQ1RTWzJdKSkKIAkJ
CQkJCQkJCQl0aGlzLmlkID0gVHlwZUlkcy5UX0phdmFVdGlsT2JqZWN0czsKZGlmZiAtLWdpdCBh
L29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9j
b21waWxlci9sb29rdXAvVHlwZUNvbnN0YW50cy5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUv
Y29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9UeXBlQ29u
c3RhbnRzLmphdmEKaW5kZXggNGNjOWJkYS4uYTQyM2I5ZiAxMDA2NDQKLS0tIGEvb3JnLmVjbGlw
c2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xv
b2t1cC9UeXBlQ29uc3RhbnRzLmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGls
ZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9UeXBlQ29uc3RhbnRz
LmphdmEKQEAgLTMyOSw2ICszMjksMTUgQEAKIAljaGFyW11bXSBDT01fR09PR0xFX0lOSkVDVF9J
TkpFQ1QgPSBuZXcgY2hhcltdW10ge0NPTSwgR09PR0xFLCBJTkpFQ1RfUEFDS0FHRSwgSU5KRUNU
X1RZUEUgfTsKIAkvLyAgICBkZXRhaWwgZm9yIHRoZSBhYm92ZToKIAljaGFyW10gT1BUSU9OQUwg
PSAib3B0aW9uYWwiLnRvQ2hhckFycmF5KCk7IC8vJE5PTi1OTFMtMSQKKwkKKwkvLyB3ZWxsLWtu
b3duIG1ldGhvZHMgd2l0aCAiZGFuZ2Vyb3VzIiBzaWduYXR1cmVzOgorCWNoYXJbXVtdIEpBVkFf
VVRJTF9NQVAgPSBuZXcgY2hhcltdW10geyBKQVZBLCBVVElMLCAiTWFwIi50b0NoYXJBcnJheSgp
IH07IC8vJE5PTi1OTFMtMSQKKwljaGFyW10gR0VUID0gImdldCIudG9DaGFyQXJyYXkoKTsgLy8k
Tk9OLU5MUy0xJAorCWNoYXJbXSBSRU1PVkUgPSAicmVtb3ZlIi50b0NoYXJBcnJheSgpOyAvLyRO
T04tTkxTLTEkCisJY2hhcltdIENPTlRBSU5TX0tFWSA9ICJjb250YWluc0tleSIudG9DaGFyQXJy
YXkoKTsgLy8kTk9OLU5MUy0xJAorCWNoYXJbXSBDT05UQUlOU19WQUxVRSA9ICJjb250YWluc1Zh
bHVlIi50b0NoYXJBcnJheSgpOyAvLyROT04tTkxTLTEkCisJLy8gZm9yIENvbGxlY3Rpb24uY29u
dGFpbnM6CisJY2hhcltdIENPTlRBSU5TID0gImNvbnRhaW5zIi50b0NoYXJBcnJheSgpOyAvLyRO
T04tTkxTLTEkCiAKIAkvLyBDb25zdHJhaW50cyBmb3IgZ2VuZXJpYyB0eXBlIGFyZ3VtZW50IGlu
ZmVyZW5jZQogCWludCBDT05TVFJBSU5UX0VRVUFMID0gMDsJCS8vIEFjdHVhbCA9IEZvcm1hbApk
aWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9UeXBlSWRzLmphdmEgYi9vcmcuZWNsaXBzZS5qZHQu
Y29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1R5
cGVJZHMuamF2YQppbmRleCBjYzcxMTQ4Li4xZGRkNmJjIDEwMDY0NAotLS0gYS9vcmcuZWNsaXBz
ZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9v
a3VwL1R5cGVJZHMuamF2YQorKysgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcv
ZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1R5cGVJZHMuamF2YQpAQCAtMTI5
LDYgKzEyOSwxMCBAQAogCWZpbmFsIGludCBUX0NvbUdvb2dsZUluamVjdEluamVjdCA9IDgxOwog
CS8vIEphdmEgOCAtIEpFUCAxMjAKIAlmaW5hbCBpbnQgVF9KYXZhTGFuZ0Fubm90YXRpb25SZXBl
YXRhYmxlID0gOTA7CisJCisJLy8gY2xhc3NlcyB3aXRoIG1ldGhvZHMgd2l0aCAiZGFuZ2Vyb3Vz
IiBzaWduYXR1cmVzOgorCWZpbmFsIGludCBUX0phdmFVdGlsTWFwID0gOTE7CisJCiAJLy8gSWYg
eW91IGFkZCBuZXcgdHlwZSBpZCwgbWFrZSBzdXJlIHRvIGJ1bXAgdXAgVF9MYXN0V2VsbEtub3du
VHlwZUlkIGlmIHRoZXJlIGlzIGEgY3Jvc3Mgb3Zlci4KIAlmaW5hbCBpbnQgVF9MYXN0V2VsbEtu
b3duVHlwZUlkID0gMTI4OwogCQpAQCAtMjQwLDggKzI0NCwxNSBAQAogCWZpbmFsIGludCBCaXRS
ZXNvdXJjZUZyZWVDbG9zZWFibGUgPSA4OwogCQogCWZpbmFsIGludCBCaXRVbmludGVybmVkVHlw
ZSA9IDE2OworCQorCS8qKiBNYXJrIHN1YnR5cGVzIG9mIE1hcCB0byBhbmFseXplIGRhbmdlcm91
cyBnZXQvcmVtb3ZlLiAqLworCWZpbmFsIGludCBCaXRNYXAgPSAweDEwOworCisJLyoqIE1hcmsg
c3VidHlwZXMgb2YgTWFwIHRvIGFuYWx5emUgZGFuZ2Vyb3VzIGdldC9yZW1vdmUuICovCisJZmlu
YWwgaW50IEJpdENvbGxlY3Rpb24gPSAweDIwOworCiAJLyoqCiAJICogU2V0IG9mIHR5cGUgYml0
cyB0aGF0IHNob3VsZCBiZSBpbmhlcml0ZWQgYnkgYW55IHN1YiB0eXBlcy4KIAkgKi8KLQlmaW5h
bCBpbnQgSW5oZXJpdGFibGVCaXRzID0gQml0QXV0b0Nsb3NlYWJsZSB8IEJpdENsb3NlYWJsZSB8
IEJpdFVuaW50ZXJuZWRUeXBlOworCWZpbmFsIGludCBJbmhlcml0YWJsZUJpdHMgPSBCaXRBdXRv
Q2xvc2VhYmxlIHwgQml0Q2xvc2VhYmxlIHwgQml0VW5pbnRlcm5lZFR5cGUgfCBCaXRNYXAgfCBC
aXRDb2xsZWN0aW9uIDsKIH0KZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBp
bGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wcm9ibGVtL1Byb2JsZW1SZXBv
cnRlci5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vUHJvYmxlbVJlcG9ydGVyLmphdmEKaW5kZXggNzhl
NDcwNS4uMTdlYzNmMCAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIv
b3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vUHJvYmxlbVJlcG9ydGVy
LmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vUHJvYmxlbVJlcG9ydGVyLmphdmEKQEAgLTEwMjI3
LDQgKzEwMjI3LDQwIEBACiAJCQl0eXBlUmVmZXJlbmNlWzBdLnNvdXJjZVN0YXJ0LAogCQkJdHlw
ZVJlZmVyZW5jZVt0eXBlUmVmZXJlbmNlLmxlbmd0aCAtIDFdLnNvdXJjZUVuZCk7CiB9CisKK3B1
YmxpYyB2b2lkIGRpc2NvdXJhZ2VkSW52b2NhdGlvbk9mRGFuZ2Vyb3VzU2lnbmF0dXJlKE1ldGhv
ZEJpbmRpbmcgbWV0aG9kLCBFeHByZXNzaW9uIGFyZ3VtZW50LCBUeXBlQmluZGluZyBleHBlY3Rl
ZFR5cGUsIFR5cGVCaW5kaW5nIGRlY2xhcmluZ1R5cGUpIHsKKwl0aGlzLmhhbmRsZSgKKwkJCUlQ
cm9ibGVtLkRpc2NvdXJhZ2VkSW52b2NhdGlvbk9mRGFuZ2Vyb3VzU2lnbmF0dXJlLAorCQkJbmV3
IFN0cmluZ1tdIHsKKwkJCQluZXcgU3RyaW5nKG1ldGhvZC5yZWFkYWJsZU5hbWUoKSksCisJCQkJ
bmV3IFN0cmluZyhleHBlY3RlZFR5cGUucmVhZGFibGVOYW1lKCkpLAorCQkJCW5ldyBTdHJpbmco
ZGVjbGFyaW5nVHlwZS5yZWFkYWJsZU5hbWUoKSkKKwkJCX0sIAorCQkJbmV3IFN0cmluZ1tdIHsK
KwkJCQluZXcgU3RyaW5nKG1ldGhvZC5zaG9ydFJlYWRhYmxlTmFtZSgpKSwKKwkJCQluZXcgU3Ry
aW5nKGV4cGVjdGVkVHlwZS5zaG9ydFJlYWRhYmxlTmFtZSgpKSwKKwkJCQluZXcgU3RyaW5nKGRl
Y2xhcmluZ1R5cGUuc2hvcnRSZWFkYWJsZU5hbWUoKSkKKwkJCX0sIAorCQkJYXJndW1lbnQuc291
cmNlU3RhcnQsIAorCQkJYXJndW1lbnQuc291cmNlRW5kKTsKK30KKworcHVibGljIHZvaWQgc3Ry
b25nbHlEaXNjb3VyYWdlZEludm9jYXRpb25PZkRhbmdlcm91c1NpZ25hdHVyZShNZXRob2RCaW5k
aW5nIG1ldGhvZCwgRXhwcmVzc2lvbiBhcmd1bWVudCwgVHlwZUJpbmRpbmcgZXhwZWN0ZWRUeXBl
LCBUeXBlQmluZGluZyBkZWNsYXJpbmdUeXBlKSB7CisJdGhpcy5oYW5kbGUoCisJCQlJUHJvYmxl
bS5TdHJvbmdseURpc2NvdXJhZ2VkSW52b2NhdGlvbk9mRGFuZ2Vyb3VzU2lnbmF0dXJlLAorCQkJ
bmV3IFN0cmluZ1tdIHsKKwkJCQluZXcgU3RyaW5nKG1ldGhvZC5yZWFkYWJsZU5hbWUoKSksCisJ
CQkJbmV3IFN0cmluZyhhcmd1bWVudC5yZXNvbHZlZFR5cGUucmVhZGFibGVOYW1lKCkpLAorCQkJ
CW5ldyBTdHJpbmcoZXhwZWN0ZWRUeXBlLnJlYWRhYmxlTmFtZSgpKSwKKwkJCQluZXcgU3RyaW5n
KGRlY2xhcmluZ1R5cGUucmVhZGFibGVOYW1lKCkpCisJCQl9LCAKKwkJCW5ldyBTdHJpbmdbXSB7
CisJCQkJbmV3IFN0cmluZyhtZXRob2Quc2hvcnRSZWFkYWJsZU5hbWUoKSksCisJCQkJbmV3IFN0
cmluZyhhcmd1bWVudC5yZXNvbHZlZFR5cGUuc2hvcnRSZWFkYWJsZU5hbWUoKSksCisJCQkJbmV3
IFN0cmluZyhleHBlY3RlZFR5cGUuc2hvcnRSZWFkYWJsZU5hbWUoKSksCisJCQkJbmV3IFN0cmlu
ZyhkZWNsYXJpbmdUeXBlLnNob3J0UmVhZGFibGVOYW1lKCkpCisJCQl9LCAKKwkJCWFyZ3VtZW50
LnNvdXJjZVN0YXJ0LCAKKwkJCWFyZ3VtZW50LnNvdXJjZUVuZCk7Cit9CiB9CmRpZmYgLS1naXQg
YS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwv
Y29tcGlsZXIvcHJvYmxlbS9tZXNzYWdlcy5wcm9wZXJ0aWVzIGIvb3JnLmVjbGlwc2UuamR0LmNv
cmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vbWVz
c2FnZXMucHJvcGVydGllcwppbmRleCA3MGFjODFiLi5jMzhlNzcxIDEwMDY0NAotLS0gYS9vcmcu
ZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGls
ZXIvcHJvYmxlbS9tZXNzYWdlcy5wcm9wZXJ0aWVzCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3Jl
L2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wcm9ibGVtL21lc3Nh
Z2VzLnByb3BlcnRpZXMKQEAgLTg1MSw2ICs4NTEsMTIgQEAKIAogMTEwMCA9IFByb2JsZW0gZGV0
ZWN0ZWQgZHVyaW5nIHR5cGUgaW5mZXJlbmNlOiB7MH0KIAorIyBtb3JlIHByb2dyYW1taW5nIHBy
b2JsZW1zOgorMTIwMCA9IERpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgezB9LCBzaG91
bGQgYmUgb2YgdHlwZSB7MX0gdG8gbWF0Y2ggdGhlIGRlY2xhcmluZyB0eXBlIHsyfQorMTIwMSA9
IERpc2NvdXJhZ2VkIGFyZ3VtZW50IGZvciBtZXRob2QgezB9LCBwcm92aWRlZCB0eXBlIHsxfSBp
cyBkZWZpbml0ZWx5IGluY29tcGF0aWJsZSB0byB0eXBlIHsyfS4gRGVjbGFyaW5nIHR5cGUgaXMg
ezN9CisjMTIwMCA9IEludm9raW5nIG1ldGhvZCB7MH0gd2l0aCBhbiBhcmd1bWVudCBvZiB0eXBl
IHsxfSBpcyBkaXNjb3VyYWdlZC4gU2hvdWxkIHVzZSB7Mn0gdG8gbWVldCB0aGUgc2VtYW50aWNz
IG9mIGRlY2xhcmluZyB0eXBlIHszfQorIzEyMDEgPSBJbnZva2luZyBtZXRob2QgezB9IHdpdGgg
YW4gYXJndW1lbnQgb2YgdHlwZSB7MX0gY2Fubm90IG1lZXQgdGhlIHNlbWFudGljcyBvZiBkZWNs
YXJpbmcgdHlwZSB7M30uIFJlY29tbWVuZGVkIHR5cGU6IHsyfSAKKwogIyMjIEVMQUJPUkFUSU9O
UwogIyMgQWNjZXNzIHJlc3RyaWN0aW9ucwogNzg1OTIgPSBUaGUgdHlwZSAnJ3sxfScnIGlzIG5v
dCBBUEkgKHJlc3RyaWN0aW9uIG9uIGNsYXNzcGF0aCBlbnRyeSAnJ3swfScnKQo=
</data>

          </attachment>
      

    </bug>

</bugzilla>