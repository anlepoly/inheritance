<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>403216</bug_id>
          
          <creation_ts>2013-03-13 11:44:00 -0400</creation_ts>
          <short_desc>[1.8][null] TypeReference#captureTypeAnnotations treats type annotations as type argument annotations</short_desc>
          <delta_ts>2013-08-25 20:23:38 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.2</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          <blocked>392099</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Jay Arthanareeswaran">jarthana</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>srikanth_sankaran</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2230596</commentid>
    <comment_count>0</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2013-03-13 11:44:43 -0400</bug_when>
    <thetext>As a result, when null analysis is enabled, the following code has one compilation error where there is none when not enabled:

import java.lang.annotation.ElementType;
import java.lang.annotation.Target;

public class Test {}

class X {
	class Y {
		public void foo( @A X. @B Y this) {}
	}
}
@Target(value={ElementType.TYPE_USE})
@interface A {}
@Target(value={ElementType.TYPE_USE})
@interface B {}

The result is a ParameterizedTypeBinding when null analysis is enabled and MemberTypeBinding otherwise for the explicit receiver type.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2230971</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-13 19:47:38 -0400</bug_when>
    <thetext>See also bug 394539</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232171</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-15 13:25:58 -0400</bug_when>
    <thetext>See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=403457.

I think the present approach in captureTypeAnnotations is problematic as it
will spoil TypeBinding identity between an instance that has null annotations
and another that doesn&apos;t.

We could take the annotation holder approach and maintain a map between AST
nodes and annotations - this will help us preserve binding identity.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232357</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-15 20:21:30 -0400</bug_when>
    <thetext>(In reply to comment #2)
&gt; See also https://bugs.eclipse.org/bugs/show_bug.cgi?id=403457.
&gt; 
&gt; I think the present approach in captureTypeAnnotations is problematic as it
&gt; will spoil TypeBinding identity between an instance that has null annotations
&gt; and another that doesn&apos;t.

Not just an issue of type equality, the present code also create a parameterized
type where it should not.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232470</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-16 20:30:37 -0400</bug_when>
    <thetext>Alright, I had a first look at this and see several dimensions to this discussion:

(A) The implementation of bug 392099 (incl. sub tasks) is incomplete indeed. 
I put that one on hold because a full solution depends on bug 383624 (via bug 392384).
This is because without the capability to restore null type annotations from class files most of the existing tests for null annotations cannot work with null *type annotations*.
Do you see a better strategy than waiting for a fix in bug 383624?

(B) The immediate issue can be fixed by mending a simple oversight in TypeReference#captureTypeAnnotations:
if no null annotations are present, the original argType should be returned.

(C) In a receiver declaration @Nullable should be reported as an error any way, receivers are implicitly @NonNull by construction.

(D) Isn&apos;t the check in AMD.resolveReceiver() a bit too strict: JSR 308 spec says:
 &quot;The type of the this formal parameter must be the same as the class that contains the
  method and *may* include type arguments if that class has any.&quot;
(my emphasis on &quot;may&quot;).
-&gt; Shouldn&apos;t that check use original(), actually?


Back to my implementation strategy for bug 392099:

(E) I admit I&apos;m stretching the notion of &quot;ParameterizedTypeBinding&quot; but I&apos;m intentionally creating PTBs even if no type arguments are given.
The motivation is: I&apos;d like to interpret &quot;@NonNull X&quot; as an &apos;instantiation&apos; of a &apos;generic type&apos; X, even if X has no type parameters.
Please consider the basic example in this context:
   List&lt;@NonNull String&gt; strings = ...;  // (1)
   ...
   strings.add(null); // (2) 
At location (2) we want to detect a null contract violation, but for doing so we need to instantiate &quot;add(T)&quot; to &quot;add(@NonNull String)&quot;.
At that point all we have is a variable binding for &quot;strings&quot;, no reference to an AST element that holds the annotation.
That&apos;s why I think the straight-forward solution is by using a type binding to represent &quot;@NonNull String&quot; (as the type argument in another type binding &quot;List&lt;@NonNull String&gt;&quot;).
I&apos;m aware that perhaps a large number of identity checks have to be revisited to see if they are spoiled when instantiating some &quot;X&quot; to &quot;@NonNull X&quot;.
OTOH, many situations already call original() before doing identity comparison. Those locations are always fine.


With this preliminary analysis, do you consent to deferring the discussion till after bug bug 383624 has been fixed and after I&apos;ve done some assessment of the impact of my intended solution?

(F) If my proposed solution proves too hard to get right, we need to invent a new encoding to create a representation for &quot;List&lt;@NonNull String&gt;&quot;, which could be sketched as 
  PTB List {
      arguments = { String }
      type-annotations = { { @NonNull } }
  }
And then instantiating members of &quot;List&quot; will have to re-merge the information from &quot;arguments&quot; and &quot;type-annotations&quot;.
Similarly, &quot;List&lt;@Nullable Map&lt;@NonNull String, @Nullable Object&gt;&gt;&quot; would be represented like:
  PTB List {
     arguments = {
         PTB Map {
            arguments = { String, Object }
            type-annotations = { { @NonNull }, {  @Nullable } }
         }
     }
     type-annotations = { { @Nullable } }
  }
This would help to avoid the identity issue, but would make substitution considerably more involved.
Also all other locations where types can occur would need to be checked whether a place for storing the annotation is available.
Right now, I still prefer the proposed &quot;deep instantiation&quot; of type bindings with null type annotations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232476</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-17 00:41:56 -0400</bug_when>
    <thetext>(In reply to comment #4)
&gt; Alright, I had a first look at this and see several dimensions to this
&gt; discussion:
&gt; 
&gt; (A) The implementation of bug 392099 (incl. sub tasks) is incomplete indeed. 
&gt; I put that one on hold because a full solution depends on bug 383624 (via
&gt; bug 392384).

Stephan, I understand that you are tracking the dependencies and somethings
will take time to cook - That is fine. Nothing needs to be rushed.

&gt; (B) The immediate issue can be fixed by mending a simple oversight in
&gt; TypeReference#captureTypeAnnotations:
&gt; if no null annotations are present, the original argType should be returned.

Yes, please. This would be great, because two of us tripped into this
inadvertently this week and had to spend some time to understand what is 
going on.

&gt; (D) Isn&apos;t the check in AMD.resolveReceiver() a bit too strict: JSR 308 spec
&gt; says:
&gt;  &quot;The type of the this formal parameter must be the same as the class that
&gt; contains the
&gt;   method and *may* include type arguments if that class has any.&quot;
&gt; (my emphasis on &quot;may&quot;).

Jay, can you please check if the following compiles with a recent 308 JDK ?

// --
public class X&lt;T&gt; {
	void foo(X this) {
	}
}

&gt; -&gt; Shouldn&apos;t that check use original(), actually?

This shouldn&apos;t be required since we are inside the class and not dealing
with any particular parameterization.

&gt; (E) I admit I&apos;m stretching the notion of &quot;ParameterizedTypeBinding&quot; but I&apos;m
&gt; intentionally creating PTBs even if no type arguments are given.
&gt; The motivation is: I&apos;d like to interpret &quot;@NonNull X&quot; as an &apos;instantiation&apos;
&gt; of a &apos;generic type&apos; X, even if X has no type parameters.
&gt; Please consider the basic example in this context:
&gt;    List&lt;@NonNull String&gt; strings = ...;  // (1)
&gt;    ...
&gt;    strings.add(null); // (2) 
&gt; At location (2) we want to detect a null contract violation, but for doing
&gt; so we need to instantiate &quot;add(T)&quot; to &quot;add(@NonNull String)&quot;.
&gt; At that point all we have is a variable binding for &quot;strings&quot;, no reference
&gt; to an AST element that holds the annotation.
&gt; That&apos;s why I think the straight-forward solution is by using a type binding
&gt; to represent &quot;@NonNull String&quot; (as the type argument in another type binding
&gt; &quot;List&lt;@NonNull String&gt;&quot;).
&gt; I&apos;m aware that perhaps a large number of identity checks have to be
&gt; revisited to see if they are spoiled when instantiating some &quot;X&quot; to
&gt; &quot;@NonNull X&quot;.
&gt; OTOH, many situations already call original() before doing identity
&gt; comparison. Those locations are always fine.

I didn&apos;t mean it to be just a JDT/Core issue = I am not sure whether 
refactoring and such may be broken due to binding differences. They either 
would depend on binding == or the binding key being the same to decide 
which elements should be affected by refactoring - no ?

&gt; With this preliminary analysis, do you consent to deferring the discussion
&gt; till after bug bug 383624 has been fixed and after I&apos;ve done some assessment
&gt; of the impact of my intended solution?

By all means. As discussed above, let us just mend the oversight in 
captureTypeAnnotations and other fixes can come in due course. At that time
after experiments, you can propose what you decide on and that can be analyzed
for any issues before full blown implementation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232477</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-17 00:45:32 -0400</bug_when>
    <thetext>Jay, can you please check if the following compiles with a recent 308 JDK ?

// --
public class X&lt;T&gt; {
	void foo(X this) {
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232478</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-17 01:10:35 -0400</bug_when>
    <thetext>(In reply to comment #4)

&gt; (E) I admit I&apos;m stretching the notion of &quot;ParameterizedTypeBinding&quot; but I&apos;m
&gt; intentionally creating PTBs even if no type arguments are given.
&gt; The motivation is: I&apos;d like to interpret &quot;@NonNull X&quot; as an &apos;instantiation&apos;
&gt; of a &apos;generic type&apos; X, even if X has no type parameters.
&gt; Please consider the basic example in this context:
&gt;    List&lt;@NonNull String&gt; strings = ...;  // (1)
&gt;    ...
&gt;    strings.add(null); // (2) 
&gt; At location (2) we want to detect a null contract violation, but for doing
&gt; so we need to instantiate &quot;add(T)&quot; to &quot;add(@NonNull String)&quot;.

Whenever this is taken up, we need to see if this creates problems in:

    List&lt;@NonNull String&gt; strings = ...;  // (1)
    List&lt;String&gt; someStrings;

    someStrings = strings;

I see that LocalVariableBinding already has a reference to the declaration.
Perhaps augmenting FieldBinding likewise could lend a clean soultion - but
that is putting the cart before the horse. Let us wait for full investigation
in due course.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232528</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-17 09:22:44 -0400</bug_when>
    <thetext>(In reply to comment #5)
&gt; Stephan, I understand that you are tracking the dependencies and somethings
&gt; will take time to cook - That is fine. Nothing needs to be rushed.

Thanks.

&gt; &gt; (D) Isn&apos;t the check in AMD.resolveReceiver() a bit too strict: JSR 308 spec
&gt; &gt; says:
&gt; &gt;  &quot;The type of the this formal parameter must be the same as the class that
&gt; &gt; contains the
&gt; &gt;   method and *may* include type arguments if that class has any.&quot;
&gt; &gt; (my emphasis on &quot;may&quot;).
&gt; 
&gt; Jay, can you please check if the following compiles with a recent 308 JDK ?
&gt; 
&gt; // --
&gt; public class X&lt;T&gt; {
&gt; 	void foo(X this) {
&gt; 	}
&gt; }
&gt; 
&gt; &gt; -&gt; Shouldn&apos;t that check use original(), actually?
&gt; 
&gt; This shouldn&apos;t be required since we are inside the class and not dealing
&gt; with any particular parameterization.

True for enclosingReceiverType, but maybe we should say
	if (enclosingReceiver != resolvedReceiverType.original()) {
(inside AMD.resolveReceiver())?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232534</commentid>
    <comment_count>9</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-17 09:45:11 -0400</bug_when>
    <thetext>(In reply to comment #5)
&gt; &gt; (B) The immediate issue can be fixed by mending a simple oversight in
&gt; &gt; TypeReference#captureTypeAnnotations:
&gt; &gt; if no null annotations are present, the original argType should be returned.
&gt; 
&gt; Yes, please. This would be great, because two of us tripped into this
&gt; inadvertently this week and had to spend some time to understand what is 
&gt; going on.

that part has been released to the branch via commit 9673337e54ce81e8d22e9d4de37e3f9f0230c274

tests are in commit 97b509ed0492c1ec5d604a591a307ac7d4bc5ef4

Leaving this bug open for the more general issues.

A TODO for the time of revisiting this bug: I noticed that 
captureTypeAnnotations can be called before resolveAnnotations which
means we don&apos;t yet have the compilerAnnotations, mh...
To be challenged by replacing @A and @B in comment 0 with null annotations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232543</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-17 10:19:27 -0400</bug_when>
    <thetext>(In reply to comment #7)
&gt; Whenever this is taken up, we need to see if this creates problems in:
&gt; 
&gt;     List&lt;@NonNull String&gt; strings = ...;  // (1)
&gt;     List&lt;String&gt; someStrings;
&gt; 
&gt;     someStrings = strings;

Right, currently such assignments are reported as incompatible, where we
need to differentiate which direction is reported as an unchecked conversion
and which is OK.
 
&gt; I see that LocalVariableBinding already has a reference to the declaration.
&gt; Perhaps augmenting FieldBinding likewise could lend a clean soultion - but
&gt; that is putting the cart before the horse. Let us wait for full investigation
&gt; in due course.

... the FieldBinding could come from a binary type with no AST ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2232575</commentid>
    <comment_count>11</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2013-03-17 12:40:26 -0400</bug_when>
    <thetext>(In reply to comment #6)
&gt; Jay, can you please check if the following compiles with a recent 308 JDK ?
&gt; 
&gt; // --
&gt; public class X&lt;T&gt; {
&gt; 	void foo(X this) {
&gt; 	}
&gt; }

I get this:

X.java:2: error: the receiver type does not match the enclosing class type
        void foo(X this) {
                   ^
1 error

which goes away if I use replace X&lt;T&gt; for the receiver.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298762</commentid>
    <comment_count>12</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-25 18:58:48 -0400</bug_when>
    <thetext>Some related stuff has been resolved by now, incl. bug 383624, bug 392384, bug 394539.
So let me take stock on where we are in this issue:

-------------------------------------------------------------------
(In reply to comment #0)
&gt; As a result, when null analysis is enabled, the following code has one
&gt; compilation error where there is none when not enabled:

I already added the test as NullTypeAnnotationTest.testBug403216_1().
It passes in HEAD of BETA_JAVA8. See below.

-------------------------------------------------------------------
(In reply to comment #4)
&gt; (A) The implementation of bug 392099 (incl. sub tasks) is incomplete indeed. 
&gt; I put that one on hold because a full solution depends on bug 383624 (via
&gt; bug 392384).
&gt; This is because without the capability to restore null type annotations from
&gt; class files most of the existing tests for null annotations cannot work with
&gt; null *type annotations*.
&gt; Do you see a better strategy than waiting for a fix in bug 383624?

Waiting is over :)
 
-------------------------------------------------------------------
&gt; (B) The immediate issue can be fixed by mending a simple oversight in
&gt; TypeReference#captureTypeAnnotations:
&gt; if no null annotations are present, the original argType should be returned.

This fix has already been released (commit 97b509ed0492c1ec5d604a591a307ac7d4bc5ef4)
and indeed fixed the immediate bug.
 
-------------------------------------------------------------------
&gt; (C) In a receiver declaration @Nullable should be reported as an error any
&gt; way, receivers are implicitly @NonNull by construction.

Will be done via bug 392238.

-------------------------------------------------------------------
&gt; (D) Isn&apos;t the check in AMD.resolveReceiver() a bit too strict: JSR 308 spec
&gt; says:
&gt;  &quot;The type of the this formal parameter must be the same as the class that
&gt; contains the
&gt;   method and *may* include type arguments if that class has any.&quot;
&gt; (my emphasis on &quot;may&quot;).
&gt; -&gt; Shouldn&apos;t that check use original(), actually?

(In reply to comment #11)
&gt; (In reply to comment #6)
&gt; &gt; Jay, can you please check if the following compiles with a recent 308 JDK ?
&gt; &gt; 
&gt; &gt; // --
&gt; &gt; public class X&lt;T&gt; {
&gt; &gt; 	void foo(X this) {
&gt; &gt; 	}
&gt; &gt; }
&gt; 
&gt; I get this:
&gt; 
&gt; X.java:2: error: the receiver type does not match the enclosing class type
&gt;         void foo(X this) {
&gt;                    ^
&gt; 1 error
&gt; 
&gt; which goes away if I use replace X&lt;T&gt; for the receiver.

I&apos;m surprised. This doesn&apos;t match my understanding of &quot;may&quot; in the spec.

ACTION ITEM 1:
Since usage of original() is not mandated here, the comparison must be
  &quot;enclosingReceiver != resolvedReceiverType.unannotated()&quot;
Test &amp; fix to be released here.

-------------------------------------------------------------------
(In reply to comment #7)
&gt; Whenever this is taken up, we need to see if this creates problems in:
&gt; 
&gt;     List&lt;@NonNull String&gt; strings = ...;  // (1)
&gt;     List&lt;String&gt; someStrings;
&gt; 
&gt;     someStrings = strings;

This is accepted (I&apos;m adding this as testBug403216_2()).
Note that meanwhile, ReferenceBinding#isCompatibleWith(..) uses 
TypeBinding#unannotated() to get a clean story for compatibility just based on JLS.
Any annotation related incompatibilities are detected separately.

ACTION ITEM 2:
Add the promised test.

-------------------------------------------------------------------
(In reply to comment #9)
&gt; A TODO for the time of revisiting this bug: I noticed that 
&gt; captureTypeAnnotations can be called before resolveAnnotations which
&gt; means we don&apos;t yet have the compilerAnnotations, mh...
&gt; To be challenged by replacing @A and @B in comment 0 with null annotations.

I can no longer reproduce this situation. Using the example from comment 0
resolveAnnotations() is invoked *before* captureTypeAnnotations(), both from
STB#resolveTypesFor(..):
- resolveAnnotations() via getAnnotationTagBits() at the top (2nd block)
- captureTypeAnnotations() via methodDecl.receiver.type.resolveType(..) several blocks down


This leaves us with two action items before this bug can be closed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298770</commentid>
    <comment_count>13</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-25 20:23:38 -0400</bug_when>
    <thetext>Remaining items are resolved via commit d72243e9032009ede789d14b49acc668f280d583.
(incl. a fix in PTB#isAnnotatedTypeWithoutArguments() for use by PTB#unannotated()).</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>