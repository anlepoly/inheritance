<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>432605</bug_id>
          
          <creation_ts>2014-04-11 06:12:00 -0400</creation_ts>
          <short_desc>[1.8] Incorrect error &quot;The type ArrayList&lt;T&gt; does not define add(ArrayList&lt;T&gt;, Object) that is applicable here&quot;</short_desc>
          <delta_ts>2014-11-20 23:39:04 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 8</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>https://bugs.eclipse.org/bugs/show_bug.cgi?id=432759</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M3</target_milestone>
          <dependson>437444</dependson>
          <blocked>428061</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Timo Kinnunen">timo.kinnunen</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>shankhba</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
    
    <cc>tim.griffith.dev</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2387977</commentid>
    <comment_count>0</comment_count>
      <attachid>241880</attachid>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-04-11 06:12:27 -0400</bug_when>
    <thetext>Created attachment 241880
An excerpt showing the error

The attached code fails to compile with ECJ but compiles successfully using javac. Some type information appears to be lost in the nested method call because extracting part of it into a new local variable makes the error go away.

Tested using Eclipse SDK

Version: Luna (4.4)
Build id: I20140402-0100

and JDT Core built from HEAD yesterday.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2405257</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-05-21 20:24:36 -0400</bug_when>
    <thetext>Ran out of time for Luna.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2433174</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-29 11:22:50 -0400</bug_when>
    <thetext>Beautiful, one of the inference variables is erroneously (?) resolved to j.l.Object:

Inference Context (type inferred) (loose) (resolved)
Inference Variables:
	E#0	:	E
	T#1	:	T
	M#2	:	M
	T#3	:	T
	A#4	:	java.lang.Object
	R#5	:	java.util.HashMap&lt;K,L&gt;
	RR#6	:	M
	T#7	:	T
	K#8	:	K
	D#9	:	L
	A#10	:	java.util.ArrayList&lt;T&gt;
	M#11	:	java.util.HashMap&lt;K,L&gt;
	T#7	:	T
	?#12	:	java.lang.Object
	M#11	:	java.util.HashMap&lt;K,L&gt;
	T#13	:	T
	A#14	:	java.util.ArrayList&lt;T&gt;
	R#15	:	java.util.ArrayList&lt;T&gt;
	RR#16	:	L
	T#17	:	T
	R#18	:	java.util.ArrayList&lt;T&gt;
	K#19	:	K
	V#20	:	L
	E#21	:	T
Type Bounds:
	TypeBound  ?#12 = java.lang.Object
	Dependency ?#12 = A#4
	TypeBound  ?#12 &lt;: java.lang.Object
	TypeBound  D#9 = L
	TypeBound  D#9 &lt;: java.lang.Object
	Dependency M#11 :&gt; java.util.HashMap&lt;K#19,V#20&gt;
	TypeBound  M#11 :&gt; java.util.HashMap&lt;K,L&gt;
	Dependency M#11 :&gt; java.util.HashMap&lt;K#19,L&gt;
	Dependency M#11 :&gt; java.util.HashMap&lt;K,V#20&gt;
	TypeBound  M#11 = java.util.HashMap&lt;K,L&gt;
	Dependency M#11 = R#5
	Dependency M#11 = M#11
	Dependency M#11 &lt;: java.util.Map&lt;K#8,D#9&gt;
	Dependency M#11 &lt;: java.util.Map&lt;K#8,L&gt;
	Dependency M#11 &lt;: java.util.Map&lt;K,D#9&gt;
	TypeBound  M#11 &lt;: java.util.Map&lt;K,L&gt;
	TypeBound  M#11 &lt;: java.lang.Object
	TypeBound  T#13 :&gt; T
	TypeBound  T#13 = T
	TypeBound  T#13 &lt;: java.lang.Object
	Dependency T#13 &lt;: T#13
	TypeBound  T#13 &lt;: T
	Dependency T#13 &lt;: T#17
	Dependency T#3 = T#7
	TypeBound  T#3 = T
	Dependency T#3 = T#1
	TypeBound  T#3 &lt;: java.lang.Object
	TypeBound  T#3 &lt;: T
	Dependency T#3 &lt;: T#13
	TypeBound  T#3 &lt;: capture#1-of ? super T
	Dependency T#3 &lt;: T#17
	TypeBound  E#0 = E
	TypeBound  E#0 &lt;: java.lang.Exception
	TypeBound  A#10 :&gt; java.util.ArrayList&lt;T&gt;
	Dependency A#10 :&gt; java.util.ArrayList&lt;E#21&gt;
	TypeBound  A#10 = java.util.ArrayList&lt;T&gt;
	TypeBound  A#10 &lt;: java.lang.Object
	TypeBound  R#15 :&gt; java.util.ArrayList&lt;T&gt;
	Dependency R#15 :&gt; java.util.ArrayList&lt;E#21&gt;
	TypeBound  R#15 = java.util.ArrayList&lt;T&gt;
	Dependency R#15 = A#10
	TypeBound  R#15 &lt;: java.lang.Object
	TypeBound  A#14 :&gt; java.util.ArrayList&lt;T&gt;
	Dependency A#14 :&gt; java.util.ArrayList&lt;E#21&gt;
	Dependency A#14 = R#15
	Dependency A#14 = A#10
	TypeBound  A#14 = java.util.ArrayList&lt;T&gt;
	TypeBound  A#14 &lt;: java.lang.Object
	TypeBound  T#1 = T
	TypeBound  T#1 &lt;: T
	Dependency T#1 &lt;: T#13
	Dependency T#1 &lt;: T#17
	TypeBound  T#1 &lt;: java.lang.Object
	TypeBound  T#1 &lt;: capture#1-of ? super T
	TypeBound  A#4 = java.lang.Object
	TypeBound  A#4 &lt;: java.lang.Object
	Dependency R#5 :&gt; java.util.HashMap&lt;K#19,V#20&gt;
	TypeBound  R#5 :&gt; java.util.HashMap&lt;K,L&gt;
	Dependency R#5 :&gt; java.util.HashMap&lt;K#19,L&gt;
	Dependency R#5 :&gt; java.util.HashMap&lt;K,V#20&gt;
	Dependency R#5 = M#11
	TypeBound  R#5 = java.util.HashMap&lt;K,L&gt;
	Dependency R#5 &lt;: java.util.Map&lt;K#8,D#9&gt;
	Dependency R#5 &lt;: java.util.Map&lt;K#8,L&gt;
	Dependency R#5 &lt;: java.util.Map&lt;K,D#9&gt;
	TypeBound  R#5 &lt;: java.util.Map&lt;K,L&gt;
	TypeBound  R#5 &lt;: java.lang.Object
	Dependency RR#16 = D#9
	TypeBound  RR#16 = L
	TypeBound  RR#16 &lt;: java.lang.Object
	TypeBound  R#18 :&gt; java.util.ArrayList&lt;T&gt;
	Dependency R#18 :&gt; java.util.ArrayList&lt;E#21&gt;
	Dependency R#18 = A#14
	TypeBound  R#18 = java.util.ArrayList&lt;T&gt;
	Dependency R#18 = R#15
	TypeBound  R#18 &lt;: java.lang.Object
	Dependency RR#6 = M#2
	TypeBound  RR#6 = M
	TypeBound  RR#6 &lt;: java.lang.Object
	TypeBound  RR#6 &lt;: M
	TypeBound  E#21 = T
	TypeBound  E#21 &lt;: java.lang.Object
	Dependency V#20 = D#9
	TypeBound  V#20 = L
	TypeBound  V#20 &lt;: java.lang.Object
	Dependency T#7 = T#3
	TypeBound  T#7 = T
	Dependency T#7 = T#7
	Dependency T#7 = T#1
	TypeBound  T#7 &lt;: T
	Dependency T#7 &lt;: T#17
	TypeBound  T#7 &lt;: capture#1-of ? super T
	TypeBound  T#7 &lt;: java.lang.Object
	Dependency T#7 &lt;: T#13
	TypeBound  K#8 :&gt; capture#2-of ? extends K
	TypeBound  K#8 = K
	TypeBound  K#8 &lt;: java.lang.Object
	TypeBound  T#17 :&gt; T
	Dependency T#17 = T#13
	TypeBound  T#17 = T
	TypeBound  T#17 &lt;: T
	TypeBound  T#17 &lt;: java.lang.Object
	Dependency T#17 &lt;: T#17
	Dependency T#17 &lt;: T#13
	TypeBound  M#2 = M
	TypeBound  M#2 &lt;: M
	TypeBound  M#2 &lt;: java.lang.Object
	TypeBound  K#19 :&gt; capture#2-of ? extends K
	Dependency K#19 = K#8
	TypeBound  K#19 = K
	TypeBound  K#19 &lt;: java.lang.Object
Capture Bounds:</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2433176</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-29 11:30:06 -0400</bug_when>
    <thetext>Here&apos;s the inner inference for Collector.of(..):

Inference Context (type inferred) (vararg) (resolved)
Inference Variables:
	T#0	:	java.lang.Object
	R#1	:	java.util.ArrayList&lt;T&gt;
	E#2	:	T
Type Bounds:
	TypeBound  T#0 = java.lang.Object
	TypeBound  T#0 &lt;: java.lang.Object
	TypeBound  E#2 = T
	TypeBound  E#2 &lt;: java.lang.Object
	TypeBound  R#1 :&gt; java.util.ArrayList&lt;T&gt;
	Dependency R#1 :&gt; java.util.ArrayList&lt;E#2&gt;
	TypeBound  R#1 = java.util.ArrayList&lt;T&gt;
	TypeBound  R#1 &lt;: java.lang.Object
Capture Bounds:


It&apos;s inference variable T#0 that would need to be resolved to T for success, but is resolved to j.l.Object. Looking at the inner inference in isolation gives no hint for inferring T.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2433203</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-29 12:27:34 -0400</bug_when>
    <thetext>Transcript of more debugging:


Inference for the outer invocation Collectors.collectingAndThen(..) is driven by this target type (2nd param of terminalAsCollected()):

  Collector&lt;T, ?, M&gt;

For inference to succeed this occurrence of T needs to percolate all the way down to the method reference.

It seems to get stuck at the step from groupingBy(..) to the inner collectingAndThen():

At groupingBy() T#0 is correctly instantiated to T (from terminalAsMapToList)

During the inner inference for collectingAndThen() I see this constraint:

   Collector&lt;T#0,A#1,RR#3&gt;  Collector&lt;? super capture#1-of ? super T,ArrayList&lt;T&gt;,L&gt;
reduced to:
   Collector&lt;T#0,A#1,RR#3&gt; &lt;: Collector&lt;? super capture#1-of ? super T,ArrayList&lt;T&gt;,L&gt;
   T#0 &lt;= ? super capture#1-of ? super T
       ... and two more constraints
   capture#1-of ? super T &lt;: T#0
   T#0 :&gt; capture#1-of ? super T

During resolve for T#0 this creates a type bound
   T#0 = capture#1-of ? super T


Looking OK, so far, but later in the same inference this constraint:

   ArrayList&lt;T&gt;::add  BiConsumer&lt;ArrayList&lt;T&gt;,capture#1-of ? super T&gt;

fails to reduce!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2433214</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-29 12:41:43 -0400</bug_when>
    <thetext>So, inference failed because it found that
   BiConsumer&lt;ArrayList&lt;T&gt;,T&gt;
is not compatible with
   BiConsumer&lt;ArrayList&lt;T&gt;,capture#1-of ? super T&gt;

Correct.

I&apos;m guessing that javac might accept this due to one of its illegal manipulations of captures.

Experiment: selectively insert a call to uncapture to let inference proceed ...

   B-I-N-G-O

That manipulation makes the test pass.


Current reading:

- Rejecting the program might be correct.

- javac might accept due to incorrectly dropping a capture.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2433221</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-29 12:55:29 -0400</bug_when>
    <thetext>Final remarks for now:

Anyone challenging whether the capture is correct in this location: it is the same &quot;capture#1-of ? super T&quot; that has been observed during comment 4

I&apos;ll try to coordinate with javac ... time permitting ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2453449</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-18 00:07:10 -0400</bug_when>
    <thetext>Targetting for 4.5 M3. While ATM ownership is left unchanged, Stephan is under
time constraint during this window, so I will likely take this over or assign to someone else to load balance later on.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454452</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-20 06:45:21 -0400</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #0)
&gt; Created attachment 241880 [details]
&gt; An excerpt showing the error
&gt; 
&gt; The attached code fails to compile with ECJ but compiles successfully using
&gt; javac. Some type information appears to be lost in the nested method call
&gt; because extracting part of it into a new local variable makes the error go
&gt; away.

We compile this fine if ArrayList&lt;T&gt;::add is changed to:

(alt, t) -&gt; alt.add(t)

Investigating ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454458</commentid>
    <comment_count>9</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-20 08:48:56 -0400</bug_when>
    <thetext>Similar failure at https://bugs.eclipse.org/bugs/show_bug.cgi?id=428811.

I released a disabled junit here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=ab887d57001c56847b048951c3a4d17601aad067</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456809</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-26 13:04:12 -0400</bug_when>
    <thetext>Fix and tests here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=48bf00145f70fca24101eaac33adc5d495f9e595.

Basically there was a bug in reducing type argument containment formulas.
CaptureBinding does not answer Binding.WILDCARD_TYPE but answers TYPE_PARAMETER.
So were injecting bad constraints that cause problems down the road.

This fix also aligns us fully with javac for bug 428177 and better aligns us
with javac on bug 432759 - we not emit one error there that javac also emits and
compile one more call than javac does, as opposed to no errors earlier.

Stephan, review at your convenience,</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2457651</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-29 16:49:00 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #10)
&gt; Fix and tests here:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?id=48bf00145f70fca24101eaac33adc5d495f9e595.
&gt; 
&gt; Basically there was a bug in reducing type argument containment formulas.
&gt; CaptureBinding does not answer Binding.WILDCARD_TYPE but answers
&gt; TYPE_PARAMETER.
&gt; So were injecting bad constraints that cause problems down the road.
&gt; 
&gt; This fix also aligns us fully with javac for bug 428177 and better aligns us
&gt; with javac on bug 432759 - we not emit one error there that javac also emits
&gt; and
&gt; compile one more call than javac does, as opposed to no errors earlier.
&gt; 
&gt; Stephan, review at your convenience,

I was going to ask where you read in the spec that CaptureBinding should be treated like a wildcard. (It&apos;s wrong IMO). But while I&apos;m looking at your WIP patch in bug 437444 I see you are withdrawing this very change ... 

I recall some discussion with Dan about this, resulting in this comment:
  // &quot;If T is a type&quot; ... all alternatives require &quot;wildcard&quot;
In constrast to wildcard, a capture *is* a type.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2457681</commentid>
    <comment_count>12</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-29 20:13:13 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #11)

&gt; I was going to ask where you read in the spec that CaptureBinding should be
&gt; treated like a wildcard. (It&apos;s wrong IMO). But while I&apos;m looking at your WIP
&gt; patch in bug 437444 I see you are withdrawing this very change ... 
&gt; 
&gt; I recall some discussion with Dan about this, resulting in this comment:
&gt;   // &quot;If T is a type&quot; ... all alternatives require &quot;wildcard&quot;
&gt; In constrast to wildcard, a capture *is* a type.

Yes, my further reasoning led me to the conclusion that the change made to fix
the current bug is not appropriate and I was perhaps compensating for a bug 
somewhere else. This should go away with the elaborate solution for bug 437444.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2458012</commentid>
    <comment_count>13</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-30 10:07:24 -0400</bug_when>
    <thetext>Xref: when re-resolving this, we should also re-check bug 432759 which seems to depend on this change (?)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2459589</commentid>
    <comment_count>14</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-02 21:38:18 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #12)
&gt; (In reply to Stephan Herrmann from comment #11)
&gt; 
&gt; &gt; I was going to ask where you read in the spec that CaptureBinding should be
&gt; &gt; treated like a wildcard. (It&apos;s wrong IMO). But while I&apos;m looking at your WIP
&gt; &gt; patch in bug 437444 I see you are withdrawing this very change ... 
&gt; &gt; 
&gt; &gt; I recall some discussion with Dan about this, resulting in this comment:
&gt; &gt;   // &quot;If T is a type&quot; ... all alternatives require &quot;wildcard&quot;
&gt; &gt; In constrast to wildcard, a capture *is* a type.
&gt; 
&gt; Yes, my further reasoning led me to the conclusion that the change made to
&gt; fix
&gt; the current bug is not appropriate and I was perhaps compensating for a bug 
&gt; somewhere else. This should go away with the elaborate solution for bug
&gt; 437444.

Reverted the commit through: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=341ead40b71a0bffec0f8325f6b29d2b567caf8a, 

Sorry for the inconvenience - status reflects status. Will continue to investigate.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2461295</commentid>
    <comment_count>15</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-07 23:18:41 -0400</bug_when>
    <thetext>I believe we are hitting https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891
in this one too.

The return expression of this lambda 


(ArrayList&lt;T&gt; left, ArrayList&lt;T&gt; right) -&gt; {
  		        left.addAll(right);
  		        return left;

is necessary to solve the type equations and we are dropping them ATN</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463252</commentid>
    <comment_count>16</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-11 06:19:10 -0400</bug_when>
    <thetext>Reduced test case:

import java.util.ArrayList;
import java.util.HashMap;
import java.util.function.Function;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class X {
    static &lt;T, K, L, M&gt; void foo() {
	Collector&lt;T, ?, M&gt; cat = 
            Collectors.collectingAndThen(
		Collectors.groupingBy((Function&lt;? super T, ? extends K&gt;) null, 
				HashMap&lt;K, L&gt;::new, 
				(Collector&lt;T, ArrayList&lt;T&gt;, L&gt;) null), 
				(Function&lt;HashMap&lt;K, L&gt;, M&gt;) null);
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463256</commentid>
    <comment_count>17</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-11 07:25:03 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #16)
&gt; Reduced test case:
&gt; 
&gt; import java.util.ArrayList;
&gt; import java.util.HashMap;
&gt; import java.util.function.Function;
&gt; import java.util.stream.Collector;
&gt; import java.util.stream.Collectors;
&gt; 
&gt; public class X {
&gt;     static &lt;T, K, L, M&gt; void foo() {
&gt; 	Collector&lt;T, ?, M&gt; cat = 
&gt;             Collectors.collectingAndThen(
&gt; 		Collectors.groupingBy((Function&lt;? super T, ? extends K&gt;) null, 
&gt; 				HashMap&lt;K, L&gt;::new, 
&gt; 				(Collector&lt;T, ArrayList&lt;T&gt;, L&gt;) null), 
&gt; 				(Function&lt;HashMap&lt;K, L&gt;, M&gt;) null);
&gt; 	}
&gt; }

&lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;
    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt;,
                                  Supplier&lt;M&gt;,
                                  Collector&lt;? super T, A, D&gt;) 

After 18.5.1,

We have:

Dependency M#4 &lt;: java.util.Map&lt;K#1,D#2&gt;

Initial constraints:

(Function&lt;? super T, ? extends K&gt;) null  java.util.function.Function&lt;? super T#0,? extends K#1&gt;, 

(Collector&lt;T, ArrayList&lt;T&gt;, L&gt;) null  java.util.stream.Collector&lt;? super T#0,A#3,D#2&gt;

Reducing the first constraint:

(Function&lt;? super T, ? extends K&gt;) null  java.util.function.Function&lt;? super T#0,? extends K#1&gt;, 

we produce additional constraints in steps:

java.util.function.Function&lt;capture#1-of ? super T,capture#2-of ? extends K&gt;  java.util.function.Function&lt;? super T#0,? extends K#1&gt;

Reducing that produces:

java.util.function.Function&lt;capture#1-of ? super T,capture#2-of ? extends K&gt; &lt;: java.util.function.Function&lt;? super T#0,? extends K#1&gt;

Reducing that produces:

capture#1-of ? super T &lt;= ? super T#0, 
capture#2-of ? extends K &lt;= ? extends K#1]

Reducing the first of these two produces:

T#0 &lt;: capture#1-of ? super T

We have a problem right there. 

This is according to the literal interpretation of the text, yes,
but I think we should be deriving the constraint instead:

T#0 &lt;: T

That is exactly what we do in TypeBinding.isTypeArgumentContainedBy</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463258</commentid>
    <comment_count>18</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-11 07:35:43 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #17)

Here is another way of looking at it:

18.2.3 Subtyping Constraints

A constraint formula of the form S &lt;: T is reduced as follows:

If T is a parameterized class or interface type, or an inner class type of
a parameterized class or interface type (directly or indirectly), let A1,
..., An be the type arguments of T. Among the supertypes of S, a 
corresponding class or interface type is identified, with type arguments 
B1, ..., Bn. If no such type exists, the constraint reduces to false.
Otherwise, the constraint reduces to the following new constraints: for 
all i (1  i  n), Bi &lt;= Ai.

The corresponding super type should really be the &quot;wildcard parameterized
type&quot;, not the &quot;captured wildcard parameterized type.&quot;

Our implementation of TypeBinding.fSTOF called thusly:

    G&lt;capture#1 of ?&gt;.fSTOF(G&lt;?&gt;) returns G&lt;capture#1 of ?&gt; while
G&lt;?&gt; would arguably be the &quot;corresponding&quot; class or interface type.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463260</commentid>
    <comment_count>19</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-11 09:00:39 -0400</bug_when>
    <thetext>I have asked Dan Smith for clarifications. Based on what we hear, we will
take a call on this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2464249</commentid>
    <comment_count>20</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-13 23:06:31 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #19)
&gt; I have asked Dan Smith for clarifications. Based on what we hear, we will
&gt; take a call on this.

OK, we have the official word, a captured wildcard is to be treated as a type
not as a wildcard. Happily, we don&apos;t need to deviate/introduce hacks at all.
See https://bugs.eclipse.org/bugs/show_bug.cgi?id=446434#c1 - confusion
resolved. I&apos;ll update the patch at https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444 removing the hack.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471509</commentid>
    <comment_count>21</comment_count>
      <attachid>248169</attachid>
    <who name="Tim Griffith">tim.griffith.dev</who>
    <bug_when>2014-10-24 16:07:01 -0400</bug_when>
    <thetext>Created attachment 248169
Javac and 4.3 JDK8 support regression.

Minimal, self-contained code showing failure which seems to align to this bug - seeking confirmation that this is the correct tracking number.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471510</commentid>
    <comment_count>22</comment_count>
    <who name="Tim Griffith">tim.griffith.dev</who>
    <bug_when>2014-10-24 16:12:37 -0400</bug_when>
    <thetext>Version: Luna (4.4.1)
Build id: 20140925-1800

I have added a self-contained testcase which shows failure to bind a method reference to a genericized Functional Interface and pass to a genericized method. 
This comes after upgrading from 4.3 with JDK8 support to 4.4.1 and finding that previously building code (both under ECJ and javac) no longer builds within the 4.4.1 IDE. I have also confirmed that this behavior works correctly under IDEA 13.1 and so am looking for:
a) verification that this is the appropriate bug to track for the fix
b) if (a) then to request if this could be brought forward to a 4.4.X SR rather than waiting for 4.5 as this is reasonably impactful to the manner in which we are authoring JDK8 code.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471549</commentid>
    <comment_count>23</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-24 19:01:27 -0400</bug_when>
    <thetext>(In reply to Tim Griffith from comment #22)

&gt; a) verification that this is the appropriate bug to track for the fix

No.

The code snippet you have produced compiles fine on master (Mars HEAD)
while the present bug is still open.

Early next week, we are back porting a whole slew of bug fixes made to Mars
to Luna 4.4.2 maintenance stream.  You can grab a build towards the end of
the week to test.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471731</commentid>
    <comment_count>24</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-25 08:47:28 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #15)
&gt; I believe we are hitting https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891
&gt; in this one too.
&gt; 
&gt; The return expression of this lambda 
&gt; 
&gt; 
&gt; (ArrayList&lt;T&gt; left, ArrayList&lt;T&gt; right) -&gt; {
&gt;   		        left.addAll(right);
&gt;   		        return left;
&gt; 
&gt; is necessary to solve the type equations and we are dropping them ATN


Just to clarify status on this bug: is the spec change being tracked in bug 444891 indeed what turns this example from fail to pass?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471734</commentid>
    <comment_count>25</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-25 08:51:16 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #24)
&gt; (In reply to Srikanth Sankaran from comment #15)
&gt; &gt; I believe we are hitting https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891
&gt; &gt; in this one too.
&gt; &gt; 
&gt; &gt; The return expression of this lambda 
&gt; &gt; 
&gt; &gt; 
&gt; &gt; (ArrayList&lt;T&gt; left, ArrayList&lt;T&gt; right) -&gt; {
&gt; &gt;   		        left.addAll(right);
&gt; &gt;   		        return left;
&gt; &gt; 
&gt; &gt; is necessary to solve the type equations and we are dropping them ATN
&gt; 
&gt; 
&gt; Just to clarify status on this bug: is the spec change being tracked in bug
&gt; 444891 indeed what turns this example from fail to pass?

No, I think not. In comment#15 I was speculating/wondering aloud. I am fairly
certain in the final analysis bug 444891 was not involved.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471751</commentid>
    <comment_count>26</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-25 09:34:17 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #25)
&gt; (In reply to Stephan Herrmann from comment #24)
&gt; &gt; (In reply to Srikanth Sankaran from comment #15)
&gt; &gt; &gt; I believe we are hitting https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891
&gt; &gt; &gt; in this one too.
&gt; &gt; &gt; 
&gt; &gt; &gt; The return expression of this lambda 
&gt; &gt; &gt; 
&gt; &gt; &gt; 
&gt; &gt; &gt; (ArrayList&lt;T&gt; left, ArrayList&lt;T&gt; right) -&gt; {
&gt; &gt; &gt;   		        left.addAll(right);
&gt; &gt; &gt;   		        return left;
&gt; &gt; &gt; 
&gt; &gt; &gt; is necessary to solve the type equations and we are dropping them ATN
&gt; &gt; 
&gt; &gt; 
&gt; &gt; Just to clarify status on this bug: is the spec change being tracked in bug
&gt; &gt; 444891 indeed what turns this example from fail to pass?
&gt; 
&gt; No, I think not. In comment#15 I was speculating/wondering aloud. I am fairly
&gt; certain in the final analysis bug 444891 was not involved.

In that case I&apos;m at a loss seeing what *did* make the difference.
I&apos;m asking, because I see this as a positive test in bug 437444, whereas initial analysis concluded that rejecting should be correct.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471773</commentid>
    <comment_count>27</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-25 10:47:34 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #26)

&gt; In that case I&apos;m at a loss seeing what *did* make the difference.
&gt; I&apos;m asking, because I see this as a positive test in bug 437444, whereas
&gt; initial analysis concluded that rejecting should be correct.

Seeing that Collectors.groupingBy has this signature

Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier,
                                  Supplier&lt;M&gt; mapFactory,
                                  Collector&lt;? super T, A, D&gt; downstream);

I think we were impacted by the JLS bug 
https://bugs.openjdk.java.net/browse/JDK-8054721

Our present interim solution gets us past the failure.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471783</commentid>
    <comment_count>28</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-25 11:56:48 -0400</bug_when>
    <thetext>Fix and tests released as part of http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=f357f309273e0bfe8345ff708d18fa83c6a34931

made on behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=437444.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2473180</commentid>
    <comment_count>29</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-10-29 00:50:58 -0400</bug_when>
    <thetext>Verified for 4.5 M3 using  I20141027-2000 build.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2486571</commentid>
    <comment_count>30</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-11-20 11:21:09 -0500</bug_when>
    <thetext>Srikanth, should we consider this for 4.4.2? This fix is being mentioned in bug 443596 comment #3, which is tagged for 4.4.2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2486580</commentid>
    <comment_count>31</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-11-20 11:38:39 -0500</bug_when>
    <thetext>This bug being resolved by the patch for bug 437444 I don&apos;t see how we could possibly back port this one without the other (huge) patch.

Additionally, the mentioning in bug 443596 comment #3 is probably superseded by some of the 17 comments that followed (see in particular 443596 comment #5).

My 2c.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2486585</commentid>
    <comment_count>32</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-11-20 11:42:33 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #31)
&gt; This bug being resolved by the patch for bug 437444 I don&apos;t see how we could
&gt; possibly back port this one without the other (huge) patch.
&gt; 
&gt; Additionally, the mentioning in bug 443596 comment #3 is probably superseded
&gt; by some of the 17 comments that followed (see in particular 443596 comment
&gt; #5).
&gt; 
&gt; My 2c.

Agreed, I didn&apos;t pay close attention to the &quot;on behalf of ...&quot; comment. 

Srikanth, I will appreciate if you can call out which commits need to be back ported. Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2486792</commentid>
    <comment_count>33</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-11-20 23:15:42 -0500</bug_when>
    <thetext>(In reply to Jayaprakash Arthanareeswaran from comment #32)
&gt; (In reply to Stephan Herrmann from comment #31)
&gt; &gt; This bug being resolved by the patch for bug 437444 I don&apos;t see how we could
&gt; &gt; possibly back port this one without the other (huge) patch.
&gt; &gt; 
&gt; &gt; Additionally, the mentioning in bug 443596 comment #3 is probably superseded
&gt; &gt; by some of the 17 comments that followed (see in particular 443596 comment
&gt; &gt; #5).
&gt; &gt; 
&gt; &gt; My 2c.
&gt; 
&gt; Agreed, I didn&apos;t pay close attention to the &quot;on behalf of ...&quot; comment. 
&gt; 
&gt; Srikanth, I will appreciate if you can call out which commits need to be
&gt; back ported. Thanks!

I am not sure I can isolate it - After thinking about what we should do for
bug 437444, I think we should simply tell people to upgrade to M3 or M4 if
they are impacted. My confidence/comfort level is very high with the work done
for bug 437444, but it is huge and so it is reasonable to tell people to upgrade
to M3 if they need it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2486793</commentid>
    <comment_count>34</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-11-20 23:39:04 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #33)
&gt; I am not sure I can isolate it - After thinking about what we should do for
&gt; bug 437444, I think we should simply tell people to upgrade to M3 or M4 if
&gt; they are impacted. My confidence/comfort level is very high with the work
&gt; done
&gt; for bug 437444, but it is huge and so it is reasonable to tell people to
&gt; upgrade
&gt; to M3 if they need it.

Sorry, my bad. My question was actually for bug 443596.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>241880</attachid>
            <date>2014-04-11 06:12:00 -0400</date>
            <delta_ts>2014-04-11 06:12:27 -0400</delta_ts>
            <desc>An excerpt showing the error</desc>
            <filename>Snippet.java</filename>
            <type>text/plain</type>
            <size>1641</size>
            <attacher name="Timo Kinnunen">timo.kinnunen</attacher>
            
              <data encoding="base64">cGFja2FnZSBzbmlwcGV0OwoKaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7CmltcG9ydCBqYXZh
LnV0aWwuSGFzaE1hcDsKaW1wb3J0IGphdmEudXRpbC5mdW5jdGlvbi5GdW5jdGlvbjsKaW1wb3J0
IGphdmEudXRpbC5mdW5jdGlvbi5TdXBwbGllcjsKaW1wb3J0IGphdmEudXRpbC5zdHJlYW0uQ29s
bGVjdG9yOwppbXBvcnQgamF2YS51dGlsLnN0cmVhbS5Db2xsZWN0b3JzOwppbXBvcnQgamF2YS51
dGlsLnN0cmVhbS5TdHJlYW07CgpwdWJsaWMgY2xhc3MgU25pcHBldCB7CgoJc3RhdGljIDxULCBF
IGV4dGVuZHMgRXhjZXB0aW9uLCBLLCBMLCBNPiBNIHRlcm1pbmFsQXNNYXBUb0xpc3QoCiAgICBG
dW5jdGlvbjw/IHN1cGVyIFQsID8gZXh0ZW5kcyBLPiBjbGFzc2lmaWVyLAogICAgRnVuY3Rpb248
SGFzaE1hcDxLLCBMPiwgTT4gaW50b01hcCwKICAgIEZ1bmN0aW9uPEFycmF5TGlzdDxUPiwgTD4g
aW50b0xpc3QsCiAgICBTdXBwbGllcjxTdHJlYW08VD4+IHN1cHBsaWVyLAogICAgQ2xhc3M8RT4g
Y2xhc3NPZkUpIHRocm93cyBFIHsKICAJcmV0dXJuIHRlcm1pbmFsQXNDb2xsZWN0ZWQoCiAgCSAg
Y2xhc3NPZkUsCiAgCSAgQ29sbGVjdG9ycy5jb2xsZWN0aW5nQW5kVGhlbigKICAJICAgIENvbGxl
Y3RvcnMuZ3JvdXBpbmdCeSgKICAJICAgICAgY2xhc3NpZmllciwKICAJICAgICAgSGFzaE1hcDxL
LCBMPjo6bmV3LAogIAkgICAgICBDb2xsZWN0b3JzLmNvbGxlY3RpbmdBbmRUaGVuKAogIAkgICAg
ICAJLy8gVGhlIHR5cGUgQXJyYXlMaXN0PFQ+IGRvZXMgbm90IGRlZmluZSBhZGQoQXJyYXlMaXN0
PFQ+LCBPYmplY3QpIHRoYXQgaXMgYXBwbGljYWJsZSBoZXJlCiAgCSAgICAgIAkvLyBmcm9tIEFy
cmF5TGlzdDxUPjo6YWRkOgogIAkgICAgICAgIENvbGxlY3Rvci5vZihBcnJheUxpc3Q8VD46Om5l
dywgQXJyYXlMaXN0PFQ+OjphZGQsIChBcnJheUxpc3Q8VD4gbGVmdCwgQXJyYXlMaXN0PFQ+IHJp
Z2h0KSAtPiB7CiAgCQkgICAgICAgIGxlZnQuYWRkQWxsKHJpZ2h0KTsKICAJCSAgICAgICAgcmV0
dXJuIGxlZnQ7CiAgCSAgICAgICAgfSksCiAgCSAgICAgICAgaW50b0xpc3QpKSwKICAJICAgIGlu
dG9NYXApLAogIAkgIHN1cHBsaWVyKTsKICB9CglzdGF0aWMgPEUgZXh0ZW5kcyBFeGNlcHRpb24s
IFQsIE0+IE0gdGVybWluYWxBc0NvbGxlY3RlZCgKICAgIENsYXNzPEU+IGNsYXNzMSwKICAgIENv
bGxlY3RvcjxULCA/LCBNPiBjb2xsZWN0b3IsCiAgICBTdXBwbGllcjxTdHJlYW08VD4+IHN1cHBs
aWVyKSB0aHJvd3MgRSB7CiAgCXRyeShTdHJlYW08VD4gcyA9IHN1cHBsaWVyLmdldCgpKSB7CiAg
CQlyZXR1cm4gcy5jb2xsZWN0KGNvbGxlY3Rvcik7CiAgCX0gY2F0Y2goUnVudGltZUV4Y2VwdGlv
biBlKSB7CiAgCQl0aHJvdyB1bndyYXBDYXVzZShjbGFzczEsIGUpOwogIAl9CiAgfQoJc3RhdGlj
IDxFIGV4dGVuZHMgRXhjZXB0aW9uPiBFIHVud3JhcENhdXNlKENsYXNzPEU+IGNsYXNzT2ZFLCBS
dW50aW1lRXhjZXB0aW9uIGUpIHRocm93cyBFIHsKCQlUaHJvd2FibGUgY2F1c2UgPSBlLmdldENh
dXNlKCk7CgkJaWYoY2xhc3NPZkUuaXNJbnN0YW5jZShjYXVzZSkgPT0gZmFsc2UpIHsKCQkJdGhy
b3cgZTsKCQl9CgkJdGhyb3cgY2xhc3NPZkUuY2FzdChjYXVzZSk7Cgl9Cn0K
</data>

          </attachment>
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>248169</attachid>
            <date>2014-10-24 16:07:00 -0400</date>
            <delta_ts>2014-10-24 16:07:01 -0400</delta_ts>
            <desc>Javac and 4.3 JDK8 support regression.</desc>
            <filename>Eclipse44Java8MethodReferencesTest.java</filename>
            <type>application/octet-stream</type>
            <size>645</size>
            <attacher name="Tim Griffith">tim.griffith.dev</attacher>
            
              <data encoding="base64">cGFja2FnZSBzcGluZS50dXRvcmlhbDsNCg0KaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uOw0K
DQppbXBvcnQgb3JnLmp1bml0LlRlc3Q7DQoNCnB1YmxpYyBjbGFzcyBFY2xpcHNlNDRKYXZhOE1l
dGhvZFJlZmVyZW5jZXNUZXN0IHsNCg0KICAgIEBGdW5jdGlvbmFsSW50ZXJmYWNlDQogICAgaW50
ZXJmYWNlIEV4dGVuZHM8VD4gew0KICAgICAgICB2b2lkIGZvbyhDb2xsZWN0aW9uPFQ+IHZhbHVl
KTsNCiAgICB9DQogICAgDQogICAgcHJpdmF0ZSA8VD4gdm9pZCBjb25zdW1lcihFeHRlbmRzPFQ+
IGlucHV0KSB7fQ0KICAgIA0KICAgIHByaXZhdGUgdm9pZCBjb25jcmV0ZU1ldGhvZChDb2xsZWN0
aW9uPFN0cmluZz4gdmFsdWVzKSB7fQ0KICAgIA0KICAgIEBUZXN0DQogICAgcHVibGljIHZvaWQg
aWxsdXN0cmF0ZUphdmFjU3VjY2Vzc0pEVENvcmVGYWlsdXJlKCkgew0KICAgICAgICAvLyBFQ0og
ZmFpbHVyZTogVGhlIFR5cGUgRWNsaXBzZTMzSmF2YThNZXRob2RSZWZlcmVuY2VzVGVzdCBkb2Vz
IG5vdCBkZWZpbmUgDQogICAgICAgIC8vIGNvbmNyZXRlTWV0aG9kKENvbGxlY3Rpb248VD4pIHRo
YXQgaXMgYXBwbGljYWJsZSBoZXJlLg0KICAgICAgICBjb25zdW1lcih0aGlzOjpjb25jcmV0ZU1l
dGhvZCk7DQogICAgfQ0KfQ0K
</data>

          </attachment>
      

    </bug>

</bugzilla>