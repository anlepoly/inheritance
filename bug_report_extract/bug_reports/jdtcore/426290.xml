<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>426290</bug_id>
          
          <creation_ts>2014-01-21 13:38:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Inference + overloading =&gt; wrong method resolution ?</short_desc>
          <delta_ts>2014-01-23 10:10:44 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>blocker</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          <blocked>424053</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>jarthana</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2352665</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-01-21 13:38:29 -0500</bug_when>
    <thetext>// --
import java.util.ArrayList;
import java.util.List;

public class X {
    public static void main(String argv[]) {
       goo(foo());
    }

    static &lt;T extends Number&gt; List&lt;T&gt; foo() {
        return new ArrayList&lt;T&gt;();
    }

    static void goo(Object p1) {
        System.out.println(&quot;goo(Object)&quot;);
    }

    static void goo(List&lt;Integer&gt; p1) {
        System.out.println(&quot;goo(List&lt;Integer&gt;)&quot;);
    }
}

On the program above, ECJ compile results in goo(Object) while
javac compile results in goo(List&lt;Integer&gt;)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2352666</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-01-21 13:39:10 -0500</bug_when>
    <thetext>Is this a bug in most specific inference implementation ? Thanks for looking
into this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2352771</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-21 18:39:40 -0500</bug_when>
    <thetext>We have a problem with invoking Scope.mostSpecificMethodBinding() with a fixed array of argumentTypes. These types are the provisional results from invocation applicability inference for contained arguments (here: foo()), not the final results from invocation type inference. The final results may be different for different method candidates for the outer invocation.
 
Ergo: we need to use different argumentTypes per candidate, which are updated from the corresponding instance of (inner) invocation type inference (to yield &quot;List&lt;Integer&gt;&quot; when targeting goo(List&lt;Integer&gt;)).

For this scenario, invocation type inference is triggered from parameterCompatibilityLevel18(). Each time we invoke this method it must be passed a fresh new array argumentTypes, so that inference results can safely be reported back into that array.

Unfortunately we cannot easily use an InferenceContext18 to hold this information since the outer method goo() does not use inference.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2353298</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-01-22 22:19:31 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #2)

&gt; Unfortunately we cannot easily use an InferenceContext18 to hold this
&gt; information since the outer method goo() does not use inference.

Does creating one even when outer is not generic possible ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2353449</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-23 07:05:21 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; 
&gt; &gt; Unfortunately we cannot easily use an InferenceContext18 to hold this
&gt; &gt; information since the outer method goo() does not use inference.
&gt; 
&gt; Does creating one even when outer is not generic possible ?

Indeed that might give a much cleaner solution than changing tons of signatures from &quot;TypeBinding[] argumentTypes&quot; to &quot;TypeBinding[][] argsPerCandidate&quot;.

I&apos;ll try my best down this road :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2353550</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-23 10:10:44 -0500</bug_when>
    <thetext>When searching for a solution to a scary task, it usually helps to look in the right place :)

Indeed, storing the information (from inner inference) right when it occurs and into a place that&apos;s accessible when needed (during Scope.mostSpecificMethodBinding()), is all it needed to resolve this issue, phew!

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=cbe2b622e81a27ceffd382724966e1dd065a9d5c</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>