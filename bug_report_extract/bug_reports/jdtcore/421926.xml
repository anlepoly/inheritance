<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>421926</bug_id>
          
          <creation_ts>2013-11-17 22:43:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Compiler tolerates illegal forward reference from lambda in initializer</short_desc>
          <delta_ts>2014-04-25 13:52:09 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>https://bugs.eclipse.org/bugs/show_bug.cgi?id=433535</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>daniel_megert</cc>
    
    <cc>jarthana</cc>
    
    <cc>markus_keller</cc>
    
    <cc>noopur_gupta</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2331088</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-17 22:43:32 -0500</bug_when>
    <thetext>BETA_JAVA8:
-----------

The following program compiles with ECJ, but fails to compile with
8b115.

It appears ECJ behavior is incorrect.

// --
interface I { 
	int run(int s1, int s2); 
}

class X {
	
    static int f = ((I) (int x5, int x2) -&gt; x1).run(10,  20);
    static int x1 = 2;
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334376</commentid>
    <comment_count>1</comment_count>
    <who name="Noopur Gupta">noopur_gupta</who>
    <bug_when>2013-11-26 03:44:27 -0500</bug_when>
    <thetext>Another example, which compiles with ECJ, but not with 8b115:

----------------------------------------------
package test.inline;

interface I {
	I run(int s1);
}

class X {	
	public static final I fi = x -&gt; fi;
}
---------------------------------------------</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334625</commentid>
    <comment_count>2</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-11-26 11:47:08 -0500</bug_when>
    <thetext>Srikanth, I think this needs to be taken to the 335 EG.

JLS7 8.3.2.3 &quot;Restrictions on the use of Fields during Initialization&quot; says as point 4: &quot;C is the innermost class or interface enclosing the usage&quot;.

This should be expanded to include lambda bodies, e.g.:
&quot;C is the innermost class or interface enclosing the usage, or the usage occurs inside a lambda expression that occurs inside C&quot;.

The informative text later in that section confirms this intention:
&quot;The restrictions above are designed to catch, at compile time, circular or otherwise malformed initializations.&quot;

In case of lambda bodies, self-references don&apos;t cause malformed initializations.


Example that shows that javac only disallows unqualified access as per 8.3.2.3:

public class C {
    // OK:
    Runnable qi= () -&gt; executeAndRepost(this.qi);
    static Runnable qs= () -&gt; executeAndRepost(C.qs);
    
    // javac 1.8.0-ea-b115 says: error: self-reference in initializer
    Runnable i= () -&gt; executeAndRepost(i);
    static Runnable s= () -&gt; executeAndRepost(s);
    
    static void executeAndRepost(Runnable r) { }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2337013</commentid>
    <comment_count>3</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-12-03 10:04:52 -0500</bug_when>
    <thetext>http://mail.openjdk.java.net/pipermail/lambda-spec-observers/2013-December/000588.html</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2343430</commentid>
    <comment_count>4</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-12-18 13:15:37 -0500</bug_when>
    <thetext>Updated the spec request: http://mail.openjdk.java.net/pipermail/lambda-spec-observers/2013-December/000623.html

The problem is actually not only about self-references from the lambda 
body of a field initializer, but about any forward reference that is 
forbidden by JLS7 8.3.2.3.

A better example:
----------
public class D {
    int v1 = value; // Error for 8.3.2.3 (good).
    int v2 = D.this.value; // No simple name -&gt; no error (good).
 
    IntSupplier s1 = () -&gt; value; // Why error?
    IntSupplier s2 = new IntSupplier() {
        @Override
        public int getAsInt() {
            return value; // No error (good).
        }
    };
 
    int value = 42;
}
----------

There&apos;s absolutely no problem with the reference in s1&apos;s initializer. The 
only problem is that 8.3.2.3 needs to be updated to make lambda bodies 
behave the same as nested class bodies.

REQUEST:
========
8.3.2.3 should get a fifth point:
&quot;- The usage is not in a lambda expression body that occurs inside c.&quot;

The next sentence could also be clarified to:
&quot;It is a compile-time error if any of the five requirements above are not 
met for such a forward reference.&quot;
========

FWIW, this still excludes the forward reference to &quot;VALUE&quot; here:

    public static final IntConsumer c = (@A(VALUE) int x) -&gt; {};
    public static final int VALUE = 42;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2349774</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-01-15 00:50:10 -0500</bug_when>
    <thetext>The plan is to conform to the present spec and reference compiler behavior and
react at the right time to any changes as they happen.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2349785</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-01-15 01:41:24 -0500</bug_when>
    <thetext>Fix and test released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=cc95db68297f07027a83fc8b08b9b05722eceebc</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>