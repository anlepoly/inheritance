<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>435187</bug_id>
          
          <creation_ts>2014-05-19 07:18:00 -0400</creation_ts>
          <short_desc>[1.8] ECJ reports error in the code without type information</short_desc>
          <delta_ts>2014-09-23 22:24:49 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>DUPLICATE</resolution>
          <dup_id>432682</dup_id>
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          <blocked>428061</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Noopur Gupta">noopur_gupta</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>nikolaymetchev</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2403603</commentid>
    <comment_count>0</comment_count>
    <who name="Noopur Gupta">noopur_gupta</who>
    <bug_when>2014-05-19 07:18:13 -0400</bug_when>
    <thetext>From bug 433783 comment #2:

The Eclipse compiler complains and oracle javac and Idea doesn&apos;t:

The method collect(Collector&lt;? super Object,A,R&gt;) in the type Stream&lt;Object&gt; is not applicable for the arguments (Collector&lt;Map.Entry&lt;String,String&gt;,capture#1-of ?,Map&lt;String,List&lt;String&gt;&gt;&gt;)	


Sample code that doesn&apos;t compile:

import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.stream.Collector;
import java.util.stream.Stream;

public class ExtractLocalLambda {
	static Stream&lt;Entry&lt;List&lt;String&gt;, String&gt;&gt; map;
	static Collector&lt;Entry&lt;String, String&gt;, ?, Map&lt;String, List&lt;String&gt;&gt;&gt; groupingBy;
	private static Stream&lt;String&gt; stream(Entry&lt;List&lt;String&gt;, String&gt; p) {		return null;	}
	private static Entry&lt;String, String&gt; keep(Entry&lt;List&lt;String&gt;, String&gt; p, String leftHS2) {		return null;	}

	static Map&lt;String, List&lt;String&gt;&gt; beforeRefactoring() {
		// Extract local variable from the parameter to flatMap:
		return map.flatMap(
				p -&gt; stream(p).map(leftHS -&gt; {
					String leftHS2 = leftHS;
					return keep(p, leftHS2);
				})
		).collect(groupingBy);
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2403779</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-05-19 13:13:36 -0400</bug_when>
    <thetext>I admit the error message isn&apos;t very helpful.

OTOH, I&apos;d be reluctant to tell whether or not that code is legal Java 8 (and looking just at javac behavior doesn&apos;t suffice for judging).

Anyway, too late for Luna.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2403852</commentid>
    <comment_count>2</comment_count>
    <who name="Nikolay Metchev">nikolaymetchev</who>
    <bug_when>2014-05-19 18:00:45 -0400</bug_when>
    <thetext>The fact that both Javac and Idea don&apos;t complain is telling I think.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2403855</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-05-19 18:27:50 -0400</bug_when>
    <thetext>(In reply to Nikolay Metchev from comment #2)
&gt; The fact that both Javac and Idea don&apos;t complain is telling I think.

Since I wasn&apos;t 100% sure about IDEA, I just looked up their help and was actually surprised to find:

   &quot;Select the desired compiler from the list of the supported ones:

    - Javac. This compiler is taken from the Java SDK currently assigned to the project.
    - Eclipse. IntelliJ IDEA comes bundled with the Eclipse compiler.
    - Ajc. This compiler is not included in IntelliJ IDEA distribution and should be downloaded separately.&quot;

I was aware, that Idea does not have an own Java compiler, but that they offer to use ours was indeed news for me :))


Remain: ecj vs. javac. 

I have no indication that javac is more reliable in terms of type-checking Java 8 than ecj.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2403861</commentid>
    <comment_count>4</comment_count>
    <who name="Nikolay Metchev">nikolaymetchev</who>
    <bug_when>2014-05-19 19:34:36 -0400</bug_when>
    <thetext>That setting is just for generating .class files. In order to be able to do all other functions (e.g. refactoring) idea must have a parser and AST. I think in the next version they are actually planning on adding a full blown compiler as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2403862</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-05-19 19:37:23 -0400</bug_when>
    <thetext>(In reply to Nikolay Metchev from comment #4)
&gt; That setting is just for generating .class files.

IFAICS this is also what generates the error messages. That&apos;s what&apos;s relevant here.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2434347</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-31 14:13:27 -0400</bug_when>
    <thetext>Analysis part 1:

&quot;map.flatMap(,,)&quot; is a standalone expression (no target type available) which we resolve to:
  Stream&lt;Object&gt; flatMap(Function&lt;? super Entry&lt;List&lt;String&gt;,String&gt;,? extends Stream&lt;? extends Object&gt;&gt;)

After that resolution is done we resolve &quot;collect(groupingBy)&quot;, starting from the receiver type provided by the return of flatMap:
  Stream&lt;Object&gt;

At this point we search Stream&lt;Object&gt; for a method &quot;collect&quot; accepting an argument of type
  Collector&lt;Entry&lt;String, String&gt;, ?, Map&lt;String, List&lt;String&gt;&gt;&gt;

That method doesn&apos;t exist, we only find a method
  &lt;R, A&gt; R collect(Collector&lt;? super Object, A, R&gt; collector)

since Entry&lt;String,String&gt; is not a valid substitute for &apos;? super Object&apos; (i.e., the two instantiations of Collector are incompatible) we report an error.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2434367</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-31 14:53:29 -0400</bug_when>
    <thetext>The only way to challenge the above chain of inference is to attack the first step: is it correct to resolve &quot;map.flatMap(..)&quot; to the mentioned signature with &quot;Stream&lt;Object&gt;&quot; as the return type?

As mentioned, this invocation is a standalone expression, so we only have the information from the following snippet, plus things referenced from there:

        map.flatMap(
                p -&gt; stream(p).map(leftHS -&gt; {
                    String leftHS2 = leftHS;
                    return keep(p, leftHS2);
                })
        )

Original signature of Stream&lt;T&gt;.flatMap(..) is:
  &lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt;)

So we need to investigate how this &lt;R&gt; is inferred.

In the absence of a target type, all we know about R must be derived from the parameter, which enters inference in the shape of this constraint:

  (&lt;no type&gt; p) -&gt; stream(p).map((&lt;no type&gt; leftHS) -&gt; {
    String leftHS2 = leftHS;
    return keep(p, leftHS2);
  })  Function&lt;? super Map.Entry&lt;List&lt;String&gt;,String&gt;,? extends Stream&lt;? extends R#0&gt;&gt;

Reduction of the above creates:

  stream(p).map((&lt;no type&gt; leftHS) -&gt; {
    String leftHS2 = leftHS;
    return keep(p, leftHS2);
  })  Stream&lt;? extends R#0&gt;

I.e. the map(..) call must produce a value of some type Stream&lt;? extends R#0&gt;

Now order of inference steps plays a key role:

* We are in the process of inferring types for the flatMap() invocation (outer)
* We reduce an expression compatibility constraint whose LHS is the method invocation map(..) (inner)

The decisive element is JLS 18.2.1 bullet 3.2:
&quot; If the expression is a class instance creation expression or a method invocation expression, the constraint reduces to the bound set B3 which would be used to determine the expression&apos;s invocation type when targeting T, as defined in 18.5.2.&quot;

This is crucial, because the steps leading to the bound set B3 *do not touch* any of the invocation arguments. These arguments are only consulted later when creating &quot;C&quot; from which the bound set &quot;B4&quot; is derived. But B4 is not considered at this point.

This means, while inferring types for the flatMap(..) invocation, we never look at this inner lambda:
  (&lt;no type&gt; leftHS) -&gt; {
    String leftHS2 = leftHS;
    return keep(p, leftHS2);
  }

Looking at the nested statement &quot;return keep(..)&quot; *could* provide the desired type information connecting &lt;R&gt; to Entry&lt;String,String&gt;, but the compiler is not allowed to use this information at this stage.

For lack of type information from arguments, inferring types for map(..) has only these bits of information:
- receiver type: Stream&lt;String&gt;
- target type: ? extends Stream&lt;? extends R#0&gt;
where R#0 is the type we are currently inferring.

With now further constraints on R#0 we infer it to java.lang.Object.

End of story.


Epilogue:
After types for flatMap(..) have been inferred the remaining inference steps are performed for map(..), using the results from outer interence. This eventually updates the return type of map(..) to &quot;Stream&lt;Entry&lt;String,String&gt;&gt;&quot;. 
This demonstrates that our inference does produce the expected type for this nested call. HOWEVER, this comes too late for the outer invocation of flatMap(..), whose inference is already finalized at that point.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2434369</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-31 14:56:06 -0400</bug_when>
    <thetext>Scheduling for the typical scrutiny of: reporting a bug against javac and closing once that bug has been accepted on their side.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2434376</commentid>
    <comment_count>9</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-31 15:11:29 -0400</bug_when>
    <thetext>I&apos;ve released the example as a negative regression test via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=c7d5dd9d5cb1b97ae6a8cae6547b02ca06b345eb</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2453448</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-18 00:06:56 -0400</bug_when>
    <thetext>Targetting for 4.5 M3. While ATM ownership is left unchanged, Stephan is under
time constraint during this window, so I will likely take this over or assign to someone else to load balance later on.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454052</commentid>
    <comment_count>11</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-19 03:47:30 -0400</bug_when>
    <thetext>The proposed patch at https://bugs.eclipse.org/bugs/show_bug.cgi?id=432682#c10
solves this problem.

*** This bug has been marked as a duplicate of bug 432682 ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454107</commentid>
    <comment_count>12</comment_count>
    <who name="Nikolay Metchev">nikolaymetchev</who>
    <bug_when>2014-09-19 04:58:43 -0400</bug_when>
    <thetext>I&apos;m confused,
According to Stephen this wasn&apos;t a bug in eclipse.
Did Oracle convince you otherwise?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454204</commentid>
    <comment_count>13</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-19 09:43:12 -0400</bug_when>
    <thetext>(In reply to Nikolay Metchev from comment #12)
&gt; I&apos;m confused,
&gt; According to Stephen this wasn&apos;t a bug in eclipse.
&gt; Did Oracle convince you otherwise?

We&apos;re still discussing in the other bug :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2455577</commentid>
    <comment_count>14</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-23 22:24:49 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #13)
&gt; (In reply to Nikolay Metchev from comment #12)
&gt; &gt; I&apos;m confused,
&gt; &gt; According to Stephen this wasn&apos;t a bug in eclipse.
&gt; &gt; Did Oracle convince you otherwise?
&gt; 
&gt; We&apos;re still discussing in the other bug :)

For posterity: Stephan&apos;s claim was correct, there is indeed a clause that
is missing in the relevant section: 

See https://bugs.openjdk.java.net/browse/JDK-8038747

I have opened: https://bugs.eclipse.org/bugs/show_bug.cgi?id=444891

Interim workaround &quot;fix&quot; has been released on behalf of  bug 432682</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>