<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>347396</bug_id>
          
          <creation_ts>2011-05-27 02:30:00 -0400</creation_ts>
          <short_desc>ASTParser returns empty or partial AST if we parse when the body contains empty for loop</short_desc>
          <delta_ts>2011-09-13 04:59:10 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>3.7</version>
          <rep_platform>All</rep_platform>
          <op_sys>Windows XP</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>3.8 M2</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Francis Sujai A">afsujai</reporter>
          <assigned_to name="Olivier Thomann">Olivier_Thomann</assigned_to>
          <cc>amj87.iitr</cc>
    
    <cc>daniel_megert</cc>
    
    <cc>Olivier_Thomann</cc>
    
    <cc>satyam.kandula</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>1938557</commentid>
    <comment_count>0</comment_count>
    <who name="Francis Sujai A">afsujai</who>
    <bug_when>2011-05-27 02:30:08 -0400</bug_when>
    <thetext>Build Identifier: Version: 3.6.2, Build id: M20110210-1200

ASTParser parsed with K_STATEMENTS kind and the source contains an empty for loop (e.g. for{};) returns the empty/partial ASTNode.

Tried with parser.setStatementsRecovery(true) also.

I want to parse the code and find analyze it. So, even with errors (syntax/semantic errors in th code), I would like to get the AST with recovered statements and problems. 

I have attached the running test case code and let me know if there is any work around to get the full AST node.

Thanks in advance.

Reproducible: Always

Steps to Reproduce:
Sample code to test this behavior:

if you use the commented out source, AST is returned properly and my visitor could visit all the nodes. 
===================================================

import java.util.HashSet;
import java.util.Set;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.Block;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;

public class Test {
	public static void main(String args[]){
		ASTParser parser = ASTParser.newParser(AST.JLS3);
		//parser.setSource(&quot;int i = 9;  \n int j;\n for(int k = 0; k &lt; i; k++) {int ii =10;}; \n ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();j=1000; &quot;.toCharArray());
		parser.setSource(&quot;int i = 9;  \n int j;\n for {}; \n ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();j=1000; &quot;.toCharArray());
		parser.setKind(ASTParser.K_STATEMENTS);
		parser.setStatementsRecovery(true);
 
		final Block block = (Block) parser.createAST(null);
		ASTNode parent = block.getParent();
		while (parent != null &amp;&amp; !(parent instanceof CompilationUnit)) {
			parent = parent.getParent();
		}
		final CompilationUnit cu = (CompilationUnit) parent;
		cu.accept(new ASTVisitor() {
 
			Set names = new HashSet();
 
			public boolean visit(VariableDeclarationFragment node) {
				SimpleName name = node.getName();
				this.names.add(name.getIdentifier());
				System.out.println(&quot;Declaration of &apos;&quot;+name+&quot;&apos; at line&quot;+cu.getLineNumber(name.getStartPosition()));
				return false; // do not continue to avoid usage info
			}
 
			public boolean visit(SimpleName node) {
				if (this.names.contains(node.getIdentifier())) {
				System.out.println(&quot;Usage of &apos;&quot; + node + &quot;&apos; at line &quot; +	cu.getLineNumber(node.getStartPosition()));
				}
				return true;
			}
 
		});
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1939044</commentid>
    <comment_count>1</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2011-05-27 02:46:42 -0400</bug_when>
    <thetext>The AST currently has an EmptyStatement node corresponding to 
for{};

This is completely invalid and not even close to a usual &apos;for&apos; syntax. What do you expect here?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1939245</commentid>
    <comment_count>2</comment_count>
    <who name="Francis Sujai A">afsujai</who>
    <bug_when>2011-05-27 02:59:42 -0400</bug_when>
    <thetext>(In reply to comment #1)
&gt; The AST currently has an EmptyStatement node corresponding to 
&gt; for{};
&gt; 
&gt; This is completely invalid and not even close to a usual &apos;for&apos; syntax. What do
&gt; you expect here?

I understand that. But, is there any way we can recover the other statements.

IMO, statement recovery is meant for that. But, with that also, AST is completely unusable. In case of errors (syntax/semantic), I expect ASTParser to recover all the remaining valid statements and cu.getProblems() will return all the problems(i.e errors).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1939599</commentid>
    <comment_count>3</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-05-27 08:58:38 -0400</bug_when>
    <thetext>This works fine if the code is wrapped into a compilation unit declaration.
The parser options has to set the compiler source, target and compliance to 1.5 though.
This would require further investigation as why the statement recovery doesn&apos;t return the same result with K_STATEMENTS and K_COMPILATION_UNIT.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1939602</commentid>
    <comment_count>4</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-05-27 09:00:40 -0400</bug_when>
    <thetext>So this works as you expect:
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;

public class Test {
	public static void main(String args[]) {
		ASTParser parser = ASTParser.newParser(AST.JLS3);
		Map options = JavaCore.getOptions();
		options.put(JavaCore.COMPILER_COMPLIANCE, JavaCore.VERSION_1_5);
		options.put(JavaCore.COMPILER_SOURCE, JavaCore.VERSION_1_5);
		options.put(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM,
				JavaCore.VERSION_1_5);
		parser.setSource(&quot;class X { public void foo() { int i = 9;  \n int j;\n for {}; \n ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();j=1000;}}&quot;
				.toCharArray());
		parser.setCompilerOptions(options);
		parser.setKind(ASTParser.K_COMPILATION_UNIT);
		parser.setStatementsRecovery(true);

		final CompilationUnit cu = (CompilationUnit) parser.createAST(null);
		cu.accept(new ASTVisitor() {

			Set names = new HashSet();

			public boolean visit(VariableDeclarationFragment node) {
				SimpleName name = node.getName();
				this.names.add(name.getIdentifier());
				System.out.println(&quot;Declaration of &apos;&quot; + name + &quot;&apos; at line&quot;
						+ cu.getLineNumber(name.getStartPosition()));
				return false; // do not continue to avoid usage info
			}

			public boolean visit(SimpleName node) {
				if (this.names.contains(node.getIdentifier())) {
					System.out.println(&quot;Usage of &apos;&quot; + node + &quot;&apos; at line &quot;
							+ cu.getLineNumber(node.getStartPosition()));
				}
				return true;
			}
		});
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1971226</commentid>
    <comment_count>5</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-07-27 15:37:01 -0400</bug_when>
    <thetext>Ayushman, we should investigate why we have a difference between the two kinds: K_STATEMENTS and K_COMPILATION_UNIT. This might hide a more serious issue.
Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1988446</commentid>
    <comment_count>6</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-09-02 12:08:23 -0400</bug_when>
    <thetext>I&apos;ll see what can be done as Ayushman is in vacations till M2 ships. Might have to be moved to 3.8M3.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1990791</commentid>
    <comment_count>7</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-09-08 12:37:53 -0400</bug_when>
    <thetext>(In reply to comment #1)
&gt; The AST currently has an EmptyStatement node corresponding to 
&gt; for{};
In fact the recovery produces an empty statement for the &apos;;&apos; part of &quot;for {};&quot;. There is no recovered statement at all corresponding to &quot;for {}&quot;.

I have a fix which returns the same number of statements using K_STATEMENTS, but it doesn&apos;t fix the missing recovered statement for the code &quot;for {}&quot;.

Testing the fix right now. Ayushman, we might work on trying to report a recovered statement for the bogus for loop.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1990921</commentid>
    <comment_count>8</comment_count>
      <attachid>203017</attachid>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-09-08 14:36:41 -0400</bug_when>
    <thetext>Created attachment 203017
Proposed fix + regression tests</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1990922</commentid>
    <comment_count>9</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-09-08 14:36:53 -0400</bug_when>
    <thetext>Released for 3.8M2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1990930</commentid>
    <comment_count>10</comment_count>
    <who name="Olivier Thomann">Olivier_Thomann</who>
    <bug_when>2011-09-08 14:41:38 -0400</bug_when>
    <thetext>(In reply to comment #7)
&gt; Testing the fix right now. Ayushman, we might work on trying to report a
&gt; recovered statement for the bogus for loop.
I opened bug 357139 for this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1992482</commentid>
    <comment_count>11</comment_count>
    <who name="Satyam Kandula">satyam.kandula</who>
    <bug_when>2011-09-13 04:59:10 -0400</bug_when>
    <thetext>Verified for 3.8M2 using build I20110912-0800</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="1"
              isprivate="0"
          >
            <attachid>203017</attachid>
            <date>2011-09-08 14:36:00 -0400</date>
            <delta_ts>2011-09-08 14:36:41 -0400</delta_ts>
            <desc>Proposed fix + regression tests</desc>
            <filename>patch_347396.txt</filename>
            <type>text/plain</type>
            <size>4057</size>
            <attacher name="Olivier Thomann">Olivier_Thomann</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUN
CkluZGV4OiBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcGFyc2Vy
L1BhcnNlci5qYXZhDQo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09DQpSQ1MgZmlsZTogL2N2c3Jvb3QvZWNsaXBzZS9vcmcu
ZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGls
ZXIvcGFyc2VyL1BhcnNlci5qYXZhLHYNCnJldHJpZXZpbmcgcmV2aXNpb24gMS40MzANCmRpZmYg
LXUgLXIxLjQzMCBQYXJzZXIuamF2YQ0KLS0tIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRl
cm5hbC9jb21waWxlci9wYXJzZXIvUGFyc2VyLmphdmEJOCBTZXAgMjAxMSAxNDoxODo1NCAtMDAw
MAkxLjQzMA0KKysrIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9w
YXJzZXIvUGFyc2VyLmphdmEJOCBTZXAgMjAxMSAxODozNjowNCAtMDAwMA0KQEAgLTk3MjIsNiAr
OTcyMiw4IEBADQogCWJvb2xlYW4gb2xkTWV0aG9kUmVjb3ZlcnlBY3RpdmF0ZWQgPSB0aGlzLm1l
dGhvZFJlY292ZXJ5QWN0aXZhdGVkOw0KIAlpZih0aGlzLm9wdGlvbnMucGVyZm9ybU1ldGhvZHNG
dWxsUmVjb3ZlcnkpIHsNCiAJCXRoaXMubWV0aG9kUmVjb3ZlcnlBY3RpdmF0ZWQgPSB0cnVlOw0K
KwkJLy8gd2Ugc2hvdWxkIG5vdCByZWxvY2F0ZSBib2R5U3RhcnQgaWYgdGhlcmUgaXMgYSBibG9j
ayB3aXRoaW4gdGhlIHN0YXRlbWVudHMNCisJCXRoaXMuaWdub3JlTmV4dE9wZW5pbmdCcmFjZSA9
IHRydWU7DQogCX0NCiANCiAJaW5pdGlhbGl6ZSgpOw0KQEAgLTk5NzEsNiArOTk3Myw4IEBADQog
DQogCWJvb2xlYW4gb2xkTWV0aG9kUmVjb3ZlcnlBY3RpdmF0ZWQgPSB0aGlzLm1ldGhvZFJlY292
ZXJ5QWN0aXZhdGVkOw0KIAlpZih0aGlzLm9wdGlvbnMucGVyZm9ybU1ldGhvZHNGdWxsUmVjb3Zl
cnkpIHsNCisJCS8vIHdlIHNob3VsZCBub3QgcmVsb2NhdGUgYm9keVN0YXJ0IGlmIHRoZXJlIGlz
IGEgYmxvY2sgd2l0aGluIHRoZSBzdGF0ZW1lbnRzDQorCQl0aGlzLmlnbm9yZU5leHRPcGVuaW5n
QnJhY2UgPSB0cnVlOw0KIAkJdGhpcy5tZXRob2RSZWNvdmVyeUFjdGl2YXRlZCA9IHRydWU7DQog
CQl0aGlzLnJQYXJlblBvcyA9IG1kLnNvdXJjZUVuZDsNCiAJfQ0KI1Agb3JnLmVjbGlwc2UuamR0
LmNvcmUudGVzdHMubW9kZWwNCkluZGV4OiBzcmMvb3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMv
ZG9tL0FTVENvbnZlcnRlclRlc3RBU1Q0XzIuamF2YQ0KPT09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQ0KUkNTIGZpbGU6IC9j
dnNyb290L2VjbGlwc2Uvb3JnLmVjbGlwc2UuamR0LmNvcmUudGVzdHMubW9kZWwvc3JjL29yZy9l
Y2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2RvbS9BU1RDb252ZXJ0ZXJUZXN0QVNUNF8yLmphdmEsdg0K
cmV0cmlldmluZyByZXZpc2lvbiAxLjINCmRpZmYgLXUgLXIxLjIgQVNUQ29udmVydGVyVGVzdEFT
VDRfMi5qYXZhDQotLS0gc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2RvbS9BU1RDb252
ZXJ0ZXJUZXN0QVNUNF8yLmphdmEJMjggSnVsIDIwMTEgMTc6MDY6MDMgLTAwMDAJMS4yDQorKysg
c3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2RvbS9BU1RDb252ZXJ0ZXJUZXN0QVNUNF8y
LmphdmEJOCBTZXAgMjAxMSAxODozNjowNSAtMDAwMA0KQEAgLTEyMiw3ICsxMjIsNyBAQA0KIAlz
dGF0aWMgew0KIC8vCQlURVNUU19OQU1FUyA9IG5ldyBTdHJpbmdbXSB7InRlc3QwNjAyIn07DQog
Ly8JCVRFU1RTX1JBTkdFID0gbmV3IGludFtdIHsgNzIxLCAtMSB9Ow0KLS8vCQlURVNUU19OVU1C
RVJTID0gIG5ldyBpbnRbXSB7IDcyMSwgNzIyLCA3MjMsIDcyNCwgNzI1IH07DQorLy8JCVRFU1RT
X05VTUJFUlMgPSAgbmV3IGludFtdIHsgNzIzLCA3MjQgfTsNCiAJfQ0KIAlwdWJsaWMgc3RhdGlj
IFRlc3Qgc3VpdGUoKSB7DQogCQlyZXR1cm4gYnVpbGRNb2RlbFRlc3RTdWl0ZShBU1RDb252ZXJ0
ZXJUZXN0QVNUNF8yLmNsYXNzKTsNCkBAIC0xMDY0MSw0ICsxMDY0MSw0NyBAQA0KIAkJCX0NCiAJ
CX0NCiAJfQ0KKwkvKioNCisJICogaHR0cHM6Ly9idWdzLmVjbGlwc2Uub3JnL2J1Z3Mvc2hvd19i
dWcuY2dpP2lkPTM0NzM5Ng0KKwkgKi8NCisJcHVibGljIHZvaWQgdGVzdDA3MjMoKSB7DQorCQlB
U1RQYXJzZXIgcGFyc2VyID0gQVNUUGFyc2VyLm5ld1BhcnNlcihBU1QuSkxTNCk7DQorCQlwYXJz
ZXIuc2V0S2luZCAoQVNUUGFyc2VyLktfU1RBVEVNRU5UUyk7DQorCQlTdHJpbmcgc3JjID0gImlu
dCBqO1xuZm9yIHt9O1xuaj0xMDAwOyI7DQorCQljaGFyW10gc291cmNlID0gc3JjLnRvQ2hhckFy
cmF5KCk7DQorCQlwYXJzZXIuc2V0U3RhdGVtZW50c1JlY292ZXJ5KHRydWUpOw0KKwkJcGFyc2Vy
LnNldFNvdXJjZShzb3VyY2UpOw0KKwkJQVNUTm9kZSByZXN1bHQgPSBwYXJzZXIuY3JlYXRlQVNU
IChudWxsKTsNCisJCWFzc2VydE5vdE51bGwoIm5vIHJlc3VsdCIsIHJlc3VsdCk7DQorCQlhc3Nl
cnRFcXVhbHMoIldyb25nIHR5cGUiLCBBU1ROb2RlLkJMT0NLLCByZXN1bHQuZ2V0Tm9kZVR5cGUo
KSk7DQorCQlCbG9jayBibG9jayA9IChCbG9jaykgcmVzdWx0Ow0KKwkJTGlzdCBzdGF0ZW1lbnRz
ID0gYmxvY2suc3RhdGVtZW50cygpOw0KKwkJYXNzZXJ0Tm90TnVsbCgiTm8gc3RhdGVtZW50cyIs
IHN0YXRlbWVudHMpOw0KKwkJYXNzZXJ0RXF1YWxzKCJXcm9uZyBzaXplIiwgMywgc3RhdGVtZW50
cy5zaXplKCkpOw0KKwkJYXNzZXJ0RmFsc2UoaXNSZWNvdmVyZWQoKEFTVE5vZGUpIHN0YXRlbWVu
dHMuZ2V0KDApKSk7DQorCQlhc3NlcnRGYWxzZShpc1JlY292ZXJlZCgoQVNUTm9kZSkgc3RhdGVt
ZW50cy5nZXQoMSkpKTsNCisJCWFzc2VydEZhbHNlKGlzUmVjb3ZlcmVkKChBU1ROb2RlKSBzdGF0
ZW1lbnRzLmdldCgyKSkpOw0KKwl9DQorDQorCS8qKg0KKwkgKiBodHRwczovL2J1Z3MuZWNsaXBz
ZS5vcmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9MzQ3Mzk2DQorCSAqLw0KKwlwdWJsaWMgdm9pZCB0
ZXN0MDcyNCgpIHsNCisJCUFTVFBhcnNlciBwYXJzZXIgPSBBU1RQYXJzZXIubmV3UGFyc2VyKEFT
VC5KTFM0KTsNCisJCXBhcnNlci5zZXRLaW5kIChBU1RQYXJzZXIuS19DT01QSUxBVElPTl9VTklU
KTsNCisJCVN0cmluZyBzcmMgPSAicHVibGljIGNsYXNzIFggeyB2b2lkIGZvbygpIHtpbnQgajtc
bmZvciB7fTtcbmo9MTAwMDt9fSI7DQorCQljaGFyW10gc291cmNlID0gc3JjLnRvQ2hhckFycmF5
KCk7DQorCQlwYXJzZXIuc2V0U3RhdGVtZW50c1JlY292ZXJ5KHRydWUpOw0KKwkJcGFyc2VyLnNl
dFNvdXJjZShzb3VyY2UpOw0KKwkJQVNUTm9kZSByZXN1bHQgPSBwYXJzZXIuY3JlYXRlQVNUIChu
dWxsKTsNCisJCWFzc2VydE5vdE51bGwoIm5vIHJlc3VsdCIsIHJlc3VsdCk7DQorCQlhc3NlcnRF
cXVhbHMoIldyb25nIHR5cGUiLCBBU1ROb2RlLkNPTVBJTEFUSU9OX1VOSVQsIHJlc3VsdC5nZXRO
b2RlVHlwZSgpKTsNCisJCUJsb2NrIGJsb2NrID0gKChNZXRob2REZWNsYXJhdGlvbikgZ2V0QVNU
Tm9kZSgoQ29tcGlsYXRpb25Vbml0KSByZXN1bHQsIDAsIDApKS5nZXRCb2R5KCk7DQorCQlMaXN0
IHN0YXRlbWVudHMgPSBibG9jay5zdGF0ZW1lbnRzKCk7DQorCQlhc3NlcnROb3ROdWxsKCJObyBz
dGF0ZW1lbnRzIiwgc3RhdGVtZW50cyk7DQorCQlhc3NlcnRFcXVhbHMoIldyb25nIHNpemUiLCAz
LCBzdGF0ZW1lbnRzLnNpemUoKSk7DQorCQlhc3NlcnRGYWxzZShpc1JlY292ZXJlZCgoQVNUTm9k
ZSkgc3RhdGVtZW50cy5nZXQoMCkpKTsNCisJCWFzc2VydEZhbHNlKGlzUmVjb3ZlcmVkKChBU1RO
b2RlKSBzdGF0ZW1lbnRzLmdldCgxKSkpOw0KKwkJYXNzZXJ0RmFsc2UoaXNSZWNvdmVyZWQoKEFT
VE5vZGUpIHN0YXRlbWVudHMuZ2V0KDIpKSk7DQorCX0NCiB9DQpcIE5vIG5ld2xpbmUgYXQgZW5k
IG9mIGZpbGUNCg==
</data>

          </attachment>
      

    </bug>

</bugzilla>