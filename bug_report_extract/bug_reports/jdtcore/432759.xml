<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>432759</bug_id>
          
          <creation_ts>2014-04-14 12:41:00 -0400</creation_ts>
          <short_desc>[1.8][compiler] Some differences between Javac and ECJ regarding wildcards and static methods</short_desc>
          <delta_ts>2014-10-28 04:39:53 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 8</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>https://bugs.eclipse.org/bugs/show_bug.cgi?id=432605</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M3</target_milestone>
          <dependson>434483</dependson>
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Timo Kinnunen">timo.kinnunen</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      <flag name="review"
          id="63543"
          type_id="1"
          status="?"
          setter="srikanth_sankaran"
          requestee="stephan.herrmann"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2388885</commentid>
    <comment_count>0</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-04-14 12:41:22 -0400</bug_when>
    <thetext>Please see the summary within the source code for differences and agreements between the compilers. I tried asking in lambda-dev about what the ground truth should be but didn&apos;t really get any answers, so these are the those examples with some additional cleanup. Personally, I don&apos;t think any one of these should be an error, but that&apos;s not here or now.

Tested with the ECJ from latest JDT Core built from HEAD today, inside Eclipse IDE, and javac from java.runtime.version=1.8.0-b132 running on java.vm.version=25.0-b70 launched from Maven with the following configuration:
				&lt;configuration&gt;
					&lt;source&gt;1.8&lt;/source&gt;
					&lt;target&gt;1.8&lt;/target&gt;
					&lt;verbose&gt;false&lt;/verbose&gt;
					&lt;forceJavacCompilerUse&gt;true&lt;/forceJavacCompilerUse&gt;
					&lt;fork&gt;true&lt;/fork&gt;
					&lt;debuglevel&gt;lines,vars,source&lt;/debuglevel&gt;
					&lt;showDeprecation&gt;true&lt;/showDeprecation&gt;
					&lt;showWarnings&gt;true&lt;/showWarnings&gt;
					&lt;compilerArgs&gt;
						&lt;arg&gt;-version&lt;/arg&gt;
						&lt;arg&gt;-Xlint:all&lt;/arg&gt;
						&lt;arg&gt;-Xdiags:verbose&lt;/arg&gt;
						&lt;arg&gt;-Xstdout&lt;/arg&gt;
						&lt;arg&gt;C:\Users\Timo\workspaceI\Java8Tests2\libfilename.txt&lt;/arg&gt;
					&lt;/compilerArgs&gt;
				&lt;/configuration&gt;

The source code:

package differences;

import java.util.function.BinaryOperator;
import java.util.function.Consumer;

/*Q*/
@FunctionalInterface interface Subsumer&lt;T&gt; {	void accept(T t);
  default                                 Subsumer&lt;T&gt; andThe1(                  Subsumer&lt;? super T&gt; afterT) { return (T t) -&gt; {      accept(t); afterT.accept(t); }; }
  default                                 Subsumer&lt;T&gt; andThe2(Subsumer&lt;T&gt; this, Subsumer&lt;? super T&gt; afterT) { return (T t) -&gt; { this.accept(t); afterT.accept(t); }; }
  static &lt;U&gt;                              Subsumer&lt;U&gt; andThe3(Subsumer&lt;U&gt; tihs, Subsumer&lt;? super U&gt; afterU) { return (U u) -&gt; { tihs.accept(u); afterU.accept(u); }; }
  static &lt;S extends ISSUPER_S, ISSUPER_S&gt; Subsumer&lt;S&gt; andThe4(Subsumer&lt;S&gt; tihs, Subsumer&lt;ISSUPER_S&gt; afterS) { return (S s) -&gt; { tihs.accept(s); afterS.accept(s); }; }
}
public class JavacECJDiffer {
	static &lt;T extends ISSUPER_T, ISSUPER_T&gt; void method() {
		BinaryOperator&lt;Consumer&lt;? super T&gt;&gt; attempt_X_0 = Consumer::andThen;
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_1 = Subsumer::andThe1;
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_2 = Subsumer::andThe2;
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_3 = Subsumer::andThe3;
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_4 = Subsumer::andThe4;
		BinaryOperator&lt;Consumer&lt;ISSUPER_T&gt;&gt; attempt_n_0 = Consumer::andThen;
		BinaryOperator&lt;Subsumer&lt;ISSUPER_T&gt;&gt; attempt_n_1 = Subsumer::andThe1;
		BinaryOperator&lt;Subsumer&lt;ISSUPER_T&gt;&gt; attempt_n_2 = Subsumer::andThe2;
		BinaryOperator&lt;Subsumer&lt;ISSUPER_T&gt;&gt; attempt_n_3 = Subsumer::andThe3;
		BinaryOperator&lt;Subsumer&lt;ISSUPER_T&gt;&gt; attempt_n_4 = Subsumer::andThe4;
		// Summary:
		// ECJ error #1, javac no error
		// ECJ error #2, javac no error
		// ECJ error #3, javac no error
		// ECJ error #4, javac error #1
		// ECJ error #5, javac error #2
		// ECJ no error, javac no error
		// ECJ no error, javac no error
		// ECJ no error, javac no error
		// ECJ no error, javac no error
		// ECJ no error, javac no error
	}

/*
ECJ errors:
1: The type Consumer does not define andThen(Consumer&lt;? super T&gt;, Consumer&lt;? super T&gt;) that is applicable here
2: The type Subsumer does not define andThe1(Subsumer&lt;? super T&gt;, Subsumer&lt;? super T&gt;) that is applicable here
3: The type Subsumer does not define andThe2(Subsumer&lt;? super T&gt;, Subsumer&lt;? super T&gt;) that is applicable here
4: The type Subsumer does not define andThe3(Subsumer&lt;? super T&gt;, Subsumer&lt;? super T&gt;) that is applicable here
5: The type Subsumer does not define andThe4(Subsumer&lt;? super T&gt;, Subsumer&lt;? super T&gt;) that is applicable here

javac errors:
1: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:18: error: incompatible types: invalid method reference
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_3 = Subsumer::andThe3;
		                                                  ^
    method andThe3 in interface Subsumer&lt;T#2&gt; cannot be applied to given types
      required: Subsumer&lt;U&gt;,Subsumer&lt;? super U&gt;
      found: Subsumer&lt;? super T#1&gt;,Subsumer&lt;? super T#1&gt;
      reason: inference variable U has incompatible bounds
        equality constraints: CAP#1
        upper bounds: T#1,Object
  where U,T#1,ISSUPER_T,T#2 are type-variables:
    U extends Object declared in method &lt;U&gt;andThe3(Subsumer&lt;U&gt;,Subsumer&lt;? super U&gt;)
    T#1 extends ISSUPER_T declared in method &lt;T#1,ISSUPER_T&gt;method()
    ISSUPER_T extends Object declared in method &lt;T#1,ISSUPER_T&gt;method()
    T#2 extends Object declared in interface Subsumer
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object super: T#1 from capture of ? super T#1
2: C:\Users\Timo\workspaceI\Java8Tests2\src\differences\JavacECJDiffer.java:19: error: incompatible types: invalid method reference
		BinaryOperator&lt;Subsumer&lt;? super T&gt;&gt; attempt_X_4 = Subsumer::andThe4;
		                                                  ^
    method andThe4 in interface Subsumer&lt;T#2&gt; cannot be applied to given types
      required: Subsumer&lt;S&gt;,Subsumer&lt;ISSUPER_S&gt;
      found: Subsumer&lt;? super T#1&gt;,Subsumer&lt;? super T#1&gt;
      reason: inference variable ISSUPER_S has incompatible bounds
        equality constraints: CAP#1
        lower bounds: S,CAP#2
  where S,ISSUPER_S,T#1,ISSUPER_T,T#2 are type-variables:
    S extends ISSUPER_S declared in method &lt;S,ISSUPER_S&gt;andThe4(Subsumer&lt;S&gt;,Subsumer&lt;ISSUPER_S&gt;)
    ISSUPER_S extends Object declared in method &lt;S,ISSUPER_S&gt;andThe4(Subsumer&lt;S&gt;,Subsumer&lt;ISSUPER_S&gt;)
    T#1 extends ISSUPER_T declared in method &lt;T#1,ISSUPER_T&gt;method()
    ISSUPER_T extends Object declared in method &lt;T#1,ISSUPER_T&gt;method()
    T#2 extends Object declared in interface Subsumer
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object super: T#1 from capture of ? super T#1
    CAP#2 extends Object super: T#1 from capture of ? super T#1

*/ /*E*/}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2389028</commentid>
    <comment_count>1</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-04-15 01:44:47 -0400</bug_when>
    <thetext>It&apos;s easy to see where the bug in the specification of inference is, assuming javac&apos;s 2 errors are working as specified. At the point where it says:
    method andThe3 in interface Subsumer&lt;T#2&gt; cannot be applied to given types
      required: Subsumer&lt;U&gt;,Subsumer&lt;? super U&gt;
and:
    method andThe4 in interface Subsumer&lt;T#2&gt; cannot be applied to given types
      required: Subsumer&lt;S&gt;,Subsumer&lt;ISSUPER_S&gt;
      
It should be asking:
    method andThe3 in interface Subsumer&lt;T#2&gt; cannot be applied to given types?
      required: Subsumer&lt;U&gt;,Subsumer&lt;? super U&gt;
      or required: Subsumer&lt;U&gt;,Subsumer&lt;U&gt;
and:
    method andThe4 in interface Subsumer&lt;T#2&gt; cannot be applied to given types?
      required: Subsumer&lt;S&gt;,Subsumer&lt;ISSUPER_S&gt;
      or required: Subsumer&lt;ISSUPER_S&gt;,Subsumer&lt;ISSUPER_S&gt;

But this is still not here or now. Unless that&apos;s what javac is allowing when there&apos;s a sub-type relationship between receiver&apos;s and another parameter&apos;s type variables.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2406006</commentid>
    <comment_count>2</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-05-22 22:51:31 -0400</bug_when>
    <thetext>With not much time left in Luna, we will handle this in 4.5 or 4.4.1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2434311</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-07-31 12:25:19 -0400</bug_when>
    <thetext>Seeing all the method reference I believe I first need a better grip on bug 434483 before I&apos;m ready to address this bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2445823</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-08-31 09:13:03 -0400</bug_when>
    <thetext>Status after fixing bug 434483 and bug 441734:

ECJ still reports the same 5 errors.


Let&apos;s pick attempt_X_0 as a sample. We report:

The type Consumer does not define andThen(Consumer&lt;? super T&gt;, Consumer&lt;? super T&gt;) that is applicable here

We are trying to infer as a function type that takes two arguments of the same type (for BinaryOperator).
Instead we get a receiver-less method reference that takes two different arguments:
- Consumer&lt;T&gt; (the receiver)
- Consumer&lt;? super T&gt; (the real argument)

My guess is that this difference causes inference to fail. Not sure if there is a rule that could lead to a valid inference solution ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2451478</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-14 23:29:59 -0400</bug_when>
    <thetext>This looks involved and not suitable for milestone week of M2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454521</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-20 23:47:31 -0400</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #0)
&gt; Please see the summary within the source code for differences and agreements
&gt; between the compilers. I tried asking in lambda-dev about what the ground
&gt; truth should be but didn&apos;t really get any answers, so these are the those
&gt; examples with some additional cleanup. Personally, I don&apos;t think any one of
&gt; these should be an error, but that&apos;s not here or now.

Timo, could you double check the assertion that &quot;I don&apos;t think any one of
these should be an error&quot; - I have an experimental fix that compiles ALL of
these - I will also verify case by case, but another pair of eyes verifying
it always welcome.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454523</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-21 00:00:31 -0400</bug_when>
    <thetext>The basic problems at least in some of the cases appears to be that there is a 
&quot;fan out&quot; of the wild card type argument through type parameterization
substitutions and wildcard captures post the fan out will result in incompatible
types. My experimental fix is extra-constitutional in nature in that the relevant
section of JLS on computing the function type of the functional interface does not
explicitly call for what I am experimenting with</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454538</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-21 01:42:30 -0400</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #7)
&gt; My experimental fix is extra-constitutional in nature in that the
&gt; relevant
&gt; section of JLS on computing the function type of the functional interface
&gt; does not
&gt; explicitly call for what I am experimenting with

Not quite. I interpret the following passage in 15.13.1: 

&quot; ... the method reference is treated as if it were an invocation
with argument expressions of types P1, ..., Pn;&quot;

as requiring captures - as &quot;argument expressions&quot; necessarily involve wildcard
captures.

The second part of the fix deal with capture ahead of substitutions to ensure
that type identity is not lost. The type Consumer&lt;? super T&gt; gets fanned out
and becomes the type of multiple arguments of the functional abstract method.
How can they be different types ? 

Fix and test here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=2749db90d9b59a49ba8d955d8eddabda9be1d8ee

Note that this compiles all the cases in comment#0.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2454539</commentid>
    <comment_count>9</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-21 01:43:33 -0400</bug_when>
    <thetext>Stephan, please review when you get a moment. No hurry.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456811</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-26 13:06:10 -0400</bug_when>
    <thetext>See that with commit http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=48bf00145f70fca24101eaac33adc5d495f9e595, we not emit one error that javac
also emits. Javac emits an extra error.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2458014</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-30 10:12:28 -0400</bug_when>
    <thetext>This may be a silly question: Is there any connection between these two methods in ReferenceExpression:
- descriptorParametersAsArgumentExpressions()
- createPseudoExpressions()
?

OK, first one answers bindings, the second expects bindings and creates AST.
The second also considers a receiver argument if that is unbound.
Would that be relevant for the former, too?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463341</commentid>
    <comment_count>12</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-11 20:28:56 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #11)
&gt; This may be a silly question: Is there any connection between these two
&gt; methods in ReferenceExpression:
&gt; - descriptorParametersAsArgumentExpressions()
&gt; - createPseudoExpressions()
&gt; ?
&gt; 
&gt; OK, first one answers bindings, the second expects bindings and creates AST.
&gt; The second also considers a receiver argument if that is unbound.
&gt; Would that be relevant for the former, too?

Yes, but that already happens inside RE.resolveType where there is a capture.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2472785</commentid>
    <comment_count>13</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-10-28 04:39:53 -0400</bug_when>
    <thetext>Verified for 4.5 M3 using I20141027-2000 build</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>