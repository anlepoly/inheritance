<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>442929</bug_id>
          
          <creation_ts>2014-08-29 18:25:00 -0400</creation_ts>
          <short_desc>[1.8][compiler] ClassCastException during runtime where is no cast</short_desc>
          <delta_ts>2014-09-16 14:23:19 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS X</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M2</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Daniel Dietrich">daniel.dietrich</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>manpalat</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
    
    <cc>timo.kinnunen</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2445693</commentid>
    <comment_count>0</comment_count>
    <who name="Daniel Dietrich">daniel.dietrich</who>
    <bug_when>2014-08-29 18:25:34 -0400</bug_when>
    <thetext>/*
The following code produces a class cast exception at runtime when compiled with eclipse (targeting 1.8 - others not tested). Compiled with jdk1.8.0_20 it runs without error.
*/
class Test {

	public static void main(String[] args) {
		shouldNotThrow();
	}

	static void shouldNotThrow() {

		final String[] array = { &quot;&quot; };
		final String[] expected = { &quot;&quot; };

		// throws
		assertThat(op(array, &quot;&quot;)).isEqualTo(expected);

	}

	static &lt;T&gt; T[] op(T[] array, T element) {
		return asArray(element);
	}

	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}

	static &lt;T&gt; ObjectArrayAssert&lt;T&gt; assertThat(T actual) {
		return new ObjectArrayAssert&lt;&gt;(actual);
	}

	static class ObjectArrayAssert&lt;T&gt; {

		ObjectArrayAssert(T actual) {
		}

		void isEqualTo(T expected) {
		}
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2445695</commentid>
    <comment_count>1</comment_count>
    <who name="Daniel Dietrich">daniel.dietrich</who>
    <bug_when>2014-08-29 18:32:07 -0400</bug_when>
    <thetext>Considering my example above, there are two interesting variants:

This does run when compiled with eclipse:

	static void shouldNotThrow() {

		final String[] expected = { &quot;&quot; };

		// throws
		assertThat(op(&quot;&quot;)).isEqualTo(expected);

	}

	@SafeVarargs
	static &lt;T&gt; T[] op(T... elements) {
		return elements;
	}

This does not run when compiled with eclipse:

	static void shouldNotThrow() {

		final String[] expected = { &quot;&quot; };

		// throws
		assertThat(op(&quot;&quot;)).isEqualTo(expected);

	}

	static &lt;T&gt; T[] op(T element) {
		return asArray(element);
	}

	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2445711</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-08-29 20:28:25 -0400</bug_when>
    <thetext>Thanks Daniel, I&apos;ll take a look for 4.5 M2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2445732</commentid>
    <comment_count>3</comment_count>
    <who name="Daniel Dietrich">daniel.dietrich</who>
    <bug_when>2014-08-30 03:27:38 -0400</bug_when>
    <thetext>Great :)
Have a nice weekend!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448621</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 05:01:03 -0400</bug_when>
    <thetext>I am not sure yet there is a bug here.

As JLS 9.6.3.7 mentions, 

&quot;The SafeVarargs annotation has non-local effects because it suppresses unchecked
warnings at method invocation expressions in addition to an unchecked warning
pertaining to the declaration of the variable arity method itself&quot;

While the asArray method itself does not perform any unsafe operations and
is well behaved with respect to its variable arity parameter, applying safe
varargs annotation to this method has the non-local side effect of suppressing
the type safety warning at the call site regarding the the generic array creation
attempt.

In effect the real array is created is an array of jlO&apos;s while shouldNotThrow
attempts to cast that into a jlS [] given the inferred return type is
String [] and the erased generic method&apos;s type is Object [].

This would justify the CCE - there is indeed heap pollution and unsafe operations
in the picture.

See that the following slightly modified program triggers a CCE with javac too:

public class X {
	static void shouldNotThrow() {
		final String[] array = { &quot;&quot; };
		final String[] expected = { &quot;&quot; };
		String [] blah = op(array, &quot;&quot;);
	}
	public static void main(String[] args) {
		shouldNotThrow();
	}
	static &lt;T&gt; T[] op(T[] array, T element) {
		return asArray(element);
	}
	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}
	static &lt;T&gt; ObjectArrayAssert&lt;T&gt; assertThat(T actual) {
		return new ObjectArrayAssert&lt;&gt;(actual);
	}
	static class ObjectArrayAssert&lt;T&gt; {
		ObjectArrayAssert(T actual) {
		}
		void isEqualTo(T expected) {
		}
	}
}

I don&apos;t see why assigning the generic method&apos;s return value should trigger
a CCE while passing it to another method invocation should not.

In summary, it would appear the CCE is justified and the SafeVarargs annotation
is misplaced. 

Stephan, can you weigh in with your opinions on this ?

I don&apos;t see the nested method invocation playing any role as opposed to
assignment playing any role in whether in op()&apos;s return value should be
value cast or not - do you agree ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448625</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 05:12:54 -0400</bug_when>
    <thetext>(In reply to Daniel Dietrich from comment #1)
&gt; Considering my example above, there are two interesting variants:
&gt; 
&gt; This does run when compiled with eclipse:
&gt; 
&gt; 	static void shouldNotThrow() {
&gt; 
&gt; 		final String[] expected = { &quot;&quot; };
&gt; 
&gt; 		// throws
&gt; 		assertThat(op(&quot;&quot;)).isEqualTo(expected);
&gt; 
&gt; 	}
&gt; 
&gt; 	@SafeVarargs
&gt; 	static &lt;T&gt; T[] op(T... elements) {
&gt; 		return elements;
&gt; 	}

Basically, there is no heap pollution in the picture in this case. op() is
as safe as asArray() was in earlier example, it simply passes the array
handed to it. But the array that is created in this case is of jlS and not
jlO which is the problematic pollution case.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448630</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 05:24:10 -0400</bug_when>
    <thetext>Here is another slightly modified program that throws a CCE with javac:

public class X {
	static String [] shouldNotThrow() {
		final String[] array = { &quot;&quot; };
		return op(array, &quot;&quot;);
	}
	public static void main(String[] args) {
		shouldNotThrow();
	}
	static &lt;T&gt; T[] op(T[] array, T element) {
		return asArray(element);
	}
	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448645</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 06:05:26 -0400</bug_when>
    <thetext>Here is another variant that involves nested method invocations that produces a
CCE with javac:

// --
public class X {

	public static void main(String[] args) {
		shouldNotThrow();
	}

	static void shouldNotThrow() {

		final String[] array = { &quot;&quot; };
		final String[] expected = { &quot;&quot; };

		// throws
		assertThat(array == expected ? array : op(array, &quot;&quot;)).isEqualTo(expected);

	}

	static &lt;T&gt; T[] op(T[] array, T element) {
		return asArray(element);
	}

	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}

	static &lt;T&gt; ObjectArrayAssert&lt;T&gt; assertThat(T actual) {
		return new ObjectArrayAssert&lt;&gt;(actual);
	}

	static class ObjectArrayAssert&lt;T&gt; {

		ObjectArrayAssert(T actual) {
		}

		void isEqualTo(T expected) {
		}
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448658</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 06:34:16 -0400</bug_when>
    <thetext>One more case that produces CCE with javac:

public class X {

	public static void main(String[] args) {
		shouldNotThrow();
	}

	static void shouldNotThrow() {
		final String[] array = { &quot;&quot; };
		assertThat(op(array, &quot;&quot;));
	}

	static &lt;T&gt; T[] op(T[] array, T element) {
		return asArray(element);
	}

	@SafeVarargs
	static &lt;T&gt; T[] asArray(T... elements) {
		return elements;
	}

	static void assertThat(String [] actual) {
	}
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448934</commentid>
    <comment_count>9</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-09-08 15:23:21 -0400</bug_when>
    <thetext>These last examples indirectly demonstrate that methods which create generic arrays internally and then let those arrays escape from the generic type&apos;s scope are unusable for their callers. To put that more clearly, here&apos;s an example which does the same thing explicitly without varargs:

public class Test {

	public static void main(String[] args) {
		
		// both ecj and javac do not throw
		Test.&lt;String&gt; newArray();
		
		// ecj throws, javac does not
		assertNothing(Test.&lt;String&gt; newArray());
		
		// both ecj and javac throw
		String[] hopeless = newArray();
	}

	static &lt;T&gt; void assertNothing(T actual) { /* nada */ }

	static &lt;T&gt; T[] newArray() {
		@SuppressWarnings(&quot;unchecked&quot;) 
		T[] array = (T[]) new Object[0];
		return array;
	}
}

Calling newArray() should be useless because without the generic type the result shouldn&apos;t be assignable to any other array than an Object[]. It&apos;s interesting that javac doesn&apos;t balk at passing the array between generic methods. 

Expressed like this this feels to me like a missed type check in javac.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2448994</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-08 20:47:44 -0400</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #9)
&gt; These last examples indirectly demonstrate that methods which create generic
&gt; arrays internally and then let those arrays escape from the generic type&apos;s
&gt; scope are unusable for their callers.

Thanks Timo. On account of such escape asArray()should be deemed unsafe
even it appears to merely pass back its parameter.

I released a regression test codifying the current behavior here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=624a3b161667d6e60131508fd9a3c0a4477c8b9d.

Daniel, you may want to report a code generation problem with javac skipping
a checkcast instruction.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2449132</commentid>
    <comment_count>11</comment_count>
    <who name="Daniel Dietrich">daniel.dietrich</who>
    <bug_when>2014-09-09 05:52:34 -0400</bug_when>
    <thetext>Thank all of you for your engagement and ongoing tests! As a nice side-effect this grants me interesting insight into Java specifics and corner cases. I will report a javac problem.

- Daniel

&gt; Daniel, you may want to report a code generation problem with javac skipping
a checkcast instruction.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2449504</commentid>
    <comment_count>12</comment_count>
    <who name="Daniel Dietrich">daniel.dietrich</who>
    <bug_when>2014-09-09 17:23:00 -0400</bug_when>
    <thetext>I filed a bug at http://bugreport.java.com, which is noew evaluated with the Review ID JI-9014960. If it is determined as a defect, it will be listed on bugs.java.com.

In this case I will post the link to the bug here...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2452696</commentid>
    <comment_count>13</comment_count>
    <who name="Manoj Palat Away Until May 11 2015">manpalat</who>
    <bug_when>2014-09-16 14:23:19 -0400</bug_when>
    <thetext>Verified as Invalid for Eclipse Mars 4.5 M2 Build id: I20140915-2000
[conclusion as per comment 4]</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>