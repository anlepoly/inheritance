<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>445099</bug_id>
          
          <creation_ts>2014-09-25 09:17:00 -0400</creation_ts>
          <short_desc>[1.8][compiler][null] NTAT.testNullTypeInference3c failure needs investigation.</short_desc>
          <delta_ts>2014-10-29 07:39:18 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.5</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M3</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>shankhba</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2456283</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-25 09:17:40 -0400</bug_when>
    <thetext>The commit made for https://bugs.eclipse.org/bugs/show_bug.cgi?id=442245
breaks this test, don&apos;t know why. I wonder if it may be have worked by
relying on incorporation having run a bit more earlier than absolutely needed.
Having said that the prior incorporatedBounds.contains mechanism to avoid
reincorporation and the present generational incorporation should really be
equivalent. Long story short - needs investigation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456285</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-25 09:20:17 -0400</bug_when>
    <thetext>I&apos;ll investigate. If appropriate, will pass to Stephan.

(In reply to Srikanth Sankaran from comment #0)
&gt; I wonder if it may be have worked by
&gt; relying on incorporation having run a bit more earlier than absolutely
&gt; needed.

That sentence is muddled. I meant &quot;in earlier versions incorporation chugged
along a bit longer than absolutely needed&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456945</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-27 12:13:39 -0400</bug_when>
    <thetext>What is the nature of failure? Different null analysis or different result of type inference itself?
I&apos;m asking because null type inference is &quot;best effort&quot; by nature. Inferring more or less null information _might_ just be acceptable.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2463642</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-13 04:32:54 -0400</bug_when>
    <thetext>Hi Stephan, I would like to trade this one for the ones I grabbed. TIA.
Please adjust the target suitably.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2465074</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-14 22:09:45 -0400</bug_when>
    <thetext>If I read https://bugs.eclipse.org/bugs/show_bug.cgi?id=446434#c0 correctly,
the new messages for this test may be what is desired ? Instead of
reporting contradiction, we report null type safety/mismatch messages.

The new messages themselves look reasonable. Perhaps this is just a question
of remastering the test ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2470133</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-22 16:40:55 -0400</bug_when>
    <thetext>Observation #1: it&apos;s indeed http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=c98606727e89fdf50e483c7870bb4651b90d6014 (&quot;First batch of changes for Bug 442245&quot;) that changes the result of testNullTypeInference3c.

Observation #2: among several changes in output, the relevant is: we go from reporting inference of contradictory null annotations, to reporting a mismatch at argument &apos;f&apos;. The additional unchecked-warnings just didn&apos;t surface previously, because the contradiction-error was reported during resolve and set ignoreFurtherInvestigation thus blocking flow analysis from reporting the unchecked things.

I&apos;m still curious how that code change succeeded to trigger this behaviour change (which indeed is good :) ) ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2470167</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-22 17:40:40 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #5)
&gt; I&apos;m still curious how that code change succeeded to trigger this behaviour
&gt; change (which indeed is good :) ) ...

I spoke too soon: the change is not really good, nor was the previous solution fully satisfactory:

In both cases behaviour is order-dependent. If we create two bounds, say
   I#0 = Object
   I#0 = @NonNull Object

The old implementation would simply overwrite the first instantiation with the right type from each new SAME bound found for I#0. Last save wins.

The new implementation does the opposite: it completely ignores the second bound because it&apos;s (correctly) recognized as equal to an existing bound.


Any order-dependent behaviour is bad, though.


I believe the fact that we see the @NonNull on bound.right and not just as a bit in nullHints, results from the annotation on the type parameter declaration itself. In this location type annotations are indeed binding, a type that has a different null annotation than the type parameter declaration is not a valid instantiation (when considering null annotations). 
Hence, a contradiction may be the best thing to report, actually, because inference wasn&apos;t free to ignore some &quot;null hints&quot;, but was asked to find a solution that satisfies this additional constraint - and couldn&apos;t.

I will try to come up with a solution that reliably propagates null annotations on bound.right even if the bound-minus-type-annotations finds a previously incorporated duplicate.

(this makes for a great bonus exercise in my talk next week, btw :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471245</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-24 09:23:26 -0400</bug_when>
    <thetext>Main fix is indeed to remaster the test. Reporting &quot;Null type mismatch&quot; is just fine.

Behind the scenes I&apos;m including two fixes to ensure we are not dropping necessary information:

- BoundSet.addBound(), when detecting duplication against a mostRecentBound,
  when doing null analysis: still extract the null information from the new
  bound (tolerating any contradiction that might result from merging).

- ThreeSets.setInstantiation(): ensure that null annotations on the type
  parameter (which are copied into the InferenceVariable) will never be
  dropped. This ensures that we will never infer a type, whose nullness would
  violate an immediate constraint on the type parameter.

Additionally, I should validate whether nullness on a type parameter&apos;s type bound could still be violated by an inferred solution. 

We have one disabled check inside TypeVariable.boundCheck(), that would detect this, but at that point I saw no easy way, how this could be turned into proper error reporting, without being prematurely triggered during overload resolution.

Easier than using boundCheck() we could let ThreeSets.setInstantiation() look even into type bounds, to ensure compatible nullness on the solution.


Released for 4.5 M3 via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=3256aef43e2296affdbf86e21f8cafdaa866161a</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2471251</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-10-24 09:27:27 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #7)
&gt; Additionally, I should validate whether nullness on a type parameter&apos;s type
&gt; bound could still be violated by an inferred solution. 
&gt; 
&gt; We have one disabled check inside TypeVariable.boundCheck(), that would
&gt; detect this, but at that point I saw no easy way, how this could be turned
&gt; into proper error reporting, without being prematurely triggered during
&gt; overload resolution.
&gt; 
&gt; Easier than using boundCheck() we could let ThreeSets.setInstantiation()
&gt; look even into type bounds, to ensure compatible nullness on the solution.

Follow-up filed as bug 448709</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2473487</commentid>
    <comment_count>9</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-10-29 07:39:18 -0400</bug_when>
    <thetext>Verified for 4.5 M3 using  I20141027-2000 build.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>