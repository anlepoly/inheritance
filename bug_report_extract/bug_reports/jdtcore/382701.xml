<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>382701</bug_id>
          
          <creation_ts>2012-06-15 03:32:00 -0400</creation_ts>
          <short_desc>[1.8][compiler] Implement semantic analysis of Lambda expressions &amp; Reference expressions.</short_desc>
          <delta_ts>2014-02-01 14:43:03 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>3.8</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          <dependson>382702</dependson>
    
    <dependson>382713</dependson>
    
    <dependson>382721</dependson>
    
    <dependson>382727</dependson>
    
    <dependson>384595</dependson>
    
    <dependson>384600</dependson>
    
    <dependson>384687</dependson>
    
    <dependson>384750</dependson>
    
    <dependson>398267</dependson>
    
    <dependson>398269</dependson>
    
    <dependson>398734</dependson>
    
    <dependson>399224</dependson>
    
    <dependson>399534</dependson>
    
    <dependson>399537</dependson>
    
    <dependson>399778</dependson>
    
    <dependson>399979</dependson>
    
    <dependson>400159</dependson>
    
    <dependson>400556</dependson>
    
    <dependson>400745</dependson>
    
    <dependson>400872</dependson>
          <blocked>380188</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>amj87.iitr</cc>
    
    <cc>daniel_heidinga</cc>
    
    <cc>daniel_megert</cc>
    
    <cc>jesper</cc>
    
    <cc>Mike_Wilson</cc>
    
    <cc>pradeepb</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2124716</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-06-15 03:32:01 -0400</bug_when>
    <thetext>This ER will serve as the top level umbrella entry to track semantic
analysis support for Lambda expressions &amp; Method and constructor references.
(https://bugs.eclipse.org/bugs/show_bug.cgi?id=380501 will be used to
track support for default methods.)

Separate bugs will be spawned for unit tasks in this project and linked
to this entry.

When resolved, we would be able to reject every semantically illegal program
with a suitable/appropriate diagnostic. The further treatment of well
defined programs will be the subject matter of ERs that will be created
later.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2134416</commentid>
    <comment_count>1</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-07-09 07:12:14 -0400</bug_when>
    <thetext>Just adding a small test case from bug 384593

public class Action&lt;T&gt; {
    public void foo() {
    int i11 = (Integer) (final int x, MissingType&lt;String, Integer&gt; m) -&gt; x;
    }
}
Should be rejected because of MissingType</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2138268</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-07-17 19:27:10 -0400</bug_when>
    <thetext>Let us use this bug just as an umbrella/master ER for semantic analysis
and post all comments to individual bugs linked as as blockers of this
bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2171409</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-10-13 02:02:59 -0400</bug_when>
    <thetext>Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
is moved to here and will be addressed as a part of this work. 

(2) Decide fields of ReferenceExpression (only one of name/type/primary is
used see bug bug 380194 comment 53</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2171436</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-13 11:20:28 -0400</bug_when>
    <thetext>(In reply to comment #3)
&gt; Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
&gt; is moved to here and will be addressed as a part of this work. 
&gt; 
&gt; (2) Decide fields of ReferenceExpression (only one of name/type/primary is
&gt; used see bug bug 380194 comment 53

Update: the &apos;name&apos; field (and the constructors taking a NameReference) appear to be obsolete already in current BETA_JAVA8. 
Remains the duality between TypeReference and Expression, which indeed seems to be inherent in a way. 
Is it naive asking about splitting this class into InstanceBasedReferenceExpression and TypeBasedReferenceExpression.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2171483</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-10-13 19:24:54 -0400</bug_when>
    <thetext>(In reply to comment #4)
&gt; (In reply to comment #3)
&gt; &gt; Concern #2 from https://bugs.eclipse.org/bugs/show_bug.cgi?id=385041#c7
&gt; &gt; is moved to here and will be addressed as a part of this work. 
&gt; &gt; 
&gt; &gt; (2) Decide fields of ReferenceExpression (only one of name/type/primary is
&gt; &gt; used see bug bug 380194 comment 53
&gt; 
&gt; Update: the &apos;name&apos; field (and the constructors taking a NameReference)
&gt; appear to be obsolete already in current BETA_JAVA8. 

Certainly the constructor is obsolete. But the field is not really.
consumeReferenceExpressionTypeForm has a TODO comment &quot;Handle ambiguity 
with NameReference.&quot;

&gt; Remains the duality between TypeReference and Expression, which indeed seems
&gt; to be inherent in a way. 
&gt; Is it naive asking about splitting this class into
&gt; InstanceBasedReferenceExpression and TypeBasedReferenceExpression.

When Name gets resurrected, we will have three + 1 base class to factor in
common behavior. 

I am not opposed to 4 classes - let&apos;s revisit this when we are at the bridge
to cross.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2203584</commentid>
    <comment_count>6</comment_count>
      <attachid>225695</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-16 07:29:03 -0500</bug_when>
    <thetext>Created attachment 225695
First attempt at type analysis for lambdas

Simple first attempt at a patch, which implements a scope for lambdas (extends from MethodScope as the lambda behaves quite a bit like a method)

TODO:
 - The detection of functional interfaces is a simple first attempt.
 - error messages should be better
 - this only covers lambdas, I haven&apos;t worked on method and constructor references
 - no code generation yet, obviously

(Note: The patch is over 250 lines long but that&apos;s only really because of the diff markers and copyright comments. I am an Eclipse committer, but not on JDT, obviously).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2203917</commentid>
    <comment_count>7</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-16 16:19:15 -0500</bug_when>
    <thetext>I&apos;ve set up a fork on GitHub where you may view patches:

https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2203996</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-16 23:08:30 -0500</bug_when>
    <thetext>(In reply to comment #7)
&gt; I&apos;ve set up a fork on GitHub where you may view patches:
&gt; 
&gt; https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8

I am not 100% sure, but I *think* eclipse IP process requires patches
to be attached to bugzilla by contributors. In any case that is the
standard process we have followed and I would request you to attach
a patch here, just to be safe.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2204010</commentid>
    <comment_count>9</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-17 01:26:30 -0500</bug_when>
    <thetext>(In reply to comment #8)
&gt; (In reply to comment #7)
&gt; &gt; https://github.com/jespersm/eclipse.jdt.core/tree/BETA_JAVA8
&gt; 
&gt; I am not 100% sure, but I *think* eclipse IP process requires patches
&gt; to be attached to bugzilla by contributors. In any case that is the
&gt; standard process we have followed and I would request you to attach
&gt; a patch here, just to be safe.

You are correct -- and everything I&apos;ve committed into the GitHub fork has also been added as patches. I&apos;ve just set this up to track my own progress, and edit patches once Anirban starts adding stuff, in case it differs a lot.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208149</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-26 12:48:35 -0500</bug_when>
    <thetext>Has it been decided yet, where LambdaExpressions will be integrated in the AST inheritance tree? I see &quot;LambdaExpression extends FunctionalLiteral&quot; in some patches, which looks surprising to the naive reader:
- lambdas aren&apos;t literals, are they?
- lambdas share a lot with methods and I&apos;ve already seen some copy/paste from AbstractMethodDeclaration to LambdaExpression.

My naive p.o.v. soon breaks because a lambda must be subtype of Expression, so we can&apos;t extend AbstractMethodDeclaration here. Is that your reasoning?

Two options come to mind:
- make LambdaExpression a very thin wrapper with a reference to a - say - LambdaMethodDeclaration, or
- push some reusable code from AbstractMethodDeclaration up to ASTNode.

Sorry, if I&apos;m fighting a non-issue. If alternatives have already been discussed please give a me a pointer so I can catch up. Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208227</commentid>
    <comment_count>11</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-27 00:59:30 -0500</bug_when>
    <thetext>(In reply to comment #10)
&gt; Has it been decided yet, where LambdaExpressions will be integrated in the
&gt; AST inheritance tree? I see &quot;LambdaExpression extends FunctionalLiteral&quot; in
&gt; some patches, which looks surprising to the naive reader:
&gt; - lambdas aren&apos;t literals, are they?
&gt; - lambdas share a lot with methods and I&apos;ve already seen some copy/paste
&gt; from AbstractMethodDeclaration to LambdaExpression.
&gt; 
&gt; My naive p.o.v. soon breaks because a lambda must be subtype of Expression,
&gt; so we can&apos;t extend AbstractMethodDeclaration here. Is that your reasoning?

I originally hooked up LambdaExpression as a subtype of NullLiteral as a way
of silencing the rest of the phases of compilers from emitting various errors.
As null is always assignable to any reference, it was an effective way to short
circuit downstream components.

As you point out, LambdaExpression and ReferenceExpression must be derived 
from Expression.

I think any continued connection to Literals is likely intended as a stop
gap measure in the same spirit as the original subtyping from NullLiteral.

&gt; Two options come to mind:
&gt; - make LambdaExpression a very thin wrapper with a reference to a - say -
&gt; LambdaMethodDeclaration, or

This is worth exploring. Though at the moment I am inclined to think we
should do it in a follow up bug. I am keen to review and release basic
infrastructure code for semantic analysis this week.

&gt; - push some reusable code from AbstractMethodDeclaration up to ASTNode.

I am not hugely worried about code duplication via copy+paste
from AMD or its subtypes. Pushing them upwards could save some duplication
at the expense of implementing behavior at a level where it is not entirely
appropriate. We could chose to duplicate code with a clear cross referencing
comment on either side.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208240</commentid>
    <comment_count>12</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-27 06:03:41 -0500</bug_when>
    <thetext>(In reply to comment #11)

&gt; As you point out, LambdaExpression and ReferenceExpression must be derived 
&gt; from Expression.

I figure that they share some common analysis (hooking up with a functional interface and using the expected type for further analyses), so I&apos;ve put them under a common base, which should be abstract. Yes, that could be considered implementation inheritance, but they share some interface too, so it&apos;s not a bad smell.

&gt; I think any continued connection to Literals is likely intended as a stop
&gt; gap measure in the same spirit as the original subtyping from NullLiteral.

Actually I was in doubt as to what constituted a literal, since neither lambdas nor references actually compute anything (yet) what are they really? But I&apos;d say that FunctionalLiteral should be renamed to FunctionalExpression and extend Expression, and so avoid Literal.

&gt; I am not hugely worried about code duplication via copy+paste
&gt; from AMD or its subtypes. Pushing them upwards could save some duplication
&gt; at the expense of implementing behavior at a level where it is not entirely
&gt; appropriate. We could chose to duplicate code with a clear cross referencing
&gt; comment on either side.

The code duplication is not so bad once you have to take care of optional parameters, different interpretation of this, synthetic parameters (once we get to generating code), and whatnot: The argument list won&apos;t look too much like a method&apos;s argument list, since it (and the throws declaration) will have to be dynamically computed (see the definition of a function descriptor in the Lambda EDR, section 9.8) from the constituent interfaces. (I&apos;m going to focus on that, next, to replace the simplistic detection introduced in bug 382702, org.eclipse.jdt.internal.compiler.ast.FunctionalLiteral.resolveFunctionalMethod(int, ProblemReporter), note the TODO)

BTW: I&apos;ve pushed all the patches to Eclipse&apos;s Gerrit instance, which makes review a bit more fun and collaborative. I&apos;ll post the links in each bug, or you can search Gerrit.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208241</commentid>
    <comment_count>13</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-27 06:05:37 -0500</bug_when>
    <thetext>View these patches in Gerrit:

https://git.eclipse.org/r/9907

https://git.eclipse.org/r/9908

https://git.eclipse.org/r/9912/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208243</commentid>
    <comment_count>14</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-27 06:23:06 -0500</bug_when>
    <thetext>Patch in Gerrit (may be easier to view patch and easier to check out from using Git)

https://git.eclipse.org/r/#/c/9912/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208275</commentid>
    <comment_count>15</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-27 09:12:36 -0500</bug_when>
    <thetext>(In reply to comment #12)

Thanks for filling in the rationale behind the current design. I just wasn&apos;t sure how much consideration went into the current solution. Your reasoning makes sense to me.

&gt; Actually I was in doubt as to what constituted a literal, since neither
&gt; lambdas nor references actually compute anything (yet) what are they really?

I&apos;d agree with calling references &quot;literals&quot; (very similar to class literals),
but to me lambdas are more of a declaration (plus a reference to it), 
we might call them anonymous method/function declarations.

&gt; BTW: I&apos;ve pushed all the patches to Eclipse&apos;s Gerrit instance, which makes
&gt; review a bit more fun and collaborative. I&apos;ll post the links in each bug, or
&gt; you can search Gerrit.

Sure, Gerrit is great for detailed nit-picking :)
OTOH I&apos;d consider the design of the AST class hierarchy a conceptual thing
for which bugzilla is still a good place, don&apos;t you think?

(In reply to comment #11)
&gt; &gt; - push some reusable code from AbstractMethodDeclaration up to ASTNode.
&gt; 
&gt; I am not hugely worried about code duplication via copy+paste
&gt; from AMD or its subtypes. Pushing them upwards could save some duplication
&gt; at the expense of implementing behavior at a level where it is not entirely
&gt; appropriate. We could chose to duplicate code with a clear cross referencing
&gt; comment on either side.

We already have precedents of code sharing via ASTNode or Expression for otherwise unconnected sub-classes. IF we go that way we could use the opportunity for documenting the different groups of sub-classes that share a particular piece of behaviour. I personally find this easier to maintain than (cross-referenced) duplicates, but this is not a strong objection. And once we need significantly different variants, duplication with modification may actually be the smoothest of all solutions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208356</commentid>
    <comment_count>16</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-27 22:58:02 -0500</bug_when>
    <thetext>(In reply to comment #15)
&gt; (In reply to comment #12)

&gt; Sure, Gerrit is great for detailed nit-picking :)
&gt; OTOH I&apos;d consider the design of the AST class hierarchy a conceptual thing
&gt; for which bugzilla is still a good place, don&apos;t you think?

I apologize, I should I have chimed in with my preference much earlier
before Jesper spent cycles putting up things in gerrit. We had used gerrit
heavily for a month earlier and I was personally underwhelmed - I think
since I am going to be the primary reviewer for your patches, I would
personally prefer simple patches attached to bugzilla.

Later in the day, I&apos;ll post detailed comments on the initial infrastructural
work for semantic analysis.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208368</commentid>
    <comment_count>17</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-28 01:54:29 -0500</bug_when>
    <thetext>I have looked at the various patches and overall much of the work is
in the right direction, though I have various changes to suggest. A write
up such the one below should ideally have preceded the work, I apologize
for being too swamped to have come up with that.

Let us use this bug for putting in place the basic infrastructure for semantic
analysis and handle other issues in blocking leaf bugs.

Here is what I would like to see in the &quot;infrastructure&quot; work:

(1) Proper hierarchical placement of LambdaExpression and ReferenceExpression:

    As rightly pointed out in comment#12, there is commonality between
LambdaExpression and ReferenceExpression that is worth modelling in the
abstraction. We need to cut the chord with literals, except perhaps for
still returning TypeBinding.NULL from certain code paths (&quot;if needed&quot;, &quot;may be&quot;)
in LambdaExpression/ReferenceExpression.resolveType if we still need 
downstream components to be silent.

   I think the hierarchy should be:

   Expression
       FunctionalExpression
          LambdaExpression
          ReferenceExpression

From the type system point of view, a lambda expression stands for a reference:
a reference to an object that implements the single abstract method of the
target type interface. I don&apos;t think we should worry about the &quot;literal&quot;
connotation that comes from a &quot;particular&quot; implementation.

(2) Implementation of a skeleton method for TypeBinding#getSingleAbstractMethod
(returns null or a PRB) and ReferenceBinding#getSingleAbstractMethod. The 
latter could at this point return null for non-interfaces and for interfaces
could ignore inheritance, object method redefinitions etc. If no single method
could be found, this method should ideally return a ProblemReferenceBinding
with ProblemReasons set to NoSuchSingleAbstractMethod. 

I can get Anirbhan to tighten the implementation on behalf of a different bug.

(3) Hooking up stub/skeleton/placeholder/minimal implementation of
resolveType method:

(a) Check that target type is an interface and otherwise report an error.
(b) Report error if the target interface does not define a single abstract
method. (see #2 above)
(c) create suitable scope. I don&apos;t think this will be reentered (scope == null
redundant)
(d) Propagate possibly elided type of lambda paramaters.
(e) Resolve arguments.
(f) Resolve body.
(g) Possibly return TypeBinding.Null

(4) Propagation of expected target type *into* the new classes. I see that
the patch attached to the current bug does this. But a later patch hoists some
of the analysis to the contexts. I don&apos;t think we should opt for this latter
approach. There is precedence in expected type propagation from Java 7
constructs and we need to augment that as the patch attached to this
bug does.

// ---------
(Now, Java 8 defines additional contexts (method invocation ...) where the
expected type/target type plays a role. In these places we should invoke a 
new method setExpectedTypeInInvocationContext() etc which has a valid
implementation (that delegates to setExpectedType) with the base implementation
being a NOP. 

However, this can be dealt with a in a separate bug, as it involves quite
a bit of magic work in overload resolution: Unless the lambda&apos;s target type
is known, we can resolve the overloaded method and unless we can resolve the
overloaded method, we can&apos;t determine the target type of the lambda.

Also per my memory, some of the additional contexts also impact
Java7 constructs in Java8. In these cases, they should delegate to 
setExpectedType after a check of the source level. (this piece can also 
come later as it is not connected to the present topic.)

I see that we also need a new type for the lambda bodies of the form
() -&gt; 100, as the resolution of the misnamed &quot;Statement&quot; should treat
it as an implicit return statement, which won&apos;t happen automatically.
I&apos;ll raise a separate bug for this - we also need to chain the expected
type from the containing lambda.
)
// ------------

For the present implementing setExpectedType is good enough.

(5) I would withdraw the new LambdaScope class at this time. Not opposed
to this abstraction per se, but it can be deferred to a later time when
its motivation is fully clear. At the level of patch attached to this
bug all LambdaScope does is to forward the expectedResultType, which can
be otherwise achieved by making LambdaExpression implement ReferenceContext
and handlng LambdaExpressions pretty much the same way as is done for AMD.

(6) LambdaExpression should implement ReferenceContext. In the absence of
this, we would abort compilations at a coarser level than we should.

(7) Implement the traverse methods. In both ClassScope and BlockScope.
IIRC, 308 requires them in both scopes. Not sure, but it wouldn&apos;t hurt.
(See Argument#traverse)

(8) Provide implementation of ASTVisitor.visit and endVisit methods for
both the new types.

Editorial comments:

(1) Copyright update missing in LambdaExpression. Make sure to uniformly
call out your contribution with bug number in all modified files.

(2) Please get rid of the unused
org.eclipse.jdt.internal.compiler.ast.LambdaExpression.typeDeclaration

(3) Please rename org.eclipse.jdt.internal.compiler.ast.LambdaExpression.singleMethod to
singleAbstractMethod.

(4) I would cluster all the 3.9 APIs closer together where possible.
i.e newer problems can follow IllegalQualifierForExplicitThis2 (as of
this writing.)

(5) PolyExpressionInIllegalContext is too general. I would opt for
LambdaOrReferenceExpressionInIllegalContext. May be split it into two
so message text can unambiguously call out.

(6) Calling org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolveToType(BlockScope, TypeBinding) from org.eclipse.jdt.internal.compiler.ast.Argument.resolve(BlockScope) is 
problematic.

The new LocalVariableBinding created is tagged as being a non-argument,
various diagnostics would confuse arguments vs locals etc (redefineLocal()).
I would handle redeclaring/hiding/shadowing/obscuring related issues in
a different bug though. (The nesting of Method scopes could upset the
hiddenVariableDepth and could call for some massaging of code)

(see that your patch https://bugs.eclipse.org/bugs/attachment.cgi?id=225696
exhibits this problem)

(7) Argument resolution is traditionally handled NOT by deferring
to the LocalDeclaration#resolve and friends, but via org.eclipse.jdt.internal.compiler.ast.Argument.bind(MethodScope, TypeBinding, boolean). Please take a look at the caller&apos;s of this method.

(8) I can&apos;t see a use for org.eclipse.jdt.internal.compiler.ast.Argument.elidedType()

(9) We usually leave a space after the ) of the cast, so  ((LambdaScope)methodScope) should be  ((LambdaScope) methodScope)

A note on testing: We are trying to stabilize our testing against
b73/b74 JRE. There are still some failures we are trying to clean
up. Once that is declared green, you can test against the agreed
upon JRE. Your test entry point will be org.eclipse.jdt.core.tests.RunJDTCoreTests. Till then I am happy to run
all the regression tests for you as a part of the review/release process.

Every test we write, we want to confirm behavior against the reference
compiler. (b73/b74)

Please split the patches into tests vs code or even code and code as needed
at the moment. We will take up committer rights process in due course.

The suggested infrastructure can be amended as time goes and a clear need
emerges.

As these changes will impact other patches you have posted, I&apos;ll include
high level comments on them here itself using the recommended order of
review outlined by you.

(1) 381121: I don&apos;t see a test patch here ??
(2) 382727: the recommended way to disable a test is to prefix its name 
with an _. Also remember to post an updated list to bug 383608, so we don&apos;t 
lose track.
(3) 382727: &quot;Duplicate local variable x&quot; message - x is actually an argument.
Perhaps we could issue clearer new message here as a part of a separate
bug - we need to handle and test nested lambdas.
(4) 383096: Will review after infrastructure is in place and fix is massaged.
(5) 384687: Will review after infrastructure is in place and fix is massaged.
(6) 382702: We need to remove all the code around allowFunctionalInterface()
and use the propagation of the target type via setExpectedType() as mentioned
earlier.
(7) 398734: Would recommend eliminating all flow analysis from here and
handle it in a separate bug altogether at a later time.

Overall, I would say things look promising for someone starting to work
on JDT/Core anew. Thanks for your efforts.

Please a propose a patch with the suggested infrastructural changes and
I&apos;ll review and release on a priority basis.

(If needed, you can also split the work into LambdaExpression and ReferenceExpression portions)

Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2208382</commentid>
    <comment_count>18</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-28 03:11:18 -0500</bug_when>
    <thetext>(In reply to comment #17)

&gt; (2) Implementation of a skeleton method for
&gt; TypeBinding#getSingleAbstractMethod
&gt; (returns null or a PRB) and ReferenceBinding#getSingleAbstractMethod. The 
&gt; latter could at this point return null for non-interfaces and for interfaces
&gt; could ignore inheritance, object method redefinitions etc. If no single
&gt; method
&gt; could be found, this method should ideally return a ProblemReferenceBinding
&gt; with ProblemReasons set to NoSuchSingleAbstractMethod.

Correction: I meant to say ProblemMethodBinding (PMB) and not 
ProblemReferenceBinding

&gt; I can get Anirbhan to tighten the implementation on behalf of a different
&gt; bug.

See bug 399224

&gt; (3) Hooking up stub/skeleton/placeholder/minimal implementation of
&gt; resolveType method:

We can introduce as many IProblem constants as necessary so we are able
to issue a precise clearly worded message.

&gt; a bit of magic work in overload resolution: Unless the lambda&apos;s target type
&gt; is known, we can resolve the overloaded method and unless we can resolve the
&gt; overloaded method, we can&apos;t determine the target type of the lambda.

Correction: Unless the lambda&apos;s target type is known, we *can&apos;t* resolve the overloaded method ...

&gt; I see that we also need a new type for the lambda bodies of the form
&gt; () -&gt; 100, as the resolution of the misnamed &quot;Statement&quot; should treat
&gt; it as an implicit return statement, which won&apos;t happen automatically.
&gt; I&apos;ll raise a separate bug for this - we also need to chain the expected
&gt; type from the containing lambda.

Not necessary. We can check if the lambda body is a block and if not
validate the return type then and there. Likewise, we can check if the
lambda body is a lambda expression and if so chain the expected type.

&gt; (7) 398734: Would recommend eliminating all flow analysis from here and
&gt; handle it in a separate bug altogether at a later time.

i.e everything not pertinent to the title of the bug should be in a
different patch on a different bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209592</commentid>
    <comment_count>19</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-29 20:08:55 -0500</bug_when>
    <thetext>Jesper, let me know if finding time is going to be a problem this week.
The DOM/AST work for 308 is coming to completion and I can work on this
this week if needed. Since the infrastructure work will unblock other
tasks, I am keen to wrap this up soon.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209600</commentid>
    <comment_count>20</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-29 20:42:33 -0500</bug_when>
    <thetext>Srikanth - it has been a bit of a task basically unravelling all the patches are starting it one step at a time, so I&apos;m not sure I&apos;d be able to finish it till late Thursday. Perhaps it&apos;d be better if I post a patch of my current work, and you&apos;d take it from there.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209604</commentid>
    <comment_count>21</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-29 21:38:51 -0500</bug_when>
    <thetext>(In reply to comment #20)
&gt; Srikanth - it has been a bit of a task basically unravelling all the patches
&gt; are starting it one step at a time, so I&apos;m not sure I&apos;d be able to finish it
&gt; till late Thursday. Perhaps it&apos;d be better if I post a patch of my current
&gt; work, and you&apos;d take it from there.

Sounds good. Please do. We will avoid such situations in future by ensuring
that (a) you are working on well defined non-blcoker/leaf items and/or (b)
well defined projects such as flow analysis where you have made good progress
(c) reviews are prompt and patches don&apos;t pile up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209612</commentid>
    <comment_count>22</comment_count>
      <attachid>226290</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-29 22:09:55 -0500</bug_when>
    <thetext>Created attachment 226290
Patch for as far as I&apos;ve gotten (cleanly)

Srikanth - It came in just under 250 lines :-) and lots of it is copyright boilerplate, really :-|

I&apos;ve addressed point 1), 2), 3)a+b and 4) above, and haven&apos;t retrofitted the tests yet (so haven&apos;t checked the formatting of the error message or PMB).

I hope you can use this as is, I&apos;m leaving it for now -- if you check in (or attact a patch), I can continue on from there late Wednesday, if you want.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209692</commentid>
    <comment_count>23</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 04:05:18 -0500</bug_when>
    <thetext>(In reply to comment #22)
&gt; Created attachment 226290 [details]
&gt; Patch for as far as I&apos;ve gotten (cleanly)

Thanks, Here are the modifications I made. I know this is work in progress
that you have uploaded without opportunity to polish and so are not 
oversights per se.

(1) Renamed IProblem.NotAFunctionalInterface to TargetTypeNotAFunctionalInterface.
(2) In ReferenceBinding.getSingleAbstractMethod() eliminated multiple calls to
this.methods(), by capturing the value in local.
(3) instance method calls are not required to be prefixed with &quot;this.&quot;, only
instance field accesses are.
(4) Same method: We can simply pass null for arguments and PMB will transform
it into Binding.NO_PARAMETERS. We don&apos;t want to create new objects.
(5) Same method: we centralize all hardcoded constants into either TypeConstants
or into ConstantPool. I replaced &quot;function&quot;.toCharArray with TypeConstants.ANONYMOUS_METHOD. A trick to make sure internal names don&apos;t 
collide with user space names is to embed white spaces. 
(6) We should cache the PMB or the single abstract method.
(7) Fixed the error message: it was mangled.
(8) Simplified the signature of ProblemReporter#targetTypeIsNotAFunctionalInterface

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=b9ab827b0e2709263cd127badca5672535507466.

Congrats on your first commit - Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209695</commentid>
    <comment_count>24</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 04:06:12 -0500</bug_when>
    <thetext>Released some missing pieces that complement previous commit via:
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=5da340dfbdee6d0d431864522bf5ee4b7e53f3e4</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209697</commentid>
    <comment_count>25</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 04:10:38 -0500</bug_when>
    <thetext>(In reply to comment #24)
&gt; Released some missing pieces that complement previous commit via:
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA8&amp;id=5da340dfbdee6d0d431864522bf5ee4b7e53f3e4

Anirban, these two commits should completely unblock you and allow
you to proceed on bug 399224</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209728</commentid>
    <comment_count>26</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-30 05:14:14 -0500</bug_when>
    <thetext>Ouch, my patch omitted my version of FunctionalLiteral - must be an EGit PEBKAC error, I thought I&apos;d added it to the index.
Sorry &apos;bout that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209734</commentid>
    <comment_count>27</comment_count>
      <attachid>226307</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-30 05:22:32 -0500</bug_when>
    <thetext>Created attachment 226307
Test fixes for org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests

Introducing a new problem always triggers a change to this test. I&apos;m not entirely sure of the purpose...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209763</commentid>
    <comment_count>28</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 06:39:46 -0500</bug_when>
    <thetext>(In reply to comment #27)
&gt; Created attachment 226307 [details]
&gt; Test fixes for
&gt; org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests
&gt; 
&gt; Introducing a new problem always triggers a change to this test. I&apos;m not
&gt; entirely sure of the purpose...

Thanks for catching it. I have released the patch via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=e8075a0df168dcda9adff16ce27919f4df5f2cda.

To avoid such problems in future, I have added CompilerInvocationTests to
RunAllJava8Tests via:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=2565f84b1b73e40321abe403fa7b5cce7eb56119

Note on testing: 

(1) Please use b74 - all tests should pass when run as RunJDTCoreTests
(2) Smoke test can be done via RunAllJava8Tests - this finishes in under
a couple of minutes and tells if you broke some 308/335 functionality.
(3) When in doubt, run (1)
(4) Unless you are very sure run (1)
(5) Run (1) :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2209787</commentid>
    <comment_count>29</comment_count>
      <attachid>226315</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-30 07:47:07 -0500</bug_when>
    <thetext>Created attachment 226315
Patch to cut FunctionalExpression&apos;s dependency on Literal

... since lambdas and references aren&apos;t literals.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210041</commentid>
    <comment_count>30</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 13:32:29 -0500</bug_when>
    <thetext>(In reply to comment #29)
&gt; Created attachment 226315 [details]
&gt; Patch to cut FunctionalExpression&apos;s dependency on Literal
&gt; 
&gt; ... since lambdas and references aren&apos;t literals.

Thanks, released with a couple of minor changes. Expression&apos;s implementation
of reusableJSRTarget() is the right one and should not be overridden. By mistake
I also ended up deleting the javadoc on generateCode, but left it as is since
this method is a place holder.

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=7e9cb5a3c53e26b5cf1cdabebd4f0bb2f504c23d

Followed up with a bit more clean up on constructor chaining with:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=4152a87f3580e53749fa348690b4abc9a373bea9</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210219</commentid>
    <comment_count>31</comment_count>
      <attachid>226356</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-30 19:23:55 -0500</bug_when>
    <thetext>Created attachment 226356
Actual activation of the semantic analysis inside the lambda expression

This variation reuses MethodScope, implements ReferenceContext (I still need to find out what the deal is there) and performs very simple resolving.

I have left TODOs instead of actual error messages, as I need to figure out how to do this best. For this reason, the patch doesn&apos;t contain new tests, only a fix of a single test which had an unknown variable, in NegativeLambdaExpressionsTest.test009. I&apos;ve used another variable to silence the analysis, as to not confuse what&apos;s being tested.

So, to actually test the semantic validation, new tests will be submitted -- at first for the basic resolve() on the lambda body, and then more as I add error messages. I hope that approach is workable.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210235</commentid>
    <comment_count>32</comment_count>
      <attachid>226357</attachid>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-30 20:16:55 -0500</bug_when>
    <thetext>Created attachment 226357
Test case for basic semantic tests in lambdas

This test demonstrates the semantic checks which now work:
- Setting up a scope
- Resolving unknown names fails as expected.
- Resolving types of declared variables
- Resolving types of elided variables as per functional descriptor
- Checking of return expression (or lack thereof)
- Following the &apos;static&apos;-ness of the enclosing method.
- Addressing a variable from enclosing method scope (for now ignoring effectively finals)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210254</commentid>
    <comment_count>33</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-01-30 23:00:27 -0500</bug_when>
    <thetext>Thanks, the best way to progress is to work on leaf bugs and add as much of
code and tests as necessary for each bug. That way on each bug we are able 
to see what code/tests were added and verify whether all the necessary and
sufficient checks are in place. If we clump all work here, it will become a
problem.

No need to rework what has already been done, but in future let us use the 
present  bug only for adding boiler plate place holder code and relegate
any real code to leaf bug (raised afresh if needed).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210300</commentid>
    <comment_count>34</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-01-31 03:41:11 -0500</bug_when>
    <thetext>(In reply to comment #33)
&gt; Thanks, the best way to progress is to work on leaf bugs and add as much of
&gt; code and tests as necessary for each bug. That way on each bug we are able 
&gt; to see what code/tests were added and verify whether all the necessary and
&gt; sufficient checks are in place. If we clump all work here, it will become a
&gt; problem.

Right. I think the only remaining infrastructure item left from you outline in comment 17, is the traverse and ASTVisitor work -- I&apos;ll file that under a separate bug as a dependency.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210921</commentid>
    <comment_count>35</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 01:08:05 -0500</bug_when>
    <thetext>(In reply to comment #31)
&gt; Created attachment 226356 [details]
&gt; Actual activation of the semantic analysis inside the lambda expression

Thanks, I released this patch with some minor edits:

(1) (I know this is copy pasted code)
if (this.scope != null) {
			return this.scope.compilationUnitScope().referenceContext;
		}
		return null;

is better written as:

return this.scope == null ? null : this.scope.compilationUnitScope().referenceContext;

(2) cleaned up comments stating the obvious.

Commit id: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=30ba2db951e79b89a330e1209e461b1c083d6de3

I&apos;ll follow this up shortly with another commit that cleans up a bunch of
things.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210923</commentid>
    <comment_count>36</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 01:24:26 -0500</bug_when>
    <thetext>(In reply to comment #32)
&gt; Created attachment 226357 [details]
&gt; Test case for basic semantic tests in lambdas

Thanks, Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=5b5c973a8216c08a1f2946e0c5b4a77da83dac27.

I verified that JDK8b74&apos;s diagnostics are equivalent. If you didn&apos;t check
explicitly this time, please do in future so we don&apos;t inadvertently encode
incorrect/suspect behavior.

All releaseable patches from you have been reviewed and released - others
attached to different bugs will require rework anyway due to the changes
done already.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210962</commentid>
    <comment_count>37</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 03:30:07 -0500</bug_when>
    <thetext>(In reply to comment #35)

&gt; I&apos;ll follow this up shortly with another commit that cleans up a bunch of
&gt; things.

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=558c64a899c0debc518d6eb92e85f37b05902eba

(In reply to comment #34)
&gt; (In reply to comment #33)

&gt; Right. I think the only remaining infrastructure item left from you outline
&gt; in comment 17, is the traverse and ASTVisitor work -- I&apos;ll file that under a
&gt; separate bug as a dependency.

Patch above includes this change, along with a few other clean-ups.

One important implementation note: Returning TypeBinding.Null is *not*
a valid way of signalling an error. Either we should return null or a
Problem*Binding as needed. In most situations null is suitable enough
and a PRB or a PMB could be an overkill.

Note that TypeBinding.Null is a valid problem free binding that corresponds
to the null literal&apos;s type. It made it into the classes due to the (now)
historic (incorrect but convenient) connection to NullLiteral.

(In reply to comment #17)

&gt; (7) Implement the traverse methods. In both ClassScope and BlockScope.
&gt; IIRC, 308 requires them in both scopes. Not sure, but it wouldn&apos;t hurt.
&gt; (See Argument#traverse)

I confirmed that lambda/reference expressions could be traversed only
in a block scope. So we should be good just with the block scope traverse
method.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210967</commentid>
    <comment_count>38</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 03:32:52 -0500</bug_when>
    <thetext>Let us move all further work/patches to blocking bugs that the present 
bug depends upon.

We will use the present bug only for discussion of overarching design issues
and as a status tracker for the umbrella semantic analysis project.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210968</commentid>
    <comment_count>39</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-01 03:39:04 -0500</bug_when>
    <thetext>(In reply to comment #37)
&gt; One important implementation note: Returning TypeBinding.Null is *not*
&gt; a valid way of signalling an error. Either we should return null or a
&gt; Problem*Binding as needed. In most situations null is suitable enough
&gt; and a PRB or a PMB could be an overkill.

Ok, good clarification, I never fully understood point (3g) above.

Thank you for your patience in bringing me up to speed, I hope my future contributions will bring &apos;less mess&apos;!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2210984</commentid>
    <comment_count>40</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 04:23:17 -0500</bug_when>
    <thetext>(In reply to comment #39)
&gt; (In reply to comment #37)
&gt; &gt; One important implementation note: Returning TypeBinding.Null is *not*
&gt; &gt; a valid way of signalling an error. Either we should return null or a
&gt; &gt; Problem*Binding as needed. In most situations null is suitable enough
&gt; &gt; and a PRB or a PMB could be an overkill.
&gt; 
&gt; Ok, good clarification, I never fully understood point (3g) above.

3g has to be read along with the earlier passage: &quot;We need to cut the chord 
with literals, except perhaps for still returning TypeBinding.NULL from 
certain code paths (&quot;if needed&quot;, &quot;may be&quot;)&quot; - Now we are fully hooked into
Expression hierarchy.

&gt; Thank you for your patience in bringing me up to speed, I hope my future
&gt; contributions will bring &apos;less mess&apos;!

Actually, the quality of your patches are well above average/typical of a rank
beginner&apos;s work. Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211037</commentid>
    <comment_count>41</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 07:07:03 -0500</bug_when>
    <thetext>A good way to check for parameter compatibility for bug 399534 is to synthesize
a suitably populated method binding for the anonymous method and call
MethodVerifier.isParameterSubsignature. See also MethodVerifier.doesMethodOverride

I am noticing some interesting behavior in javac - need to check if the spec
warrants it - Given the following program:

//----
import java.util.List;

interface I {
	void foo(List&lt;String&gt; ls);
}
public class X {
	void boo() {
		I i = (List l) -&gt; {};
	}
	void goo() {
		I i = new I() {
			public void foo(List l) {
				
			};
		};
	}
}
// --------------




When compiled I get:

C:\jtests&gt;C:\work\lambda-8-b74-windows-x64-21_jan_2013\bin\javac -cp c:\jtests X
.java
X.java:8: error: incompatible types: incompatible parameter types in lambda expression
                I i = (List l) -&gt; {};
                      ^
1 error

The identical case with anonymous classes compiles fine.

Does anyone recall a part of the spec that would justify this ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211052</commentid>
    <comment_count>42</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-01 07:38:25 -0500</bug_when>
    <thetext>(In reply to comment #41)
&gt; 
&gt; Does anyone recall a part of the spec that would justify this ?

EDR 0.5.1 - Part E - Summary addresses this:

For a lambda expression, the descriptor&apos;s parameter and return types are compared to the expression. The lambda parameter types must exactly match those of the descriptor, while the body generally must be assignment-compatible with the descriptor&apos;s return type. [...]</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211057</commentid>
    <comment_count>43</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-01 07:45:26 -0500</bug_when>
    <thetext>(In reply to comment #42)
&gt; (In reply to comment #41)
&gt; &gt; 
&gt; &gt; Does anyone recall a part of the spec that would justify this ?
&gt; 
&gt; EDR 0.5.1 - Part E - Summary addresses this:
&gt; 
&gt; For a lambda expression, the descriptor&apos;s parameter and return types are
&gt; compared to the expression. The lambda parameter types must exactly match
&gt; those of the descriptor, while the body generally must be
&gt; assignment-compatible with the descriptor&apos;s return type. [...]

I see, thanks. In that case the reference I cited in comment#41 won&apos;t be useful
as it is and we may as well resort to equality comparison.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211059</commentid>
    <comment_count>44</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-01 07:50:36 -0500</bug_when>
    <thetext>(In reply to comment #43)
&gt; I see, thanks. In that case the reference I cited in comment#41 won&apos;t be
&gt; useful
&gt; as it is and we may as well resort to equality comparison.

Found it accurately:

15.27.3, under congruence of the lambda expression, bullet 2:

If the lambda parameters have explicitly-declared types, these types are the same as the parameter types of the descriptor.

(so we can put that reference near the equals check and/or test case)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211469</commentid>
    <comment_count>45</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-03 12:05:38 -0500</bug_when>
    <thetext>Part A talks of a &quot;well-formed&quot; parameterized type in this passage:

&quot;If F&lt;T1...Tn&gt; is a well-formed type, then the descriptor of F&lt;A1...An&gt; is the result of applying substitution [P1:=T1, ..., Pn:=Tn] to the descriptor of interface F. Otherwise, the descriptor of F&lt;A1...An&gt; is undefined.&quot; ...

Does anyone have a ready reference that defines this term ? Any code example
that would show an ill formed type ? Is bounds check failure what is alluded
to here ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2211510</commentid>
    <comment_count>46</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-03 23:16:40 -0500</bug_when>
    <thetext>(In reply to comment #45)
&gt; Part A talks of a &quot;well-formed&quot; parameterized type in this passage:

&gt; Does anyone have a ready reference that defines this term ? Any code example
&gt; that would show an ill formed type ? Is bounds check failure what is alluded
&gt; to here ?

Yes. So, this question is closed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2212014</commentid>
    <comment_count>47</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-04 15:39:46 -0500</bug_when>
    <thetext>Against my own request, I am releasing a big chunk of code (resolve &amp;
analyze phases are completely in place for lambdas, analyze is a nop
for ReferenceExpressions) here via: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=1b6413921860c74cfa469f859f6fc627d6400adf

This should fix a whole slew of dozen or so bugs open in this space.
In the next couple of days, I will start adding tests to the respective
bugs and verifying things work ok, close them.

Take a look at how value-body lambda&apos;s are handled in the resolve
phase ;-)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2212022</commentid>
    <comment_count>48</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-04 16:07:32 -0500</bug_when>
    <thetext>(In reply to comment #47)

&gt; Take a look at how value-body lambda&apos;s are handled in the resolve
&gt; phase ;-)

That&apos;s clever... But you forgot to call the analyseCode on the expression, just to catch e.g. important assignments or dead code such as

Supplier&lt;Boolean&gt; bs = () -&gt; (false &amp;&amp; Math.random() &gt; 0.5)

I&apos;ll get my previous unit tests in shape and resubmit them.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2212110</commentid>
    <comment_count>49</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-04 21:21:25 -0500</bug_when>
    <thetext>(In reply to comment #48)
&gt; (In reply to comment #47)
&gt; 
&gt; &gt; Take a look at how value-body lambda&apos;s are handled in the resolve
&gt; &gt; phase ;-)
&gt; 
&gt; That&apos;s clever... But you forgot to call the analyseCode on the expression,
&gt; just to catch e.g. important assignments or dead code such as
&gt; 
&gt; Supplier&lt;Boolean&gt; bs = () -&gt; (false &amp;&amp; Math.random() &gt; 0.5)

Jesper, the following code:

// ---
interface I&lt;T&gt; {
	T doit(int x);
}

class X {
	I&lt;Boolean&gt; i = (int x) -&gt; (false &amp;&amp; Math.random() &gt; 0.5);
}
// -----

does trigger the warning. So does the one below:

// ----

interface I {
	boolean doit(int x);
}

class X {
	I i = (int x) -&gt; (false &amp;&amp; Math.random() &gt; 0.5);
}
// ----

Why wouldn&apos;t the statement:

lambdaInfo = this.body.analyseCode(this.scope, methodContext, lambdaInfo);

in LambdaExpression.analyzeCode suffice ?


&gt; I&apos;ll get my previous unit tests in shape and resubmit them.

Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2212340</commentid>
    <comment_count>50</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-05 09:54:42 -0500</bug_when>
    <thetext>(In reply to comment #49)

&gt; Why wouldn&apos;t the statement:
&gt; 
&gt; lambdaInfo = this.body.analyseCode(this.scope, methodContext, lambdaInfo);
&gt; 
&gt; in LambdaExpression.analyzeCode suffice ?

You are right, it&apos;s fine.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218479</commentid>
    <comment_count>51</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-19 05:10:59 -0500</bug_when>
    <thetext>From my understanding of the code, all is based on the assumption that prior to LambdaExpression.resolveType() we always see a call to setExpectedType().
In the light of JLS8 sect 18 this assumption is unfounded.

The interesting part will be this branch:
		if (!haveDescriptor &amp;&amp; argumentsTypeElided) 
			return null; // FUBAR, bail out...

Making this work is the hardest part.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218484</commentid>
    <comment_count>52</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-19 05:24:10 -0500</bug_when>
    <thetext>(In reply to comment #51)
&gt; From my understanding of the code, all is based on the assumption that prior
&gt; to LambdaExpression.resolveType() we always see a call to setExpectedType().
&gt; In the light of JLS8 sect 18 this assumption is unfounded.
&gt; 
&gt; The interesting part will be this branch:
&gt; 		if (!haveDescriptor &amp;&amp; argumentsTypeElided) 
&gt; 			return null; // FUBAR, bail out...
&gt; 
&gt; Making this work is the hardest part.

My original patch used a separate variable to track whether an expected type was &quot;induced&quot; properly, independent of the actual method binding.
I suppose we could use a sentinel value (MethodBinding.NO_METHOD) in a similar fashion?

One mitigating factor is that since we don&apos;t have a descriptor, the expression is in error anyway, and we wouldn&apos;t be able to verify return types or check parameter uses -- or am I missing something?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218503</commentid>
    <comment_count>53</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-19 05:50:22 -0500</bug_when>
    <thetext>(In reply to comment #52)
&gt; One mitigating factor is that since we don&apos;t have a descriptor, the
&gt; expression is in error anyway, and we wouldn&apos;t be able to verify return
&gt; types or check parameter uses -- or am I missing something?

Not in error. Here&apos;s an &apos;interesting&apos; example from the spec:

  &lt;T&gt; T id(T arg) { return arg; }
  Runnable r = id(() -&gt; { System.out.println(&quot;hi&quot;); });

Not having a descriptor up-front is perfectly legal.
See also bug 400874.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218518</commentid>
    <comment_count>54</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 06:28:16 -0500</bug_when>
    <thetext>(In reply to comment #51)
&gt; From my understanding of the code, all is based on the assumption that prior
&gt; to LambdaExpression.resolveType() we always see a call to setExpectedType().
&gt; In the light of JLS8 sect 18 this assumption is unfounded.
&gt; 
&gt; The interesting part will be this branch:
&gt; 		if (!haveDescriptor &amp;&amp; argumentsTypeElided) 
&gt; 			return null; // FUBAR, bail out...
&gt; 
&gt; Making this work is the hardest part.
 
Gentlemen, May I request you to hold your horses :) I appreciate the
energy levels ! 

Eventually, when a descriptor becomes available, every line of code in
this method is in need.

I am closing this bug shortly and action shifts to a different theater: 
bug 400871.

I expect to share a prototype solution that will address the concerns 
soon or if that gets delayed beyond a week to 10 days a sketch.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218532</commentid>
    <comment_count>55</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-19 07:03:24 -0500</bug_when>
    <thetext>(In reply to comment #54)
&gt; Eventually, when a descriptor becomes available, every line of code in
&gt; this method is in need.

I&apos;m not sure we will always have a descriptor *before* resolving the rest.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218537</commentid>
    <comment_count>56</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 07:16:04 -0500</bug_when>
    <thetext>(In reply to comment #55)
&gt; (In reply to comment #54)
&gt; &gt; Eventually, when a descriptor becomes available, every line of code in
&gt; &gt; this method is in need.
&gt; 
&gt; I&apos;m not sure we will always have a descriptor *before* resolving the rest.

Here is a passage from the spec that is pertinent to the discussion we had
earlier today:

When the lambda parameters&apos; types are inferred, the same lambda expression body can be interpreted in many different ways, depending on the context in which it appears. Specifically, the types of expressions in the body (including return statement values), the checked exceptions thrown, and the type-correctness of the code all depend on the formal parameters&apos; inferred types.
There are two important implications. First, inference of parameter types must be independent of the lambda expression body (the alternative would be to do full constraint-producing type checking, which would be a lot more complex than the simple subtyping and conversion constraints that we handle now). Second, because lambda expressions can be method parameters, overload resolution may cause the same lambda body to be &quot;hypothetically type-checked&quot; more than oncethat is, it may be type-checked multiple times, and an error that occurs during one of these times does not necessarily indicate that the program is incorrect.

I am putting in place the infrastructure to enable this analysis as part
of bug bug 400871.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218540</commentid>
    <comment_count>57</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 07:23:07 -0500</bug_when>
    <thetext>(In reply to comment #56)

&gt; Here is a passage from the spec that is pertinent to the discussion we had
&gt; earlier today:

I&apos;ll say that the two sub passages are pointing in different directions, but
I expect to understand it better as I experiment a bit.

Here is the other interesting passage, I was referring to earlier:
 
A lambda expression (15.27) is potentially compatible with a functional interface type (9.8) if all of the following are true:
The arity of the functional interface&apos;s function descriptor is the same as the arity of the lambda expression.
If the functional interface&apos;s function descriptor has a void return, then the lambda body is either a statement expression (14.8) or a void-compatible block (15.27.2).
If the functional interface&apos;s function descriptor has (non-void) return type, then the lambda body is either an expression or a value-compatible block (15.27.2)

And

A block lambda body is value-compatible if it cannot complete normally (14.21) and every return statement in the block has the form return Expression;.

It is onerous to be able to determine the first part at the exact juncture
where it is required, while the latter can be trivially determined.

My present assessment is that it is a case of over-specification and we can 
punt on the first part about normal completion and the net effect would be
shifting of diagnostics - instead of overload resolution failing, resolution
of the block body would fail and no valid program would be rejected nor any
invalid program be accepted - Let us see.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218541</commentid>
    <comment_count>58</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 07:33:12 -0500</bug_when>
    <thetext>(In reply to comment #56)

&gt; My present assessment is that it is a case of over-specification and we can 
&gt; punt on the first part about normal completion and the net effect would be
&gt; shifting of diagnostics - instead of overload resolution failing, resolution
&gt; of the block body would fail and no valid program would be rejected nor any
&gt; invalid program be accepted - Let us see.

:)

15.12.2.5 states:

T is more specific than S for a lambda expression (15.27) if all of the following are true:
T and S are functional interface types
The functional interface named by T is neither a subinterface nor a superinterface of S
If the lambda expression&apos;s parameters have inferred types, then the descriptor parameter types of T are the same as the descriptor parameter types of S
Either i) the descriptor return type of S is void, or ii) for all result expressions in the lambda body (or for the body itself if the body is an expression), the descriptor return type of the capture of T is more specific than the descriptor return type of S

I&apos;ll had get back to coding and not answer bugzilla mails :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218542</commentid>
    <comment_count>59</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-19 07:35:12 -0500</bug_when>
    <thetext>Thanks for digging out those paragraphs.

I hadn&apos;t seen some of them because I expected (and still expect) to find 
them somewhere in section 18, which gives the impression that the general
constraint-solving approach *is* taken.

Maybe it&apos;s only the return type that participates in constraint solving
across nesting levels, not the parameter types. Maybe.

I promise to hold my horses until I hear an update from you :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218543</commentid>
    <comment_count>60</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 07:39:45 -0500</bug_when>
    <thetext>(In reply to comment #59)

&gt; I promise to hold my horses until I hear an update from you :)

Or an SOS call :) 

Just kidding. (hope to be at least :))</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218900</commentid>
    <comment_count>61</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 15:24:30 -0500</bug_when>
    <thetext>All blocking bugs are resolved and this ER is ready to be resolved.

I did a quick scan of chapters A-E and we are essentially complete
with respect to these - We can now tackle head on the two tough 
nuts - F &amp; G.

This is a major milestone - Thanks everyone !</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221200</commentid>
    <comment_count>62</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-24 01:10:09 -0500</bug_when>
    <thetext>(In reply to comment #51)
&gt; From my understanding of the code, all is based on the assumption that prior
&gt; to LambdaExpression.resolveType() we always see a call to setExpectedType().
&gt; In the light of JLS8 sect 18 this assumption is unfounded.
&gt; 
&gt; The interesting part will be this branch:
&gt; 		if (!haveDescriptor &amp;&amp; argumentsTypeElided) 
&gt; 			return null; // FUBAR, bail out...
&gt; 
&gt; Making this work is the hardest part.

I have carefully read through part F a coupe of times - I think this is 
actually fairly straightforward, even though at a first glance it looks 
hard.

I&apos;ll use bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610 to
showcase a sketch of how I plan to handle this problem. Stay tuned.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221201</commentid>
    <comment_count>63</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-24 01:16:47 -0500</bug_when>
    <thetext>(In reply to comment #52)

&gt; One mitigating factor is that since we don&apos;t have a descriptor, the
&gt; expression is in error anyway, and we wouldn&apos;t be able to verify return
&gt; types or check parameter uses -- or am I missing something?

(In reply to comment #55)
&gt; (In reply to comment #54)
&gt; &gt; Eventually, when a descriptor becomes available, every line of code in
&gt; &gt; this method is in need.
&gt; 
&gt; I&apos;m not sure we will always have a descriptor *before* resolving the rest.

The trick is to short circuit resolution when the descriptor is unavailable
and attempt it only later. Anyway since a patch is worth a thousand words,
I&apos;ll try to post one in a day or two.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221228</commentid>
    <comment_count>64</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-24 08:08:10 -0500</bug_when>
    <thetext>(In reply to comment #54)
&gt; (In reply to comment #51)
&gt; &gt; From my understanding of the code, all is based on the assumption that prior
&gt; &gt; to LambdaExpression.resolveType() we always see a call to setExpectedType().
&gt; &gt; In the light of JLS8 sect 18 this assumption is unfounded.
&gt; &gt; 
&gt; &gt; The interesting part will be this branch:
&gt; &gt; 		if (!haveDescriptor &amp;&amp; argumentsTypeElided) 
&gt; &gt; 			return null; // FUBAR, bail out...
&gt; &gt; 
&gt; &gt; Making this work is the hardest part.

&gt; I expect to share a prototype solution that will address the concerns 
&gt; soon or if that gets delayed beyond a week to 10 days a sketch.

Please take a look at the patch posted at https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610#c1 for hints as to
how I plan to solve this problem.

Excluding tests, it is ~370 lines of patch file diff text, a lot of it boiler
plate variety.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221939</commentid>
    <comment_count>65</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-26 05:05:02 -0500</bug_when>
    <thetext>(In reply to comment #53)
&gt; (In reply to comment #52)
&gt; &gt; One mitigating factor is that since we don&apos;t have a descriptor, the
&gt; &gt; expression is in error anyway, and we wouldn&apos;t be able to verify return
&gt; &gt; types or check parameter uses -- or am I missing something?
&gt; 
&gt; Not in error. Here&apos;s an &apos;interesting&apos; example from the spec:
&gt; 
&gt;   &lt;T&gt; T id(T arg) { return arg; }
&gt;   Runnable r = id(() -&gt; { System.out.println(&quot;hi&quot;); });
&gt; 
&gt; Not having a descriptor up-front is perfectly legal.

This works now and has been added as test case NegativeLambdaExpressionsTest.test401610d().

From 15.12.2.1:

&quot;A lambda expression, a method reference, or a constructor reference is potentially compatible with a type variable if the type variable is a type parameter of the candidate method.&quot;

I think this should actually say, &quot;is potentially compatible with any
type that mentions a type variable if the ...&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2357465</commentid>
    <comment_count>66</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-01 01:39:42 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #59)

&gt; I promise to hold my horses until I hear an update from you :)

Just in case you are still holding your horses, please let the poor beasts
free, now that we are feature complete in the compiler thanks in huge measure
to your own contributions :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2357546</commentid>
    <comment_count>67</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-01 14:43:03 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #66)
&gt; (In reply to Stephan Herrmann from comment #59)
&gt; 
&gt; &gt; I promise to hold my horses until I hear an update from you :)
&gt; 
&gt; Just in case you are still holding your horses, please let the poor beasts
&gt; free, now that we are feature complete in the compiler thanks in huge measure
&gt; to your own contributions :)

No worries, the horses not only galloped criss-cross through type-inference-land but also grazed in neighbouring realms; they had all the exercise and nourishment they needed.

In the end having a complete spec in our hands did make a difference compared to what we had a year ago, wow ;-P</thetext>
  </long_desc>
      
          <attachment
              isobsolete="1"
              ispatch="1"
              isprivate="0"
          >
            <attachid>225695</attachid>
            <date>2013-01-16 07:29:00 -0500</date>
            <delta_ts>2013-01-29 22:09:55 -0500</delta_ts>
            <desc>First attempt at type analysis for lambdas</desc>
            <filename>lambda-type-analysis-for-382701.txt</filename>
            <type>text/plain</type>
            <size>13125</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUN
CmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2NvcmUvY29tcGlsZXIvSVByb2Js
ZW0uamF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvY29yZS9jb21waWxlci9JUHJvYmxlbS5q
YXZhDQppbmRleCBjZTNiNDY0Li5lNjAxZThjIDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9jb3JlL2NvbXBpbGVyL0lQcm9ibGVtLmphdmENCisrKyBjb21waWxlci9vcmcvZWNs
aXBzZS9qZHQvY29yZS9jb21waWxlci9JUHJvYmxlbS5qYXZhDQpAQCAtMTM0MCw2ICsxMzQwLDEx
IEBADQogCS8qKiBAc2luY2UgMy45ICovDQogCWludCBJbGxlZ2FsQXJyYXlPZlVuaW9uVHlwZSA9
IFR5cGVSZWxhdGVkICsgNjYyOw0KIA0KKwkvKiogQHNpbmNlIDMuOSAqLw0KKwlpbnQgUG9seUV4
cHJlc3Npb25JbklsbGVnYWxDb250ZXh0ID0gVHlwZVJlbGF0ZWQgKyA2NjM7DQorCS8qKiBAc2lu
Y2UgMy45ICovDQorCWludCBUYXJnZXRUeXBlSXNOb3RBRnVuY3Rpb25hbEludGVyZmFjZSA9IFR5
cGVSZWxhdGVkICsgNjY0Ow0KKwkNCiAJLyoqDQogCSAqIENvcnJ1cHRlZCBiaW5hcmllcw0KIAkg
Ki8NCmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVy
L2FzdC9Bcmd1bWVudC5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21w
aWxlci9hc3QvQXJndW1lbnQuamF2YQ0KaW5kZXggOGM5NmNlYy4uNjM5OGJkMSAxMDA2NDQNCi0t
LSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0FyZ3VtZW50
LmphdmENCisrKyBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0
L0FyZ3VtZW50LmphdmENCkBAIC0yNyw2ICsyNyw3IEBADQogDQogCS8vIHByZWZpeCBmb3Igc2V0
dGVyIG1ldGhvZCAodG8gcmVjb2duaXplIHNwZWNpYWwgaGlkaW5nIGFyZ3VtZW50KQ0KIAlwcml2
YXRlIGZpbmFsIHN0YXRpYyBjaGFyW10gU0VUID0gInNldCIudG9DaGFyQXJyYXkoKTsgLy8kTk9O
LU5MUy0xJA0KKwlwcml2YXRlIFR5cGVCaW5kaW5nIGVsaWRlZFR5cGU7DQogDQogCXB1YmxpYyBB
cmd1bWVudChjaGFyW10gbmFtZSwgbG9uZyBwb3NOb20sIFR5cGVSZWZlcmVuY2UgdHIsIGludCBt
b2RpZmllcnMpIHsNCiANCkBAIC0xMzMsNiArMTM0LDE0IEBADQogCQlyZXR1cm4gcHJpbnQoaW5k
ZW50LCBvdXRwdXQpLmFwcGVuZCgnOycpOw0KIAl9DQogDQorCXB1YmxpYyB2b2lkIHJlc29sdmUo
QmxvY2tTY29wZSBzY29wZSkgew0KKwkJLy8gd2Ugc2hvdWxkIGhhdmUgdGhlIGJpbmRpbmcgYWxy
ZWFkeQ0KKwkJaWYgKCh0aGlzLmJpdHMgJiBJc1R5cGVFbGlkZWQpICE9IDApIHsNCisJCQlyZXNv
bHZlVG9UeXBlKHNjb3BlLCB0aGlzLmVsaWRlZFR5cGUpOw0KKwkJfSBlbHNlIHsNCisJCQlzdXBl
ci5yZXNvbHZlKHNjb3BlKTsNCisJCX0NCisJfQ0KIAlwdWJsaWMgVHlwZUJpbmRpbmcgcmVzb2x2
ZUZvckNhdGNoKEJsb2NrU2NvcGUgc2NvcGUpIHsNCiAJCS8vIHJlc29sdXRpb24gb24gYW4gYXJn
dW1lbnQgb2YgYSBjYXRjaCBjbGF1c2UNCiAJCS8vIHByb3ZpZGUgdGhlIHNjb3BlIHdpdGggYSBz
aWRlIGVmZmVjdCA6IGluc2VydGlvbiBvZiBhIExPQ0FMDQpAQCAtMjEzLDQgKzIyMiwxNCBAQA0K
IAkJfQ0KIAkJdmlzaXRvci5lbmRWaXNpdCh0aGlzLCBzY29wZSk7DQogCX0NCisNCisJcHVibGlj
IHZvaWQgc2V0RWxpZGVkVHlwZShUeXBlQmluZGluZyB0eXBlQmluZGluZykgew0KKwkJaWYgKCh0
aGlzLmJpdHMgJiBJc1R5cGVFbGlkZWQpICE9IDApIHsNCisJCQl0aGlzLmVsaWRlZFR5cGUgPSB0
eXBlQmluZGluZzsNCisJCX0NCisJfQ0KKwkNCisJcHVibGljIFR5cGVCaW5kaW5nIGVsaWRlZFR5
cGUoKSB7DQorCQlyZXR1cm4gdGhpcy5lbGlkZWRUeXBlOw0KKwl9DQogfQ0KZGlmZiAtLWdpdCBj
b21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0xhbWJkYUV4cHJl
c3Npb24uamF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0
L0xhbWJkYUV4cHJlc3Npb24uamF2YQ0KaW5kZXggMjViMGYyYi4uYzEzMTY5ZCAxMDA2NDQNCi0t
LSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0xhbWJkYUV4
cHJlc3Npb24uamF2YQ0KKysrIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21w
aWxlci9hc3QvTGFtYmRhRXhwcmVzc2lvbi5qYXZhDQpAQCAtMTQsOSArMTQsMjAgQEANCiAgKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5j
b21waWxlci5hc3Q7DQogDQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxl
ci5BU1RWaXNpdG9yOw0KK2ltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIu
bG9va3VwLkJsb2NrU2NvcGU7DQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21w
aWxlci5sb29rdXAuTGFtYmRhU2NvcGU7DQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5h
bC5jb21waWxlci5sb29rdXAuTWV0aG9kQmluZGluZzsNCitpbXBvcnQgb3JnLmVjbGlwc2UuamR0
LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5SZWZlcmVuY2VCaW5kaW5nOw0KK2ltcG9ydCBvcmcu
ZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlR5cGVCaW5kaW5nOw0KKw0KIHB1
YmxpYyBjbGFzcyBMYW1iZGFFeHByZXNzaW9uIGV4dGVuZHMgTnVsbExpdGVyYWwgeyAgLy8gRm9y
IHRoZSB0aW1lIGJlaW5nLg0KIAlBcmd1bWVudCBbXSBhcmd1bWVudHM7DQogCVN0YXRlbWVudCBi
b2R5Ow0KKwlMYW1iZGFTY29wZSBzY29wZTsNCisJVHlwZURlY2xhcmF0aW9uIHR5cGVEZWNsYXJh
dGlvbjsNCisJcHJpdmF0ZSBUeXBlQmluZGluZyBleHBlY3RlZFR5cGU7DQorCXByaXZhdGUgTWV0
aG9kQmluZGluZyBzaW5nbGVNZXRob2Q7DQogCQ0KIAlwdWJsaWMgTGFtYmRhRXhwcmVzc2lvbihB
cmd1bWVudCBbXSBhcmd1bWVudHMsIFN0YXRlbWVudCBib2R5KSB7DQogCQlzdXBlcigwLCAwKTsN
CkBAIC0yNCw2ICszNSw2NyBAQA0KIAkJdGhpcy5ib2R5ID0gYm9keTsNCiAJfQ0KIAkNCisJcHVi
bGljIHZvaWQgc2V0RXhwZWN0ZWRUeXBlKFR5cGVCaW5kaW5nIGV4cGVjdGVkVHlwZSkgew0KKwkJ
dGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7DQorCX0NCisNCisJcHVibGljIFR5cGVC
aW5kaW5nIHJlc29sdmVUeXBlKEJsb2NrU2NvcGUgYmxvY2tTY29wZSkgew0KKwkJaWYgKHRoaXMu
ZXhwZWN0ZWRUeXBlID09IG51bGwpIHsNCisJCQl0aGlzLnNjb3BlLnByb2JsZW1SZXBvcnRlcigp
LnBvbHlFeHByZXNzaW9uSW5JbGxlZ2FsQ29udGV4dCh0aGlzKTsNCisJCX0NCisJCXRoaXMuc2lu
Z2xlTWV0aG9kID0gcmVzb2x2ZUZ1bmN0aW9uYWxNZXRob2QodGhpcy5hcmd1bWVudHMgIT0gbnVs
bCA/IHRoaXMuYXJndW1lbnRzLmxlbmd0aCA6IDApOw0KKwkJaWYgKHRoaXMuc2NvcGUgPT0gbnVs
bCAmJiB0aGlzLmJvZHkgIT0gbnVsbCkgew0KKwkJCXRoaXMuc2NvcGUgPSBuZXcgTGFtYmRhU2Nv
cGUoYmxvY2tTY29wZSwgdGhpcyk7DQorCQl9DQorCQlpZiAodGhpcy5hcmd1bWVudHMgIT0gbnVs
bCkgew0KKwkJCWZvciAoaW50IGkgPSAwLCBsZW5ndGggPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7
IGkgPCBsZW5ndGg7IGkrKykgew0KKwkJCQl0aGlzLmFyZ3VtZW50c1tpXS5zZXRFbGlkZWRUeXBl
KHRoaXMuc2luZ2xlTWV0aG9kLnBhcmFtZXRlcnNbaV0pOw0KKwkJCQl0aGlzLmFyZ3VtZW50c1tp
XS5yZXNvbHZlKHRoaXMuc2NvcGUpOw0KKy8vCQkJCXRoaXMuc2NvcGUuYWRkTG9jYWxWYXJpYWJs
ZSh0aGlzLmFyZ3VtZW50c1tpXS5iaW5kaW5nKTsNCisJCQl9DQorCQl9DQorCQkvLyBNdXN0IGV4
YW1pbmUgcG9seS10eXBlIGFuZCBwaWNrIHRoZSByaWdodCBvbmUNCisJCQ0KKwkJaWYgKHRoaXMu
Ym9keSAhPSBudWxsKSB7DQorCQkJdGhpcy5ib2R5LnJlc29sdmUodGhpcy5zY29wZSk7DQorCQl9
DQorCQkNCisJCXJldHVybiBzdXBlci5yZXNvbHZlVHlwZSh0aGlzLnNjb3BlKTsNCisJfQ0KKwkN
CisJcHJpdmF0ZSBNZXRob2RCaW5kaW5nIHJlc29sdmVGdW5jdGlvbmFsTWV0aG9kKGludCBudW1i
ZXJPZkFyZ3VtZW50cykgew0KKwkJaWYgKCEgKHRoaXMuZXhwZWN0ZWRUeXBlIGluc3RhbmNlb2Yg
UmVmZXJlbmNlQmluZGluZykpIHsNCisJCQl0aGlzLnNjb3BlLnByb2JsZW1SZXBvcnRlcigpLnBv
bHlFeHByZXNzaW9uSW5JbGxlZ2FsQ29udGV4dCh0aGlzKTsNCisJCQlyZXR1cm4gbnVsbDsNCisJ
CX0NCisJCVJlZmVyZW5jZUJpbmRpbmcgcmVmZXJlbmNlQmluZGluZyA9IChSZWZlcmVuY2VCaW5k
aW5nKXRoaXMuZXhwZWN0ZWRUeXBlOw0KKwkJTWV0aG9kQmluZGluZyBtZXRob2RzW10gPSByZWZl
cmVuY2VCaW5kaW5nLm1ldGhvZHMoKTsNCisJCQ0KKwkJaWYgKG1ldGhvZHMubGVuZ3RoICE9IDEp
IHsNCisJCQl0aGlzLnNjb3BlLnByb2JsZW1SZXBvcnRlcigpLnBvbHlFeHByZXNzaW9uSW5JbGxl
Z2FsQ29udGV4dCh0aGlzKTsNCisJCQlyZXR1cm4gbnVsbDsNCisJCX0NCisJCXJldHVybiBtZXRo
b2RzWzBdOyAvLyBUT0RPOiBJbXBsZW1lbnQgbWFueSBtb3JlIHJ1bGVzLi4uDQorCX0NCisNCisJ
cHVibGljIHZvaWQgdHJhdmVyc2UoDQorCQkJQVNUVmlzaXRvciB2aXNpdG9yLA0KKwkJCUJsb2Nr
U2NvcGUgYmxvY2tTY29wZSkgew0KKw0KKwkJCWlmICh2aXNpdG9yLnZpc2l0KHRoaXMsIGJsb2Nr
U2NvcGUpKSB7DQorCQkJCWlmICh0aGlzLmFyZ3VtZW50cyAhPSBudWxsKSB7DQorCQkJCQlpbnQg
YXJndW1lbnRzTGVuZ3RoID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOw0KKwkJCQkJZm9yIChpbnQg
aSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykNCisJCQkJCQl0aGlzLmFyZ3VtZW50c1tp
XS50cmF2ZXJzZSh2aXNpdG9yLCB0aGlzLnNjb3BlKTsNCisJCQkJfQ0KKw0KKwkJCQlpZiAodGhp
cy5ib2R5ICE9IG51bGwpIHsNCisJCQkJCXRoaXMuYm9keS50cmF2ZXJzZSh2aXNpdG9yLCB0aGlz
LnNjb3BlKTsNCisJCQkJfQ0KKwkJCX0NCisJCQl2aXNpdG9yLmVuZFZpc2l0KHRoaXMsIGJsb2Nr
U2NvcGUpOw0KKwkJfQ0KKw0KIAlwdWJsaWMgU3RyaW5nQnVmZmVyIHByaW50RXhwcmVzc2lvbihp
bnQgdGFiLCBTdHJpbmdCdWZmZXIgb3V0cHV0KSB7DQogCQlpbnQgcGFyZW50aGVzZXNDb3VudCA9
ICh0aGlzLmJpdHMgJiBBU1ROb2RlLlBhcmVudGhlc2l6ZWRNQVNLKSA+PiBBU1ROb2RlLlBhcmVu
dGhlc2l6ZWRTSElGVDsNCiAJCVN0cmluZyBzdWZmaXggPSAiIjsgLy8kTk9OLU5MUy0xJA0KQEAg
LTQyLDQgKzExNCw4IEBADQogCQl0aGlzLmJvZHkucHJpbnQodGhpcy5ib2R5IGluc3RhbmNlb2Yg
QmxvY2sgPyB0YWIgOiAwLCBvdXRwdXQpOw0KIAkJcmV0dXJuIG91dHB1dC5hcHBlbmQoc3VmZml4
KTsNCiAJfQ0KKw0KKwlwdWJsaWMgVHlwZUJpbmRpbmcgZXhwZWN0ZWRSZXN1bHRUeXBlKCkgew0K
KwkJcmV0dXJuIHRoaXMuc2luZ2xlTWV0aG9kICE9IG51bGwgPyB0aGlzLnNpbmdsZU1ldGhvZC5y
ZXR1cm5UeXBlIDogbnVsbDsgDQorCX0NCiB9DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTG9jYWxEZWNsYXJhdGlvbi5qYXZhIGNvbXBp
bGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTG9jYWxEZWNsYXJhdGlv
bi5qYXZhDQppbmRleCAxOTg2NmQ1Li43Njg4OTM3IDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9l
Y2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTG9jYWxEZWNsYXJhdGlvbi5qYXZhDQor
KysgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9Mb2NhbERl
Y2xhcmF0aW9uLmphdmENCkBAIC0yMTgsOCArMjE4LDE0IEBADQogDQogCQkvLyBjcmVhdGUgYSBi
aW5kaW5nIGFuZCBhZGQgaXQgdG8gdGhlIHNjb3BlDQogCQlUeXBlQmluZGluZyB2YXJpYWJsZVR5
cGUgPSB0aGlzLnR5cGUucmVzb2x2ZVR5cGUoc2NvcGUsIHRydWUgLyogY2hlY2sgYm91bmRzKi8p
Ow0KKwkJcmVzb2x2ZVRvVHlwZShzY29wZSwgdmFyaWFibGVUeXBlKTsNCisJfQ0KKwkNCisJcHJv
dGVjdGVkIHZvaWQgcmVzb2x2ZVRvVHlwZShCbG9ja1Njb3BlIHNjb3BlLCBUeXBlQmluZGluZyB2
YXJpYWJsZVR5cGUpIHsNCiANCi0JCXRoaXMuYml0cyB8PSAodGhpcy50eXBlLmJpdHMgJiBBU1RO
b2RlLkhhc1R5cGVBbm5vdGF0aW9ucyk7DQorCQlpZiAodGhpcy50eXBlICE9IG51bGwpIHsNCisJ
CQl0aGlzLmJpdHMgfD0gKHRoaXMudHlwZS5iaXRzICYgQVNUTm9kZS5IYXNUeXBlQW5ub3RhdGlv
bnMpOw0KKwkJfQ0KIAkJY2hlY2tNb2RpZmllcnMoKTsNCiAJCWlmICh2YXJpYWJsZVR5cGUgIT0g
bnVsbCkgew0KIAkJCWlmICh2YXJpYWJsZVR5cGUgPT0gVHlwZUJpbmRpbmcuVk9JRCkgew0KZGlm
ZiAtLWdpdCBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L1Jl
dHVyblN0YXRlbWVudC5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21w
aWxlci9hc3QvUmV0dXJuU3RhdGVtZW50LmphdmENCmluZGV4IDUzZWQzNTUuLmUwNTBjMDggMTAw
NjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9S
ZXR1cm5TdGF0ZW1lbnQuamF2YQ0KKysrIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9hc3QvUmV0dXJuU3RhdGVtZW50LmphdmENCkBAIC0yNTksMTEgKzI1OSwxNCBA
QA0KIAlNZXRob2RTY29wZSBtZXRob2RTY29wZSA9IHNjb3BlLm1ldGhvZFNjb3BlKCk7DQogCU1l
dGhvZEJpbmRpbmcgbWV0aG9kQmluZGluZzsNCiAJVHlwZUJpbmRpbmcgbWV0aG9kVHlwZSA9DQor
CQkobWV0aG9kU2NvcGUgaW5zdGFuY2VvZiBMYW1iZGFTY29wZSkgPyAoKExhbWJkYVNjb3BlKW1l
dGhvZFNjb3BlKS5leHBlY3RlZFJlc3VsdFR5cGUoKSA6IA0KIAkJKG1ldGhvZFNjb3BlLnJlZmVy
ZW5jZUNvbnRleHQgaW5zdGFuY2VvZiBBYnN0cmFjdE1ldGhvZERlY2xhcmF0aW9uKQ0KIAkJCT8g
KChtZXRob2RCaW5kaW5nID0gKChBYnN0cmFjdE1ldGhvZERlY2xhcmF0aW9uKSBtZXRob2RTY29w
ZS5yZWZlcmVuY2VDb250ZXh0KS5iaW5kaW5nKSA9PSBudWxsDQogCQkJCT8gbnVsbA0KIAkJCQk6
IG1ldGhvZEJpbmRpbmcucmV0dXJuVHlwZSkNCiAJCQk6IFR5cGVCaW5kaW5nLlZPSUQ7DQorDQor
CQkJDQogCVR5cGVCaW5kaW5nIGV4cHJlc3Npb25UeXBlOw0KIAlpZiAobWV0aG9kVHlwZSA9PSBU
eXBlQmluZGluZy5WT0lEKSB7DQogCQkvLyB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgbnVsbA0K
ZGlmZiAtLWdpdCBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9v
a3VwL0xhbWJkYVNjb3BlLmphdmEgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2Nv
bXBpbGVyL2xvb2t1cC9MYW1iZGFTY29wZS5qYXZhDQpuZXcgZmlsZSBtb2RlIDEwMDY0NA0KaW5k
ZXggMDAwMDAwMC4uZTQ0YTNjZQ0KLS0tIC9kZXYvbnVsbA0KKysrIGNvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAvTGFtYmRhU2NvcGUuamF2YQ0KQEAgLTAs
MCArMSwzMiBAQA0KKy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQorICogQ29weXJpZ2h0IChjKSAy
MDEzIEplc3BlciBTdGVlbiBNb2xsZXIgYW5kIG90aGVycy4NCisgKiBBbGwgcmlnaHRzIHJlc2Vy
dmVkLiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzDQorICogYXJl
IG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgRWNsaXBzZSBQdWJsaWMgTGlj
ZW5zZSB2MS4wDQorICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmlidXRpb24sIGFuZCBp
cyBhdmFpbGFibGUgYXQNCisgKiBodHRwOi8vd3d3LmVjbGlwc2Uub3JnL2xlZ2FsL2VwbC12MTAu
aHRtbA0KKyAqDQorICogVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBhbiBlYXJseS1kcmFm
dCBzcGVjaWZpY2F0aW9uIGRldmVsb3BlZCB1bmRlciB0aGUgSmF2YQ0KKyAqIENvbW11bml0eSBQ
cm9jZXNzIChKQ1ApIGFuZCBpcyBtYWRlIGF2YWlsYWJsZSBmb3IgdGVzdGluZyBhbmQgZXZhbHVh
dGlvbiBwdXJwb3Nlcw0KKyAqIG9ubHkuIFRoZSBjb2RlIGlzIG5vdCBjb21wYXRpYmxlIHdpdGgg
YW55IHNwZWNpZmljYXRpb24gb2YgdGhlIEpDUC4NCisgKg0KKyAqIENvbnRyaWJ1dG9yczoNCisg
KiAgICAgSmVzcGVyIE1vbGxlciAtIGluaXRpYWwgQVBJIGFuZCBpbXBsZW1lbnRhdGlvbg0KKyAq
CQkJCQkJCQlidWcgMzgyNzI3IC0gWzEuOF1bY29tcGlsZXJdIExhbWJkYSBleHByZXNzaW9uIHBh
cmFtZXRlcnMgYW5kIGxvY2FscyBjYW5ub3Qgc2hhZG93IHZhcmlhYmxlcyBmcm9tIGNvbnRleHQN
CisgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKi8NCitwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRl
cm5hbC5jb21waWxlci5sb29rdXA7DQorDQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5h
bC5jb21waWxlci5hc3QuTGFtYmRhRXhwcmVzc2lvbjsNCisNCitwdWJsaWMgY2xhc3MgTGFtYmRh
U2NvcGUgZXh0ZW5kcyBNZXRob2RTY29wZSB7DQorDQorCXByb3RlY3RlZCBMYW1iZGFFeHByZXNz
aW9uIGV4cHJlc3Npb247DQorDQorCXB1YmxpYyBMYW1iZGFTY29wZShCbG9ja1Njb3BlIHBhcmVu
dCwgTGFtYmRhRXhwcmVzc2lvbiBleHByZXNzaW9uKSB7DQorCQlzdXBlcihMQU1CREFfU0NPUEUs
IHBhcmVudCwgcGFyZW50LnJlZmVyZW5jZUNvbnRleHQoKSwgcGFyZW50Lm1ldGhvZFNjb3BlKCku
aXNTdGF0aWMpOw0KKwkJdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjsNCisJfQ0KKw0KKwlw
dWJsaWMgVHlwZUJpbmRpbmcgZXhwZWN0ZWRSZXN1bHRUeXBlKCkgew0KKwkJcmV0dXJuIHRoaXMu
ZXhwcmVzc2lvbi5leHBlY3RlZFJlc3VsdFR5cGUoKTsNCisJfQ0KK30NCmRpZmYgLS1naXQgY29t
cGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9NZXRob2RTY29w
ZS5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAv
TWV0aG9kU2NvcGUuamF2YQ0KaW5kZXggMzdkYjM1Ni4uMTg3OWY3MyAxMDA2NDQNCi0tLSBjb21w
aWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL01ldGhvZFNjb3Bl
LmphdmENCisrKyBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9v
a3VwL01ldGhvZFNjb3BlLmphdmENCkBAIC02MywxNCArNjMsMTggQEANCiAJLy8gcmVtZW1iZXIg
c3VwcHJlc3NlZCB3YXJuaW5nIHJlIG1pc3NpbmcgJ2RlZmF1bHQ6JyB0byBnaXZlIGhpbnRzIG9u
IHBvc3NpYmx5IHJlbGF0ZWQgZmxvdyBwcm9ibGVtcw0KIAlwdWJsaWMgYm9vbGVhbiBoYXNNaXNz
aW5nU3dpdGNoRGVmYXVsdDsgLy8gVE9ETyhzdGVwaGFuKTogY29tYmluZSBmbGFncyB0byBhIGJp
dHNldD8NCiANCi1wdWJsaWMgTWV0aG9kU2NvcGUoQ2xhc3NTY29wZSBwYXJlbnQsIFJlZmVyZW5j
ZUNvbnRleHQgY29udGV4dCwgYm9vbGVhbiBpc1N0YXRpYykgew0KLQlzdXBlcihNRVRIT0RfU0NP
UEUsIHBhcmVudCk7DQorcHJvdGVjdGVkIE1ldGhvZFNjb3BlKGludCB0eXBlLCBTY29wZSBwYXJl
bnQsIFJlZmVyZW5jZUNvbnRleHQgY29udGV4dCwgYm9vbGVhbiBpc1N0YXRpYykgew0KKwlzdXBl
cih0eXBlLCBwYXJlbnQpOw0KIAl0aGlzLmxvY2FscyA9IG5ldyBMb2NhbFZhcmlhYmxlQmluZGlu
Z1s1XTsNCiAJdGhpcy5yZWZlcmVuY2VDb250ZXh0ID0gY29udGV4dDsNCiAJdGhpcy5pc1N0YXRp
YyA9IGlzU3RhdGljOw0KIAl0aGlzLnN0YXJ0SW5kZXggPSAwOw0KIH0NCiANCitwdWJsaWMgTWV0
aG9kU2NvcGUoQ2xhc3NTY29wZSBwYXJlbnQsIFJlZmVyZW5jZUNvbnRleHQgY29udGV4dCwgYm9v
bGVhbiBpc1N0YXRpYykgew0KKwl0aGlzKE1FVEhPRF9TQ09QRSwgcGFyZW50LCBjb250ZXh0LCBp
c1N0YXRpYyk7DQorfQ0KKw0KIFN0cmluZyBiYXNpY1RvU3RyaW5nKGludCB0YWIpIHsNCiAJU3Ry
aW5nIG5ld0xpbmUgPSAiXG4iOyAvLyROT04tTkxTLTEkDQogCWZvciAoaW50IGkgPSB0YWI7IC0t
aSA+PSAwOykNCmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2Nv
bXBpbGVyL2xvb2t1cC9TY29wZS5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9sb29rdXAvU2NvcGUuamF2YQ0KaW5kZXggM2Q4OTMwZC4uOTg4ODA4NCAxMDA2
NDQNCi0tLSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3Vw
L1Njb3BlLmphdmENCisrKyBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGls
ZXIvbG9va3VwL1Njb3BlLmphdmENCkBAIC0zOCw2ICszOCw3IEBADQogCXB1YmxpYyBmaW5hbCBz
dGF0aWMgaW50IENMQVNTX1NDT1BFID0gMzsNCiAJcHVibGljIGZpbmFsIHN0YXRpYyBpbnQgQ09N
UElMQVRJT05fVU5JVF9TQ09QRSA9IDQ7DQogCXB1YmxpYyBmaW5hbCBzdGF0aWMgaW50IE1FVEhP
RF9TQ09QRSA9IDI7DQorCXB1YmxpYyBmaW5hbCBzdGF0aWMgaW50IExBTUJEQV9TQ09QRSA9IDU7
DQogDQogCS8qIEFyZ3VtZW50IENvbXBhdGliaWxpdGllcyAqLw0KIAlwdWJsaWMgZmluYWwgc3Rh
dGljIGludCBOT1RfQ09NUEFUSUJMRSA9IC0xOw0KQEAgLTE3MTcsNiArMTcxOCw3IEBADQogCQkJ
CVJlZmVyZW5jZUJpbmRpbmcgZm91bmRBY3R1YWxSZWNlaXZlclR5cGUgPSBudWxsOw0KIAkJCQlk
b25lIDogd2hpbGUgKHRydWUpIHsgLy8gZG9uZSB3aGVuIGEgQ09NUElMQVRJT05fVU5JVF9TQ09Q
RSBpcyBmb3VuZA0KIAkJCQkJc3dpdGNoIChzY29wZS5raW5kKSB7DQorCQkJCQkJY2FzZSBMQU1C
REFfU0NPUEUgOg0KIAkJCQkJCWNhc2UgTUVUSE9EX1NDT1BFIDoNCiAJCQkJCQkJTWV0aG9kU2Nv
cGUgbWV0aG9kU2NvcGUgPSAoTWV0aG9kU2NvcGUpIHNjb3BlOw0KIAkJCQkJCQlpbnNpZGVTdGF0
aWNDb250ZXh0IHw9IG1ldGhvZFNjb3BlLmlzU3RhdGljOw0KZGlmZiAtLWdpdCBjb21waWxlci9v
cmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcHJvYmxlbS9Qcm9ibGVtUmVwb3J0ZXIu
amF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcHJvYmxlbS9Q
cm9ibGVtUmVwb3J0ZXIuamF2YQ0KaW5kZXggZTk1YjllMS4uMDRkZGFjMiAxMDA2NDQNCi0tLSBj
b21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcHJvYmxlbS9Qcm9ibGVt
UmVwb3J0ZXIuamF2YQ0KKysrIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21w
aWxlci9wcm9ibGVtL1Byb2JsZW1SZXBvcnRlci5qYXZhDQpAQCAtMjc2OSw2ICsyNzY5LDIyIEBA
DQogCQkJbGV4cC5zb3VyY2VTdGFydCwNCiAJCQlsZXhwLnNvdXJjZUVuZCk7DQogfQ0KK3B1Ymxp
YyB2b2lkIHBvbHlFeHByZXNzaW9uSW5JbGxlZ2FsQ29udGV4dChMYW1iZGFFeHByZXNzaW9uIGxl
eHApIHsNCisJdGhpcy5oYW5kbGUoDQorCQkJSVByb2JsZW0uUG9seUV4cHJlc3Npb25JbklsbGVn
YWxDb250ZXh0LA0KKwkJCU5vQXJndW1lbnQsDQorCQkJTm9Bcmd1bWVudCwNCisJCQlsZXhwLnNv
dXJjZVN0YXJ0LA0KKwkJCWxleHAuc291cmNlRW5kKTsNCit9DQorcHVibGljIHZvaWQgdGFyZ2V0
VHlwZUlzTm90QUZ1bmN0aW9uYWxJbnRlcmZhY2UoTGFtYmRhRXhwcmVzc2lvbiBsZXhwKSB7DQor
CXRoaXMuaGFuZGxlKA0KKwkJCUlQcm9ibGVtLlRhcmdldFR5cGVJc05vdEFGdW5jdGlvbmFsSW50
ZXJmYWNlLA0KKwkJCU5vQXJndW1lbnQsDQorCQkJTm9Bcmd1bWVudCwNCisJCQlsZXhwLnNvdXJj
ZVN0YXJ0LA0KKwkJCWxleHAuc291cmNlRW5kKTsNCit9DQogcHVibGljIHZvaWQgaWxsZWdhbFZp
c2liaWxpdHlNb2RpZmllckNvbWJpbmF0aW9uRm9yRmllbGQoUmVmZXJlbmNlQmluZGluZyB0eXBl
LCBGaWVsZERlY2xhcmF0aW9uIGZpZWxkRGVjbCkgew0KIAlTdHJpbmdbXSBhcmd1bWVudHMgPSBu
ZXcgU3RyaW5nW10ge25ldyBTdHJpbmcoZmllbGREZWNsLm5hbWUpfTsNCiAJdGhpcy5oYW5kbGUo
DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9w
cm9ibGVtL21lc3NhZ2VzLnByb3BlcnRpZXMgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVy
bmFsL2NvbXBpbGVyL3Byb2JsZW0vbWVzc2FnZXMucHJvcGVydGllcw0KaW5kZXggMjM1ZjQ3ZS4u
NWQyMjBhNiAxMDA2NDQNCi0tLSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29t
cGlsZXIvcHJvYmxlbS9tZXNzYWdlcy5wcm9wZXJ0aWVzDQorKysgY29tcGlsZXIvb3JnL2VjbGlw
c2UvamR0L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vbWVzc2FnZXMucHJvcGVydGllcw0KQEAg
LTYxMSw2ICs2MTEsOCBAQA0KIA0KICMjIyBNT1JFIFRZUEUgUkVMQVRFRA0KIDY2MiA9IElsbGVn
YWwgYXR0ZW1wdCB0byBjcmVhdGUgYXJyYXlzIG9mIHVuaW9uIHR5cGVzDQorNjYzID0gKFRPRE86
IFdvcmRpbmcpIElsbGVnYWwgUG9seSBleHByZXNzaW9uIGNvbnRleHQgIC8gdGFyZ2V0IHR5cGUg
bm90IHNldA0KKzY2MyA9IChUT0RPOiBXb3JkaW5nKSBUYXJnZXQgdHlwZSBpcyBub3QgYSBmdW5j
dGlvbmFsIGludGVyZmFjZSAgDQogDQogIyMjIENPUlJVUFRFRCBCSU5BUklFUw0KIDcwMCA9IFRo
ZSBjbGFzcyBmaWxlIHswfSBjb250YWlucyBhIHNpZ25hdHVyZSAnJ3sxfScnIGlsbC1mb3JtZWQg
YXQgcG9zaXRpb24gezJ9
</data>

          </attachment>
          <attachment
              isobsolete="1"
              ispatch="0"
              isprivate="0"
          >
            <attachid>226290</attachid>
            <date>2013-01-29 22:09:00 -0500</date>
            <delta_ts>2013-01-30 13:00:57 -0500</delta_ts>
            <desc>Patch for as far as I&apos;ve gotten (cleanly)</desc>
            <filename>file_382701.txt</filename>
            <type>text/plain</type>
            <size>12289</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUN
CmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2NvcmUvY29tcGlsZXIvSVByb2Js
ZW0uamF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvY29yZS9jb21waWxlci9JUHJvYmxlbS5q
YXZhDQppbmRleCA1OGFmNDEzLi5hN2MzMWQ2IDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9jb3JlL2NvbXBpbGVyL0lQcm9ibGVtLmphdmENCisrKyBjb21waWxlci9vcmcvZWNs
aXBzZS9qZHQvY29yZS9jb21waWxlci9JUHJvYmxlbS5qYXZhDQpAQCAtMTYxLDYgKzE2MSw4IEBA
DQogICoJCQkJCQkJCQlEZXJlZmVyZW5jaW5nTnVsbGFibGVFeHByZXNzaW9uDQogICoJCQkJCQkJ
CQlOdWxsaXR5TWlzbWF0Y2hpbmdUeXBlQW5ub3RhdGlvbg0KICAqCQkJCQkJCQkJTnVsbGl0eU1p
c21hdGNoaW5nVHlwZUFubm90YXRpb25VbmNoZWNrZWQNCisgKiAgICAgIEplc3BlciBTIE1vbGxl
ciAgLSBhZGRlZCB0aGUgZm9sbG93aW5nIGNvbnN0YW50cw0KKyAqCQkJCQkJCQkJTm90QUZ1bmN0
aW9uYWxJbnRlcmZhY2UNCiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5l
Y2xpcHNlLmpkdC5jb3JlLmNvbXBpbGVyOw0KIA0KQEAgLTEzMzEsNiArMTMzMyw4IEBADQogICAg
IGludCBJbGxlZ2FsUXVhbGlmaWVyRm9yRXhwbGljaXRUaGlzID0gSW50ZXJuYWwgKyBTeW50YXgg
KyA2NTE7DQogICAgIC8qKiBAc2luY2UgMy45ICovDQogICAgIGludCBJbGxlZ2FsUXVhbGlmaWVy
Rm9yRXhwbGljaXRUaGlzMiA9IEludGVybmFsICsgU3ludGF4ICsgNjUyOw0KKyAgICAvKiogQHNp
bmNlIDMuOSAqLw0KKyAgICBpbnQgTm90QUZ1bmN0aW9uYWxJbnRlcmZhY2UgPSBJbnRlcm5hbCAr
IFR5cGVSZWxhdGVkICsgNjUzOw0KICAgICANCiAJLyoqDQogCSAqIE1vcmUgcHJvYmxlbXMgaW4g
Z2VuZXJpY3MNCmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2Nv
bXBpbGVyL2FzdC9MYW1iZGFFeHByZXNzaW9uLmphdmEgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL2FzdC9MYW1iZGFFeHByZXNzaW9uLmphdmENCmluZGV4IDI1YjBm
MmIuLjhjYzVjZTEgMTAwNjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFs
L2NvbXBpbGVyL2FzdC9MYW1iZGFFeHByZXNzaW9uLmphdmENCisrKyBjb21waWxlci9vcmcvZWNs
aXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0xhbWJkYUV4cHJlc3Npb24uamF2YQ0KQEAg
LTEsNSArMSw1IEBADQogLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioNCi0gKiBDb3B5cmlnaHQgKGMp
IDIwMDAsIDIwMTIgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMuDQorICogQ29weXJpZ2h0IChj
KSAyMDAwLCAyMDEzIElCTSBDb3Jwb3JhdGlvbiBhbmQgb3RoZXJzLg0KICAqIEFsbCByaWdodHMg
cmVzZXJ2ZWQuIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMNCiAg
KiBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBFY2xpcHNlIFB1Ymxp
YyBMaWNlbnNlIHYxLjANCiAgKiB3aGljaCBhY2NvbXBhbmllcyB0aGlzIGRpc3RyaWJ1dGlvbiwg
YW5kIGlzIGF2YWlsYWJsZSBhdA0KQEAgLTExLDE5ICsxMSwzMSBAQA0KICAqDQogICogQ29udHJp
YnV0b3JzOg0KICAqICAgICBJQk0gQ29ycG9yYXRpb24gLSBpbml0aWFsIEFQSSBhbmQgaW1wbGVt
ZW50YXRpb24NCisgKiAgICAgSmVzcGVyIFMgTW9sbGVyIC0gQ29udHJpYnV0aW9ucyBmb3INCisg
KgkJCQkJCQlidWcgMzgyNzAxIC0gWzEuOF1bY29tcGlsZXJdIEltcGxlbWVudCBzZW1hbnRpYyBh
bmFseXNpcyBvZiBMYW1iZGEgZXhwcmVzc2lvbnMgJiBSZWZlcmVuY2UgZXhwcmVzc2lvbg0KICAq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqLw0KIHBhY2thZ2Ugb3JnLmVjbGlwc2UuamR0LmludGVybmFs
LmNvbXBpbGVyLmFzdDsNCiANCi1wdWJsaWMgY2xhc3MgTGFtYmRhRXhwcmVzc2lvbiBleHRlbmRz
IE51bGxMaXRlcmFsIHsgIC8vIEZvciB0aGUgdGltZSBiZWluZy4NCitpbXBvcnQgb3JnLmVjbGlw
c2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5CbG9ja1Njb3BlOw0KK2ltcG9ydCBvcmcu
ZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlR5cGVCaW5kaW5nOw0KKw0KK3B1
YmxpYyBjbGFzcyBMYW1iZGFFeHByZXNzaW9uIGV4dGVuZHMgRnVuY3Rpb25hbEV4cHJlc3Npb24g
ew0KIAlBcmd1bWVudCBbXSBhcmd1bWVudHM7DQogCVN0YXRlbWVudCBib2R5Ow0KIAkNCiAJcHVi
bGljIExhbWJkYUV4cHJlc3Npb24oQXJndW1lbnQgW10gYXJndW1lbnRzLCBTdGF0ZW1lbnQgYm9k
eSkgew0KLQkJc3VwZXIoMCwgMCk7DQogCQl0aGlzLmFyZ3VtZW50cyA9IGFyZ3VtZW50czsNCiAJ
CXRoaXMuYm9keSA9IGJvZHk7DQogCX0NCiAJDQorCXB1YmxpYyBUeXBlQmluZGluZyByZXNvbHZl
VHlwZShCbG9ja1Njb3BlIGJsb2NrU2NvcGUpIHsNCisJCS8vIHRyeSB0byByZXNvbHZlIHRoZSBl
eHBlY3RlZCB0eXBlIGFzIGEgZnVuY3Rpb25hbCBpbnRlcmZhY2UNCisJCWlmIChyZXNvbHZlRnVu
Y3Rpb25hbERlc2NyaXB0b3IoYmxvY2tTY29wZS5wcm9ibGVtUmVwb3J0ZXIoKSkgIT0gbnVsbCkg
ew0KKwkJCS8vIEdyZWF0PyBUT0RPOiBCaW5kIHRoZSBhcmd1bWVudHMgYW5kIHJlc29sdmUgdGhl
IGxhbWJkYSBib2R5DQorCQl9DQorCQlyZXR1cm4gdGhpcy5leHBlY3RlZFR5cGUoKTsNCisJfQ0K
Kw0KIAlwdWJsaWMgU3RyaW5nQnVmZmVyIHByaW50RXhwcmVzc2lvbihpbnQgdGFiLCBTdHJpbmdC
dWZmZXIgb3V0cHV0KSB7DQogCQlpbnQgcGFyZW50aGVzZXNDb3VudCA9ICh0aGlzLmJpdHMgJiBB
U1ROb2RlLlBhcmVudGhlc2l6ZWRNQVNLKSA+PiBBU1ROb2RlLlBhcmVudGhlc2l6ZWRTSElGVDsN
CiAJCVN0cmluZyBzdWZmaXggPSAiIjsgLy8kTk9OLU5MUy0xJA0KQEAgLTQyLDQgKzU0LDkgQEAN
CiAJCXRoaXMuYm9keS5wcmludCh0aGlzLmJvZHkgaW5zdGFuY2VvZiBCbG9jayA/IHRhYiA6IDAs
IG91dHB1dCk7DQogCQlyZXR1cm4gb3V0cHV0LmFwcGVuZChzdWZmaXgpOw0KIAl9DQorDQorCXB1
YmxpYyBBcmd1bWVudCBbXSBhcmd1bWVudHMoKSB7DQorCQlyZXR1cm4gdGhpcy5hcmd1bWVudHM7
DQorCX0NCisNCiB9DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhwcmVzc2lvbi5qYXZhIGNvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhwcmVzc2lvbi5qYXZhDQpp
bmRleCBiYzY4MGQ2Li4yYmVjNzMyIDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pk
dC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhwcmVzc2lvbi5qYXZhDQorKysgY29t
cGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9SZWZlcmVuY2VFeHBy
ZXNzaW9uLmphdmENCkBAIC0xMSwxMSArMTEsMTMgQEANCiAgKg0KICAqIENvbnRyaWJ1dG9yczoN
CiAgKiAgICAgSUJNIENvcnBvcmF0aW9uIC0gaW5pdGlhbCBBUEkgYW5kIGltcGxlbWVudGF0aW9u
DQorICogICAgIEplc3BlciBTIE1vbGxlciAtIENvbnRyaWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJ
YnVnIDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMg
b2YgTGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4cHJlc3Npb24NCiAgKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKi8NCiANCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21w
aWxlci5hc3Q7DQogDQotcHVibGljIGNsYXNzIFJlZmVyZW5jZUV4cHJlc3Npb24gZXh0ZW5kcyBO
dWxsTGl0ZXJhbCB7IC8vIEZvciB0aGUgdGltZSBiZWluZy4NCitwdWJsaWMgY2xhc3MgUmVmZXJl
bmNlRXhwcmVzc2lvbiBleHRlbmRzIEZ1bmN0aW9uYWxFeHByZXNzaW9uIHsNCiAJDQogCXByb3Rl
Y3RlZCBOYW1lUmVmZXJlbmNlIG5hbWU7DQogCXByb3RlY3RlZCBUeXBlUmVmZXJlbmNlIHR5cGU7
DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9s
b29rdXAvUHJvYmxlbVJlYXNvbnMuamF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJu
YWwvY29tcGlsZXIvbG9va3VwL1Byb2JsZW1SZWFzb25zLmphdmENCmluZGV4IDQzNzM2ODcuLjAw
ZDgwZDUgMTAwNjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBp
bGVyL2xvb2t1cC9Qcm9ibGVtUmVhc29ucy5qYXZhDQorKysgY29tcGlsZXIvb3JnL2VjbGlwc2Uv
amR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9Qcm9ibGVtUmVhc29ucy5qYXZhDQpAQCAtMSw1
ICsxLDUgQEANCiAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLSAqIENvcHlyaWdodCAoYykgMjAw
MCwgMjAxMSBJQk0gQ29ycG9yYXRpb24gYW5kIG90aGVycy4NCisgKiBDb3B5cmlnaHQgKGMpIDIw
MDAsIDIwMTMgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMuDQogICogQWxsIHJpZ2h0cyByZXNl
cnZlZC4gVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscw0KICAqIGFy
ZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEVjbGlwc2UgUHVibGljIExp
Y2Vuc2UgdjEuMA0KICAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJpYnV0aW9uLCBhbmQg
aXMgYXZhaWxhYmxlIGF0DQpAQCAtNyw2ICs3LDkgQEANCiAgKg0KICAqIENvbnRyaWJ1dG9yczoN
CiAgKiAgICAgSUJNIENvcnBvcmF0aW9uIC0gaW5pdGlhbCBBUEkgYW5kIGltcGxlbWVudGF0aW9u
DQorICogICAgIEplc3BlciBTIE1vbGxlciAtIENvbnRyaWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJ
YnVnIDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMg
b2YgTGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4cHJlc3Npb24NCisNCiAgKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21w
aWxlci5sb29rdXA7DQogDQpAQCAtMjgsNCArMzEsNSBAQA0KIAlmaW5hbCBpbnQgSW52YWxpZFR5
cGVGb3JTdGF0aWNJbXBvcnQgPSAxNDsNCiAJZmluYWwgaW50IEludmFsaWRUeXBlRm9yQXV0b01h
bmFnZWRSZXNvdXJjZSA9IDE1Ow0KIAlmaW5hbCBpbnQgVmFyYXJnc0VsZW1lbnRUeXBlTm90Vmlz
aWJsZSA9IDE2Ow0KKwlmaW5hbCBpbnQgTm9TdWNoU2luZ2xlQWJzdHJhY3RNZXRob2QgPSAxNzsN
CiB9DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxl
ci9sb29rdXAvUmVmZXJlbmNlQmluZGluZy5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9p
bnRlcm5hbC9jb21waWxlci9sb29rdXAvUmVmZXJlbmNlQmluZGluZy5qYXZhDQppbmRleCA3M2Uw
MWJkLi5kZDliODNmIDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9sb29rdXAvUmVmZXJlbmNlQmluZGluZy5qYXZhDQorKysgY29tcGlsZXIvb3Jn
L2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9SZWZlcmVuY2VCaW5kaW5nLmph
dmENCkBAIC0xLDUgKzEsNSBAQA0KIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqDQotICogQ29weXJp
Z2h0IChjKSAyMDAwLCAyMDEyIElCTSBDb3Jwb3JhdGlvbiBhbmQgb3RoZXJzLg0KKyAqIENvcHly
aWdodCAoYykgMjAwMCwgMjAxMyBJQk0gQ29ycG9yYXRpb24gYW5kIG90aGVycy4NCiAgKiBBbGwg
cmlnaHRzIHJlc2VydmVkLiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJp
YWxzDQogICogYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgRWNsaXBz
ZSBQdWJsaWMgTGljZW5zZSB2MS4wDQogICogd2hpY2ggYWNjb21wYW5pZXMgdGhpcyBkaXN0cmli
dXRpb24sIGFuZCBpcyBhdmFpbGFibGUgYXQNCkBAIC0xOSw2ICsxOSw4IEBADQogICoJCQkJCQkJ
CWJ1ZyAzNjU1MzEgLSBbY29tcGlsZXJdW251bGxdIGludmVzdGlnYXRlIGFsdGVybmF0aXZlIHN0
cmF0ZWd5IGZvciBpbnRlcm5hbGx5IGVuY29kaW5nIG51bGxuZXNzIGRlZmF1bHRzDQogICoJCQkJ
CQkJCWJ1ZyAzODgyODEgLSBbY29tcGlsZXJdW251bGxdIGluaGVyaXRhbmNlIG9mIG51bGwgYW5u
b3RhdGlvbnMgYXMgYW4gb3B0aW9uDQogICoJCQkJCQkJCWJ1ZyAzOTI4NjIgLSBbMS44XVtjb21w
aWxlcl1bbnVsbF0gRXZhbHVhdGUgbnVsbCBhbm5vdGF0aW9ucyBvbiBhcnJheSB0eXBlcw0KKyAq
ICAgICAgSmVzcGVyIFMgTW9sbGVyIC0gQ29udHJpYnV0aW9ucyBmb3INCisgKgkJCQkJCQkJYnVn
IDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMgb2Yg
TGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4cHJlc3Npb24NCiAgKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5s
b29rdXA7DQogDQpAQCAtMTU3NCw0ICsxNTc2LDEyIEBADQogCX0JDQogCXJldHVybiAwOw0KIH0N
CisNCitwdWJsaWMgTWV0aG9kQmluZGluZyBnZXRTaW5nbGVBYnN0cmFjdE1ldGhvZCgpIHsNCisJ
Ly8gVGhpcyBpcyBqdXN0IGEgZmlyc3QgYmVnaW5uaW5nDQorCWlmICh0aGlzLm1ldGhvZHMoKS5s
ZW5ndGggIT0gMSkgew0KKwkJcmV0dXJuIG5ldyBQcm9ibGVtTWV0aG9kQmluZGluZygiZnVuY3Rp
b24iLnRvQ2hhckFycmF5KCksIG5ldyBUeXBlQmluZGluZ1swXSwgUHJvYmxlbVJlYXNvbnMuTm9T
dWNoU2luZ2xlQWJzdHJhY3RNZXRob2QpOyAvLyROT04tTkxTLTEkDQorCX0NCisJcmV0dXJuIHRo
aXMubWV0aG9kcygpWzBdOw0KK30NCiB9DQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNl
L2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAvVHlwZUJpbmRpbmcuamF2YSBjb21waWxlci9v
cmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1R5cGVCaW5kaW5nLmphdmEN
CmluZGV4IDEwZDNlNDguLjJjZTg2Y2IgMTAwNjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlwc2Uv
amR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9UeXBlQmluZGluZy5qYXZhDQorKysgY29tcGls
ZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9UeXBlQmluZGluZy5q
YXZhDQpAQCAtMSw1ICsxLDUgQEANCiAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0KLSAqIENvcHly
aWdodCAoYykgMjAwMCwgMjAxMSBJQk0gQ29ycG9yYXRpb24gYW5kIG90aGVycy4NCisgKiBDb3B5
cmlnaHQgKGMpIDIwMDAsIDIwMTMgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMuDQogICogQWxs
IHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVy
aWFscw0KICAqIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEVjbGlw
c2UgUHVibGljIExpY2Vuc2UgdjEuMA0KICAqIHdoaWNoIGFjY29tcGFuaWVzIHRoaXMgZGlzdHJp
YnV0aW9uLCBhbmQgaXMgYXZhaWxhYmxlIGF0DQpAQCAtMTQsNiArMTQsOCBAQA0KICAqICAgICAg
U3RlcGhlbiBIZXJybWFubiA8c3RlcGhhbkBjcy50dS1iZXJsaW4uZGU+IC0gIENvbnRyaWJ1dGlv
bnMgZm9yDQogICoJCQkJCQkJCWJ1ZyAzMTcwNDYgLSBFeGNlcHRpb24gZHVyaW5nIGRlYnVnZ2lu
ZyB3aGVuIGhvdmVyIG1vdXNlIG92ZXIgYSBmaWVsZA0KICAqCQkJCQkJCQlidWcgMzkyODYyIC0g
WzEuOF1bY29tcGlsZXJdW251bGxdIEV2YWx1YXRlIG51bGwgYW5ub3RhdGlvbnMgb24gYXJyYXkg
dHlwZXMNCisgKiAgICAgIEplc3BlciBTIE1vbGxlciA8amVzcGVyQHNlbHNrYWJldC5vcmc+IC0g
IENvbnRyaWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJCWJ1ZyAzODI3MDEgLSBbMS44XVtjb21waWxl
cl0gSW1wbGVtZW50IHNlbWFudGljIGFuYWx5c2lzIG9mIExhbWJkYSBleHByZXNzaW9ucyAmIFJl
ZmVyZW5jZSBleHByZXNzaW9uDQogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovDQogcGFja2FnZSBv
cmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwOw0KIA0KQEAgLTEyMjUsNCAr
MTIyNywxNSBAQA0KIHB1YmxpYyBUeXBlVmFyaWFibGVCaW5kaW5nW10gdHlwZVZhcmlhYmxlcygp
IHsNCiAJcmV0dXJuIEJpbmRpbmcuTk9fVFlQRV9WQVJJQUJMRVM7DQogfQ0KKw0KKy8qKg0KKyAq
IFJldHVybnMgdGhlIG1vc3QgbWV0aG9kIG1vc3QgY2xvc2VseSBjb3JyZXNwb25kaW5nIHRvIHRo
ZSBmdW5jdGlvbmFsIGRlc2NyaXB0b3Igb2YgdGhlIA0KKyAqIGEgZnVuY3Rpb25hbCBpbnRlcmZh
Y2UsIGFzIGRlZmluZWQgaW4gSkxTIDkuOC4NCisgKiAgDQorICogQHJldHVybiBUaGUgc2luZ2xl
IGFic3RyYWN0IG1ldGhvZCBvZiBhIGZ1bmN0aW9uYWwgaW50ZXJmYWNlLCBvciBudWxsLCBpZiB0
aGUgcmVjZWl2ZXIgaXMgbm90IGEgZnVuY3Rpb25hbCBpbnRlcmZhY2UuIA0KKyAqLw0KK3B1Ymxp
YyBNZXRob2RCaW5kaW5nIGdldFNpbmdsZUFic3RyYWN0TWV0aG9kKCkgew0KKwlyZXR1cm4gbnVs
bDsNCit9DQorDQogfQ0KZGlmZiAtLWdpdCBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJu
YWwvY29tcGlsZXIvcHJvYmxlbS9Qcm9ibGVtUmVwb3J0ZXIuamF2YSBjb21waWxlci9vcmcvZWNs
aXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcHJvYmxlbS9Qcm9ibGVtUmVwb3J0ZXIuamF2YQ0K
aW5kZXggNDc3NTJhZC4uNjAxMDRjOSAxMDA2NDQNCi0tLSBjb21waWxlci9vcmcvZWNsaXBzZS9q
ZHQvaW50ZXJuYWwvY29tcGlsZXIvcHJvYmxlbS9Qcm9ibGVtUmVwb3J0ZXIuamF2YQ0KKysrIGNv
bXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wcm9ibGVtL1Byb2JsZW1S
ZXBvcnRlci5qYXZhDQpAQCAtMjcsNiArMjcsOCBAQA0KICAqCQkJCQkJCQlidWcgMzg4MjgxIC0g
W2NvbXBpbGVyXVtudWxsXSBpbmhlcml0YW5jZSBvZiBudWxsIGFubm90YXRpb25zIGFzIGFuIG9w
dGlvbg0KICAqCQkJCQkJCQlidWcgMzkyODYyIC0gWzEuOF1bY29tcGlsZXJdW251bGxdIEV2YWx1
YXRlIG51bGwgYW5ub3RhdGlvbnMgb24gYXJyYXkgdHlwZXMNCiAgKgkJCQkJCQkJYnVnIDM4ODcz
OSAtIFsxLjhdW2NvbXBpbGVyXSBjb25zaWRlciBkZWZhdWx0IG1ldGhvZHMgd2hlbiBkZXRlY3Rp
bmcgd2hldGhlciBhIGNsYXNzIG5lZWRzIHRvIGJlIGRlY2xhcmVkIGFic3RyYWN0DQorICogICAg
ICBKZXNwZXIgUyBNb2xsZXIgPGplc3BlckBzZWxza2FiZXQub3JnPiAtICBDb250cmlidXRpb25z
IGZvcg0KKyAqCQkJCQkJCQlidWcgMzgyNzAxIC0gWzEuOF1bY29tcGlsZXJdIEltcGxlbWVudCBz
ZW1hbnRpYyBhbmFseXNpcyBvZiBMYW1iZGEgZXhwcmVzc2lvbnMgJiBSZWZlcmVuY2UgZXhwcmVz
c2lvbg0KICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLw0KIHBhY2thZ2Ugb3JnLmVjbGlwc2UuamR0
LmludGVybmFsLmNvbXBpbGVyLnByb2JsZW07DQogDQpAQCAtMTI3Miw2ICsxMjc0LDE1IEBADQog
CQlyZWZlcmVuY2Uuc291cmNlU3RhcnQsDQogCQlyZWZlcmVuY2Uuc291cmNlRW5kKTsNCiB9DQor
cHVibGljIHZvaWQgdGFyZ2V0VHlwZUlzTm90QUZ1bmN0aW9uYWxJbnRlcmZhY2UoQVNUTm9kZSB0
YXJnZXQsIFR5cGVCaW5kaW5nIGV4cGVjdGVkVGFyZ2V0VHlwZSkgew0KKwlTdHJpbmdbXSBwcm9i
bGVtQXJndW1lbnRzID0gbmV3IFN0cmluZ1tdIHsgbmV3IFN0cmluZyhleHBlY3RlZFRhcmdldFR5
cGUuc2hvcnRSZWFkYWJsZU5hbWUoKSl9Ow0KKwl0aGlzLmhhbmRsZSgNCisJCUlQcm9ibGVtLk5v
dEFGdW5jdGlvbmFsSW50ZXJmYWNlLA0KKwkJcHJvYmxlbUFyZ3VtZW50cywNCisJCXByb2JsZW1B
cmd1bWVudHMsDQorCQl0YXJnZXQuc291cmNlU3RhcnQsDQorCQl0YXJnZXQuc291cmNlRW5kKTsN
Cit9DQogcHVibGljIHZvaWQgY2FzZUV4cHJlc3Npb25NdXN0QmVDb25zdGFudChFeHByZXNzaW9u
IGV4cHJlc3Npb24pIHsNCiAJdGhpcy5oYW5kbGUoDQogCQlJUHJvYmxlbS5Ob25Db25zdGFudEV4
cHJlc3Npb24sDQpkaWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9j
b21waWxlci9wcm9ibGVtL21lc3NhZ2VzLnByb3BlcnRpZXMgY29tcGlsZXIvb3JnL2VjbGlwc2Uv
amR0L2ludGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vbWVzc2FnZXMucHJvcGVydGllcw0KaW5kZXgg
MDVkOThhOGQuLjdhMzY5ZmQgMTAwNjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2lu
dGVybmFsL2NvbXBpbGVyL3Byb2JsZW0vbWVzc2FnZXMucHJvcGVydGllcw0KKysrIGNvbXBpbGVy
L29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wcm9ibGVtL21lc3NhZ2VzLnByb3Bl
cnRpZXMNCkBAIC0yNSw2ICsyNSw4IEBADQogIwkJCQkJCQlidWcgMzgyMzQ3IC0gWzEuOF1bY29t
cGlsZXJdIENvbXBpbGVyIGFjY2VwdHMgaW5jb3JyZWN0IGRlZmF1bHQgbWV0aG9kIGluaGVyaXRh
bmNlDQogIwkJCQkJCQlidWcgMzg4MjgxIC0gW2NvbXBpbGVyXVtudWxsXSBpbmhlcml0YW5jZSBv
ZiBudWxsIGFubm90YXRpb25zIGFzIGFuIG9wdGlvbg0KICMJCQkJCQkJYnVnIDM5Mjg2MiAtIFsx
LjhdW2NvbXBpbGVyXVtudWxsXSBFdmFsdWF0ZSBudWxsIGFubm90YXRpb25zIG9uIGFycmF5IHR5
cGVzDQorIwkJSmVzcGVyIFMgTW9sbGVyIDxqZXNwZXJAc2Vsc2thYmV0Lm9yZz4gLSBDb250cmli
dXRpb25zIGZvcg0KKyMJCQkJCQkJYnVnIDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1l
bnQgc2VtYW50aWMgYW5hbHlzaXMgb2YgTGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4
cHJlc3Npb24NCiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj
IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjDQogMCA9IHswfQ0KIDEgPSBzdXBlciBj
YW5ub3QgYmUgdXNlZCBpbiBqYXZhLmxhbmcuT2JqZWN0DQpAQCAtNjA2LDYgKzYwOCw3IEBADQog
NjUwID0gVGhlIGRlY2xhcmVkIHR5cGUgb2YgdGhlIGV4cGxpY2l0ICcndGhpcycnIHBhcmFtZXRl
ciBpcyBleHBlY3RlZCB0byBiZSB7MH0NCiA2NTEgPSBUaGUgZXhwbGljaXQgJyd0aGlzJycgcGFy
YW1ldGVyIGlzIGV4cGVjdGVkIHRvIGJlIHF1YWxpZmllZCB3aXRoIHswfQ0KIDY1MiA9IFRoZSBl
eHBsaWNpdCAnJ3RoaXMnJyBwYXJhbWV0ZXIgZm9yIGEgbWV0aG9kIGNhbm5vdCBoYXZlIGEgcXVh
bGlmeWluZyBuYW1lDQorNjUyID0gVGhlIGZ1bmNpb25hbCBleHByZXNzaW9uIGNhbm5vdCBiZSBl
eHBsaWNpdCAnJ3RoaXMnJyBwYXJhbWV0ZXIgZm9yIGEgbWV0aG9kIGNhbm5vdCBoYXZlIGEgcXVh
bGlmeWluZyBuYW1lDQogIyMjIE1PUkUgR0VORVJJQ1MNCiA2NjAgPSBVbnVzZWQgdHlwZSBhcmd1
bWVudHMgZm9yIHRoZSBub24gZ2VuZXJpYyBjb25zdHJ1Y3RvciB7MH0oezF9KSBvZiB0eXBlIHsy
fTsgaXQgc2hvdWxkIG5vdCBiZSBwYXJhbWV0ZXJpemVkIHdpdGggYXJndW1lbnRzIDx7M30+DQog
NjYxID0gVW51c2VkIHR5cGUgcGFyYW1ldGVyIHswfQ0KIA==
</data>

          </attachment>
          <attachment
              isobsolete="1"
              ispatch="0"
              isprivate="0"
          >
            <attachid>226307</attachid>
            <date>2013-01-30 05:22:00 -0500</date>
            <delta_ts>2013-01-30 13:01:15 -0500</delta_ts>
            <desc>Test fixes for org.eclipse.jdt.core.tests.compiler.regression.CompilerInvocationTests</desc>
            <filename>file_382701.txt</filename>
            <type>text/plain</type>
            <size>2558</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUu
dGVzdHMuY29tcGlsZXINCmRpZmYgLS1naXQgc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3Rz
L2NvbXBpbGVyL3JlZ3Jlc3Npb24vQ29tcGlsZXJJbnZvY2F0aW9uVGVzdHMuamF2YSBzcmMvb3Jn
L2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9Db21waWxlckludm9j
YXRpb25UZXN0cy5qYXZhDQppbmRleCA0OWZkMmMwLi4yOTA2NDZjIDEwMDY0NA0KLS0tIHNyYy9v
cmcvZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9uL0NvbXBpbGVySW52
b2NhdGlvblRlc3RzLmphdmENCisrKyBzcmMvb3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29t
cGlsZXIvcmVncmVzc2lvbi9Db21waWxlckludm9jYXRpb25UZXN0cy5qYXZhDQpAQCAtMjMsNyAr
MjMsOSBAQA0KICAqCQkJCQkJCQlidWcgMzgyMzQ3IC0gWzEuOF1bY29tcGlsZXJdIENvbXBpbGVy
IGFjY2VwdHMgaW5jb3JyZWN0IGRlZmF1bHQgbWV0aG9kIGluaGVyaXRhbmNlDQogICoJCQkJCQkJ
CWJ1ZyAzODgyODEgLSBbY29tcGlsZXJdW251bGxdIGluaGVyaXRhbmNlIG9mIG51bGwgYW5ub3Rh
dGlvbnMgYXMgYW4gb3B0aW9uDQogICoJCQkJCQkJCWJ1ZyAzOTI4NjIgLSBbMS44XVtjb21waWxl
cl1bbnVsbF0gRXZhbHVhdGUgbnVsbCBhbm5vdGF0aW9ucyBvbiBhcnJheSB0eXBlcw0KLSAqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqLw0KKyAqICAgICBKZXNwZXIgUyBNb2xsZXIgLSBDb250cmlidXRp
b25zIGZvcg0KKyAqCQkJCQkJCQlidWcgMzgyNzAxIC0gWzEuOF1bY29tcGlsZXJdIEltcGxlbWVu
dCBzZW1hbnRpYyBhbmFseXNpcyBvZiBMYW1iZGEgZXhwcmVzc2lvbnMgJiBSZWZlcmVuY2UgZXhw
cmVzc2lvbg0KKyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovDQogcGFja2FnZSBvcmcuZWNsaXBzZS5q
ZHQuY29yZS50ZXN0cy5jb21waWxlci5yZWdyZXNzaW9uOw0KIA0KIGltcG9ydCBqYXZhLmxhbmcu
cmVmbGVjdC5GaWVsZDsNCkBAIC04NzcsNiArODc5LDcgQEANCiAJCWV4cGVjdGVkUHJvYmxlbUF0
dHJpYnV0ZXMucHV0KCJTdXBlcmZsdW91c1NlbWljb2xvbiIsIG5ldyBQcm9ibGVtQXR0cmlidXRl
cyhDYXRlZ29yaXplZFByb2JsZW0uQ0FUX1BPVEVOVElBTF9QUk9HUkFNTUlOR19QUk9CTEVNKSk7
DQogCQlleHBlY3RlZFByb2JsZW1BdHRyaWJ1dGVzLnB1dCgiU3dpdGNoT25FbnVtTm90QmVsb3cx
NSIsIG5ldyBQcm9ibGVtQXR0cmlidXRlcyhDYXRlZ29yaXplZFByb2JsZW0uQ0FUX1RZUEUpKTsN
CiAJCWV4cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMucHV0KCJTd2l0Y2hPblN0cmluZ3NOb3RCZWxv
dzE3IiwgbmV3IFByb2JsZW1BdHRyaWJ1dGVzKENhdGVnb3JpemVkUHJvYmxlbS5DQVRfVFlQRSkp
Ow0KKwkJZXhwZWN0ZWRQcm9ibGVtQXR0cmlidXRlcy5wdXQoIlRhcmdldFR5cGVOb3RBRnVuY3Rp
b25hbEludGVyZmFjZSIsIG5ldyBQcm9ibGVtQXR0cmlidXRlcyhDYXRlZ29yaXplZFByb2JsZW0u
Q0FUX1RZUEUpKTsNCiAJCWV4cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMucHV0KCJUYXNrIiwgbmV3
IFByb2JsZW1BdHRyaWJ1dGVzKENhdGVnb3JpemVkUHJvYmxlbS5DQVRfSU5URVJOQUwpKTsNCiAJ
CWV4cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMucHV0KCJUaGlzSW5TdGF0aWNDb250ZXh0IiwgbmV3
IFByb2JsZW1BdHRyaWJ1dGVzKENhdGVnb3JpemVkUHJvYmxlbS5DQVRfSU5URVJOQUwpKTsNCiAJ
CWV4cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMucHV0KCJUaGlzU3VwZXJEdXJpbmdDb25zdHJ1Y3Rv
ckludm9jYXRpb24iLCBuZXcgUHJvYmxlbUF0dHJpYnV0ZXMoQ2F0ZWdvcml6ZWRQcm9ibGVtLkNB
VF9NRU1CRVIpKTsNCkBAIC0xNjExLDYgKzE2MTQsNyBAQA0KIAkJZXhwZWN0ZWRQcm9ibGVtQXR0
cmlidXRlcy5wdXQoIlN1cGVyZmx1b3VzU2VtaWNvbG9uIiwgbmV3IFByb2JsZW1BdHRyaWJ1dGVz
KEphdmFDb3JlLkNPTVBJTEVSX1BCX0VNUFRZX1NUQVRFTUVOVCkpOw0KIAkJZXhwZWN0ZWRQcm9i
bGVtQXR0cmlidXRlcy5wdXQoIlN3aXRjaE9uRW51bU5vdEJlbG93MTUiLCBTS0lQKTsNCiAJCWV4
cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMucHV0KCJTd2l0Y2hPblN0cmluZ3NOb3RCZWxvdzE3Iiwg
U0tJUCk7DQorCQlleHBlY3RlZFByb2JsZW1BdHRyaWJ1dGVzLnB1dCgiVGFyZ2V0VHlwZU5vdEFG
dW5jdGlvbmFsSW50ZXJmYWNlIiwgU0tJUCk7DQogCQlleHBlY3RlZFByb2JsZW1BdHRyaWJ1dGVz
LnB1dCgiVGFzayIsIFNLSVApOw0KIAkJZXhwZWN0ZWRQcm9ibGVtQXR0cmlidXRlcy5wdXQoIlRo
aXNJblN0YXRpY0NvbnRleHQiLCBTS0lQKTsNCiAJCWV4cGVjdGVkUHJvYmxlbUF0dHJpYnV0ZXMu
cHV0KCJUaGlzU3VwZXJEdXJpbmdDb25zdHJ1Y3Rvckludm9jYXRpb24iLCBTS0lQKTs=
</data>

          </attachment>
          <attachment
              isobsolete="1"
              ispatch="1"
              isprivate="0"
          >
            <attachid>226315</attachid>
            <date>2013-01-30 07:47:00 -0500</date>
            <delta_ts>2013-01-30 13:32:51 -0500</delta_ts>
            <desc>Patch to cut FunctionalExpression&apos;s dependency on Literal</desc>
            <filename>FunctionalExpression.patch</filename>
            <type>text/plain</type>
            <size>2303</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMAojUCBvcmcuZWNsaXBzZS5qZHQuY29yZQpk
aWZmIC0tZ2l0IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3Qv
RnVuY3Rpb25hbEV4cHJlc3Npb24uamF2YSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJu
YWwvY29tcGlsZXIvYXN0L0Z1bmN0aW9uYWxFeHByZXNzaW9uLmphdmEKaW5kZXggYzVjZWZkOC4u
OTI1NGUyNyAxMDA2NDQKLS0tIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21w
aWxlci9hc3QvRnVuY3Rpb25hbEV4cHJlc3Npb24uamF2YQorKysgY29tcGlsZXIvb3JnL2VjbGlw
c2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9GdW5jdGlvbmFsRXhwcmVzc2lvbi5qYXZhCkBA
IC0xMSwyMiArMTEsMjcgQEAKICAqCiAgKiBDb250cmlidXRvcnM6CiAgKiAgICAgSUJNIENvcnBv
cmF0aW9uIC0gaW5pdGlhbCBBUEkgYW5kIGltcGxlbWVudGF0aW9uCisgKiAgICAgSmVzcGVyIFMg
TW9sbGVyIC0gQ29udHJpYnV0aW9ucyBmb3IKKyAqCQkJCQkJCWJ1ZyAzODI3MDEgLSBbMS44XVtj
b21waWxlcl0gSW1wbGVtZW50IHNlbWFudGljIGFuYWx5c2lzIG9mIExhbWJkYSBleHByZXNzaW9u
cyAmIFJlZmVyZW5jZSBleHByZXNzaW9uCiAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8KIHBhY2th
Z2Ugb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmFzdDsKIAoraW1wb3J0IG9yZy5l
Y2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5jb2RlZ2VuLkNvZGVTdHJlYW07CitpbXBvcnQg
b3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmZsb3cuRmxvd0luZm87CiBpbXBvcnQg
b3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmltcGwuQ29uc3RhbnQ7CiBpbXBvcnQg
b3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5CbG9ja1Njb3BlOwogaW1w
b3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5sb29rdXAuTWV0aG9kQmluZGlu
ZzsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlR5cGVC
aW5kaW5nOwogCi1wdWJsaWMgYWJzdHJhY3QgY2xhc3MgRnVuY3Rpb25hbEV4cHJlc3Npb24gZXh0
ZW5kcyBOdWxsTGl0ZXJhbCB7CitwdWJsaWMgYWJzdHJhY3QgY2xhc3MgRnVuY3Rpb25hbEV4cHJl
c3Npb24gZXh0ZW5kcyBFeHByZXNzaW9uIHsKIAkKIAlUeXBlQmluZGluZyBleHBlY3RlZFR5cGU7
CiAKIAlwdWJsaWMgRnVuY3Rpb25hbEV4cHJlc3Npb24oaW50IHN0YXJ0LCBpbnQgZW5kKSB7Ci0J
CXN1cGVyKHN0YXJ0LCBlbmQpOworCQl0aGlzLnNvdXJjZVN0YXJ0ID0gc3RhcnQ7CisJCXRoaXMu
c291cmNlRW5kID0gZW5kOwogCX0KLQkKKwogCXB1YmxpYyB2b2lkIHNldEV4cGVjdGVkVHlwZShU
eXBlQmluZGluZyBleHBlY3RlZFR5cGUpIHsKIAkJdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3Rl
ZFR5cGU7CiAJfQpAQCAtNDEsNCArNDYsMjcgQEAKIAkJcmV0dXJuIHRoaXMuZXhwZWN0ZWRUeXBl
OwogCX0KIAorCXB1YmxpYyBpbnQgbnVsbFN0YXR1cyhGbG93SW5mbyBmbG93SW5mbykgeworCQly
ZXR1cm4gRmxvd0luZm8uTk9OX05VTEw7CisJfQorCisJcHVibGljIE9iamVjdCByZXVzYWJsZUpT
UlRhcmdldCgpIHsKKwkJcmV0dXJuIFR5cGVCaW5kaW5nLk5VTEw7CisJfQorCisJLyoKKwkgKiBU
T0RPOiBUaGlzIHNob3VsZCBnbyBhd2F5IG9uY2UgdGhlIHJlYWwgc3ViY2xhc3NlcyBpbXBsZW1l
bnQgCisJICoKKwkgKiBAcGFyYW0gY3VycmVudFNjb3BlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5h
bC5jb21waWxlci5sb29rdXAuQmxvY2tTY29wZQorCSAqIEBwYXJhbSBjb2RlU3RyZWFtIG9yZy5l
Y2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5jb2RlZ2VuLkNvZGVTdHJlYW0KKwkgKiBAcGFy
YW0gdmFsdWVSZXF1aXJlZCBib29sZWFuCisJICovCisJcHVibGljIHZvaWQgZ2VuZXJhdGVDb2Rl
KEJsb2NrU2NvcGUgY3VycmVudFNjb3BlLCBDb2RlU3RyZWFtIGNvZGVTdHJlYW0sIGJvb2xlYW4g
dmFsdWVSZXF1aXJlZCkgeworCQlpbnQgcGMgPSBjb2RlU3RyZWFtLnBvc2l0aW9uOworCQlpZiAo
dmFsdWVSZXF1aXJlZCkgeworCQkJY29kZVN0cmVhbS5hY29uc3RfbnVsbCgpOyAvLyBUT0RPOiBS
ZWFsIGNvZGUKKwkJfQorCQljb2RlU3RyZWFtLnJlY29yZFBvc2l0aW9uc0Zyb20ocGMsIHRoaXMu
c291cmNlU3RhcnQpOworCX0KKwkKIH0=
</data>

          </attachment>
          <attachment
              isobsolete="1"
              ispatch="0"
              isprivate="0"
          >
            <attachid>226356</attachid>
            <date>2013-01-30 19:23:00 -0500</date>
            <delta_ts>2013-02-01 01:08:30 -0500</delta_ts>
            <desc>Actual activation of the semantic analysis inside the lambda expression</desc>
            <filename>file_382701.txt</filename>
            <type>text/plain</type>
            <size>12023</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUu
dGVzdHMuY29tcGlsZXINCmRpZmYgLS1naXQgc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3Rz
L2NvbXBpbGVyL3JlZ3Jlc3Npb24vTmVnYXRpdmVMYW1iZGFFeHByZXNzaW9uc1Rlc3QuamF2YSBz
cmMvb3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9OZWdhdGl2
ZUxhbWJkYUV4cHJlc3Npb25zVGVzdC5qYXZhDQppbmRleCA0NjE0NGE1Li5lNzYxNzVmIDEwMDY0
NA0KLS0tIHNyYy9vcmcvZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9u
L05lZ2F0aXZlTGFtYmRhRXhwcmVzc2lvbnNUZXN0LmphdmENCisrKyBzcmMvb3JnL2VjbGlwc2Uv
amR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9OZWdhdGl2ZUxhbWJkYUV4cHJlc3Np
b25zVGVzdC5qYXZhDQpAQCAtMSw1ICsxLDUgQEANCiAvKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKg0K
LSAqIENvcHlyaWdodCAoYykgMjAxMSwgMjAxMiBJQk0gQ29ycG9yYXRpb24gYW5kIG90aGVycy4N
CisgKiBDb3B5cmlnaHQgKGMpIDIwMTEsIDIwMTMgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMu
DQogICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55
aW5nIG1hdGVyaWFscw0KICAqIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGUgdGVybXMgb2Yg
dGhlIEVjbGlwc2UgUHVibGljIExpY2Vuc2UgdjEuMA0KICAqIHdoaWNoIGFjY29tcGFuaWVzIHRo
aXMgZGlzdHJpYnV0aW9uLCBhbmQgaXMgYXZhaWxhYmxlIGF0DQpAQCAtMTEsNiArMTEsOCBAQA0K
ICAqIA0KICAqIENvbnRyaWJ1dG9yczoNCiAgKiAgICAgSUJNIENvcnBvcmF0aW9uIC0gaW5pdGlh
bCBBUEkgYW5kIGltcGxlbWVudGF0aW9uDQorICogICAgIEplc3BlciBTIE1vbGxlciAtIENvbnRy
aWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJYnVnIDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBs
ZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMgb2YgTGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNl
IGV4cHJlc3Npb24NCiAgDQogICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovDQogcGFja2FnZSBvcmcu
ZWNsaXBzZS5qZHQuY29yZS50ZXN0cy5jb21waWxlci5yZWdyZXNzaW9uOw0KQEAgLTIxOSwxNCAr
MjIxLDE0IEBADQogCQkJCQkifVxuIiArDQogCQkJCQkicHVibGljIGNsYXNzIFgge1xuIiArDQog
CQkJCQkiICBwdWJsaWMgdm9pZCB0ZXN0MShpbnQgeCkge1xuIiArDQotCQkJCQkiICAgIEFjdGlv
bkxpc3RlbmVyIGFsID0gKHB1YmxpYyB4eXopIC0+IFN5c3RlbS5vdXQucHJpbnRsbihlKTsgXG4i
ICsNCisJCQkJCSIgICAgQWN0aW9uTGlzdGVuZXIgYWwgPSAocHVibGljIHh5eikgLT4gU3lzdGVt
Lm91dC5wcmludGxuKHh5eik7IFxuIiArDQogCQkJCQkiICAgIEkgZiA9IChhYnN0cmFjdCBmaW5h
bCBzLCBATnVsbGFibGUgdCkgLT4gU3lzdGVtLm91dC5wcmludGxuKHMgKyB0KTsgXG4iICsNCiAJ
CQkJCSIgIH1cbiIgKw0KIAkJCQkJIn1cbiIsDQogCQkJCX0sDQogCQkJCSItLS0tLS0tLS0tXG4i
ICsgDQogCQkJCSIxLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgNylcbiIgKyANCi0JCQkJIglB
Y3Rpb25MaXN0ZW5lciBhbCA9IChwdWJsaWMgeHl6KSAtPiBTeXN0ZW0ub3V0LnByaW50bG4oZSk7
IFxuIiArIA0KKwkJCQkiCUFjdGlvbkxpc3RlbmVyIGFsID0gKHB1YmxpYyB4eXopIC0+IFN5c3Rl
bS5vdXQucHJpbnRsbih4eXopOyBcbiIgKyANCiAJCQkJIgkgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgXl5eXG4iICsgDQogCQkJCSJTeW50YXggZXJyb3IsIG1vZGlmaWVycyBhbmQgYW5ub3Rh
dGlvbnMgYXJlIG5vdCBhbGxvd2VkIGZvciB0aGUgbGFtYmRhIHBhcmFtZXRlciB4eXogYXMgaXRz
IHR5cGUgaXMgZWxpZGVkXG4iICsgDQogCQkJCSItLS0tLS0tLS0tXG4iICsgDQojUCBvcmcuZWNs
aXBzZS5qZHQuY29yZQ0KZGlmZiAtLWdpdCBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJu
YWwvY29tcGlsZXIvYXN0L0Z1bmN0aW9uYWxFeHByZXNzaW9uLmphdmEgY29tcGlsZXIvb3JnL2Vj
bGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9GdW5jdGlvbmFsRXhwcmVzc2lvbi5qYXZh
DQppbmRleCA2MDk2OGZmLi40ZDEwMWVjIDEwMDY0NA0KLS0tIGNvbXBpbGVyL29yZy9lY2xpcHNl
L2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvRnVuY3Rpb25hbEV4cHJlc3Npb24uamF2YQ0KKysr
IGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvRnVuY3Rpb25h
bEV4cHJlc3Npb24uamF2YQ0KQEAgLTM0LDYgKzM0LDEwIEBADQogCXB1YmxpYyB2b2lkIHNldEV4
cGVjdGVkVHlwZShUeXBlQmluZGluZyBleHBlY3RlZFR5cGUpIHsNCiAJCXRoaXMuZXhwZWN0ZWRU
eXBlID0gZXhwZWN0ZWRUeXBlOw0KIAl9DQorDQorCXB1YmxpYyBUeXBlQmluZGluZyBleHBlY3Rl
ZFR5cGUoKSB7DQorCQlyZXR1cm4gdGhpcy5leHBlY3RlZFR5cGU7DQorCX0NCiAJDQogCXB1Ymxp
YyBUeXBlQmluZGluZyByZXNvbHZlVHlwZShCbG9ja1Njb3BlIGJsb2NrU2NvcGUpIHsNCiAJCXRo
aXMuY29uc3RhbnQgPSBDb25zdGFudC5Ob3RBQ29uc3RhbnQ7DQpkaWZmIC0tZ2l0IGNvbXBpbGVy
L29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTGFtYmRhRXhwcmVzc2lvbi5q
YXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTGFtYmRh
RXhwcmVzc2lvbi5qYXZhDQppbmRleCAyY2Q1OTE0Li5kZGNkMGE5IDEwMDY0NA0KLS0tIGNvbXBp
bGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTGFtYmRhRXhwcmVzc2lv
bi5qYXZhDQorKysgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2Fz
dC9MYW1iZGFFeHByZXNzaW9uLmphdmENCkBAIC0xNiwyMSArMTYsNzAgQEANCiAgKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxl
ci5hc3Q7DQogDQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5jb3JlLmNvbXBpbGVyLkNhdGVnb3Jp
emVkUHJvYmxlbTsNCitpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLkNv
bXBpbGF0aW9uUmVzdWx0Ow0KK2ltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGls
ZXIuaW1wbC5SZWZlcmVuY2VDb250ZXh0Ow0KIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJu
YWwuY29tcGlsZXIubG9va3VwLkJsb2NrU2NvcGU7DQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5p
bnRlcm5hbC5jb21waWxlci5sb29rdXAuTWV0aG9kQmluZGluZzsNCitpbXBvcnQgb3JnLmVjbGlw
c2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5NZXRob2RTY29wZTsNCiBpbXBvcnQgb3Jn
LmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5UeXBlQmluZGluZzsNCitpbXBv
cnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLnByb2JsZW0uQWJvcnRDb21waWxh
dGlvbjsNCitpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLnByb2JsZW0u
QWJvcnRDb21waWxhdGlvblVuaXQ7DQoraW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5j
b21waWxlci5wcm9ibGVtLkFib3J0TWV0aG9kOw0KK2ltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50
ZXJuYWwuY29tcGlsZXIucHJvYmxlbS5BYm9ydFR5cGU7DQoraW1wb3J0IG9yZy5lY2xpcHNlLmpk
dC5pbnRlcm5hbC5jb21waWxlci5wcm9ibGVtLlByb2JsZW1TZXZlcml0aWVzOw0KIA0KLXB1Ymxp
YyBjbGFzcyBMYW1iZGFFeHByZXNzaW9uIGV4dGVuZHMgRnVuY3Rpb25hbEV4cHJlc3Npb24gew0K
K3B1YmxpYyBjbGFzcyBMYW1iZGFFeHByZXNzaW9uIGV4dGVuZHMgRnVuY3Rpb25hbEV4cHJlc3Np
b24gaW1wbGVtZW50cyBQcm9ibGVtU2V2ZXJpdGllcywgUmVmZXJlbmNlQ29udGV4dCB7DQogCUFy
Z3VtZW50IFtdIGFyZ3VtZW50czsNCiAJU3RhdGVtZW50IGJvZHk7DQorCXByaXZhdGUgTWV0aG9k
U2NvcGUgc2NvcGU7DQorCXByaXZhdGUgQ29tcGlsYXRpb25SZXN1bHQgY29tcGlsYXRpb25SZXN1
bHQ7DQorCXByaXZhdGUgYm9vbGVhbiBpZ25vcmVGdXJ0aGVySW52ZXN0aWdhdGlvbjsNCiAJDQot
CXB1YmxpYyBMYW1iZGFFeHByZXNzaW9uKEFyZ3VtZW50IFtdIGFyZ3VtZW50cywgU3RhdGVtZW50
IGJvZHkpIHsNCisJcHVibGljIExhbWJkYUV4cHJlc3Npb24oQ29tcGlsYXRpb25SZXN1bHQgY29t
cGlsYXRpb25SZXN1bHQsIEFyZ3VtZW50IFtdIGFyZ3VtZW50cywgU3RhdGVtZW50IGJvZHkpIHsN
CisJCXRoaXMuY29tcGlsYXRpb25SZXN1bHQgPSBjb21waWxhdGlvblJlc3VsdDsNCiAJCXRoaXMu
YXJndW1lbnRzID0gYXJndW1lbnRzOw0KIAkJdGhpcy5ib2R5ID0gYm9keTsNCiAJfQ0KIAkNCiAJ
cHVibGljIFR5cGVCaW5kaW5nIHJlc29sdmVUeXBlKEJsb2NrU2NvcGUgYmxvY2tTY29wZSkgew0K
IAkJc3VwZXIucmVzb2x2ZVR5cGUoYmxvY2tTY29wZSk7DQotCQlyZXR1cm4gVHlwZUJpbmRpbmcu
TlVMTDsNCisJCXRoaXMuc2NvcGUgPSBuZXcgTWV0aG9kU2NvcGUoYmxvY2tTY29wZSwgdGhpcywg
YmxvY2tTY29wZS5tZXRob2RTY29wZSgpLmlzU3RhdGljKTsNCisNCisJCVR5cGVCaW5kaW5nIGV4
cGVjdGVkID0gdGhpcy5leHBlY3RlZFR5cGUoKTsNCisJCWlmIChleHBlY3RlZCA9PSBudWxsKSBy
ZXR1cm4gVHlwZUJpbmRpbmcuTlVMTDsNCisNCisJCU1ldGhvZEJpbmRpbmcgc2luZ2xlQWJzdHJh
Y3RNZXRob2QgPSBleHBlY3RlZC5nZXRTaW5nbGVBYnN0cmFjdE1ldGhvZCgpOw0KKwkJaWYgKHRo
aXMuYXJndW1lbnRzICE9IG51bGwgJiYgc2luZ2xlQWJzdHJhY3RNZXRob2QgIT0gbnVsbCkgew0K
KwkJCWludCBwYXJhbWV0ZXJDb3VudCA9IHNpbmdsZUFic3RyYWN0TWV0aG9kLnBhcmFtZXRlcnMg
IT0gbnVsbCA/IHNpbmdsZUFic3RyYWN0TWV0aG9kLnBhcmFtZXRlcnMubGVuZ3RoIDogMDsNCisJ
CQlpbnQgbGFtYmRhQXJndW1lbnRDb3VudCA9IHRoaXMuYXJndW1lbnRzICE9IG51bGwgPyB0aGlz
LmFyZ3VtZW50cy5sZW5ndGggOiAwOw0KKw0KKwkJCWlmIChwYXJhbWV0ZXJDb3VudCA9PSBsYW1i
ZGFBcmd1bWVudENvdW50KSB7DQorCQkJCWZvciAoaW50IGkgPSAwLCBsZW5ndGggPSB0aGlzLmFy
Z3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykgew0KKwkJCQkJQXJndW1lbnQgYXJndW1l
bnQgPSB0aGlzLmFyZ3VtZW50c1tpXTsNCisJCQkJCWlmIChhcmd1bWVudC50eXBlICE9IG51bGwp
IHsNCisJCQkJCQlhcmd1bWVudC5yZXNvbHZlKHRoaXMuc2NvcGUpOyAvLyBUT0RPOiBDaGVjayBp
dCENCisJCQkJCX0gZWxzZSB7DQorCQkJCQkJYXJndW1lbnQuYmluZCh0aGlzLnNjb3BlLCBzaW5n
bGVBYnN0cmFjdE1ldGhvZC5wYXJhbWV0ZXJzW2ldLCBmYWxzZSk7DQorCQkJCQl9DQorCQkJCX0N
CisJCQl9IC8qIFRPRE86IGVsc2UgY29tcGxhaW4gKi8NCisJCX0NCisJCWlmICh0aGlzLmJvZHkg
aW5zdGFuY2VvZiBFeHByZXNzaW9uKSB7DQorCQkJRXhwcmVzc2lvbiBleHByZXNzaW9uID0gKEV4
cHJlc3Npb24pIHRoaXMuYm9keTsNCisJCQlpZiAoc2luZ2xlQWJzdHJhY3RNZXRob2QgIT0gbnVs
bCkgew0KKwkJCQkvLyBJbmRlZWQsIHRoZSBleHByZXNzaW9uIHBhcnQgb2YgYSBMYW1iZGEgaXMg
YW4gYWxsb3dhYmxlIExhbWJkYSBjb250ZXh0LCBhcyBpbjoNCisJCQkJLy8gRnVuY3Rpb248cGFy
dGlhbEFkZGVyID0geCAtPiB5IC0+IHgreQ0KKwkJCQkvLyBTbywgd2Ugc2V0IHRoZSBleHBlY3Rl
ZCB0eXBlIG9mIHRoZSBzaW5nbGUgZXhwcmVzc2lvbg0KKwkJCQlleHByZXNzaW9uLnNldEV4cGVj
dGVkVHlwZShzaW5nbGVBYnN0cmFjdE1ldGhvZC5yZXR1cm5UeXBlKTsNCisJCQkJLyogVHlwZUJp
bmRpbmcgZXhwcmVzc2lvblR5cGUgPSAqLyBleHByZXNzaW9uLnJlc29sdmVUeXBlKHRoaXMuc2Nv
cGUpOw0KKwkJCQkvLyBUT0RPOiBjaGVja0V4cHJlc3Npb25SZXN1bHQoc2luZ2xlQWJzdHJhY3RN
ZXRob2QucmV0dXJuVHlwZSwgZXhwcmVzc2lvbiwgZXhwcmVzc2lvblR5cGUpOw0KKwkJCX0NCisJ
CX0gZWxzZSB7DQorCQkJLy8gaWYgbm9uLXZvaWQsIGNoZWNrIHRoYXQgYSB2YWx1ZSBpcyByZXR1
cm5lZA0KKwkJCXRoaXMuYm9keS5yZXNvbHZlKHRoaXMuc2NvcGUpOw0KKwkJfQ0KKwkJcmV0dXJu
IGV4cGVjdGVkOw0KIAl9DQogDQogCXB1YmxpYyBTdHJpbmdCdWZmZXIgcHJpbnRFeHByZXNzaW9u
KGludCB0YWIsIFN0cmluZ0J1ZmZlciBvdXRwdXQpIHsNCkBAIC01MSw0ICsxMDAsNDQgQEANCiAJ
CXRoaXMuYm9keS5wcmludCh0aGlzLmJvZHkgaW5zdGFuY2VvZiBCbG9jayA/IHRhYiA6IDAsIG91
dHB1dCk7DQogCQlyZXR1cm4gb3V0cHV0LmFwcGVuZChzdWZmaXgpOw0KIAl9DQorDQorCS8vIFRo
ZSByZXN0IGlzIGEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIFJlZmVyZW5jZUNvbnRleHQNCisJ
cHVibGljIENvbXBpbGF0aW9uUmVzdWx0IGNvbXBpbGF0aW9uUmVzdWx0KCkgew0KKwkJcmV0dXJu
IHRoaXMuY29tcGlsYXRpb25SZXN1bHQ7DQorCX0NCisJDQorCXB1YmxpYyB2b2lkIGFib3J0KGlu
dCBhYm9ydExldmVsLCBDYXRlZ29yaXplZFByb2JsZW0gcHJvYmxlbSkgew0KKw0KKwkJc3dpdGNo
IChhYm9ydExldmVsKSB7DQorCQkJY2FzZSBBYm9ydENvbXBpbGF0aW9uIDoNCisJCQkJdGhyb3cg
bmV3IEFib3J0Q29tcGlsYXRpb24odGhpcy5jb21waWxhdGlvblJlc3VsdCwgcHJvYmxlbSk7DQor
CQkJY2FzZSBBYm9ydENvbXBpbGF0aW9uVW5pdCA6DQorCQkJCXRocm93IG5ldyBBYm9ydENvbXBp
bGF0aW9uVW5pdCh0aGlzLmNvbXBpbGF0aW9uUmVzdWx0LCBwcm9ibGVtKTsNCisJCQljYXNlIEFi
b3J0VHlwZSA6DQorCQkJCXRocm93IG5ldyBBYm9ydFR5cGUodGhpcy5jb21waWxhdGlvblJlc3Vs
dCwgcHJvYmxlbSk7DQorCQkJZGVmYXVsdCA6DQorCQkJCXRocm93IG5ldyBBYm9ydE1ldGhvZCh0
aGlzLmNvbXBpbGF0aW9uUmVzdWx0LCBwcm9ibGVtKTsNCisJCX0NCisJfQ0KKw0KKwlwdWJsaWMg
Q29tcGlsYXRpb25Vbml0RGVjbGFyYXRpb24gZ2V0Q29tcGlsYXRpb25Vbml0RGVjbGFyYXRpb24o
KSB7DQorCQlpZiAodGhpcy5zY29wZSAhPSBudWxsKSB7DQorCQkJcmV0dXJuIHRoaXMuc2NvcGUu
Y29tcGlsYXRpb25Vbml0U2NvcGUoKS5yZWZlcmVuY2VDb250ZXh0Ow0KKwkJfQ0KKwkJcmV0dXJu
IG51bGw7DQorCX0NCisNCisJcHVibGljIGJvb2xlYW4gaGFzRXJyb3JzKCkgew0KKwkJcmV0dXJu
IHRoaXMuaWdub3JlRnVydGhlckludmVzdGlnYXRpb247DQorCX0NCisNCisJcHVibGljIHZvaWQg
dGFnQXNIYXZpbmdFcnJvcnMoKSB7DQorCQl0aGlzLmlnbm9yZUZ1cnRoZXJJbnZlc3RpZ2F0aW9u
ID0gdHJ1ZTsNCisJfQ0KKw0KKwlwdWJsaWMgVHlwZUJpbmRpbmcgZXhwZWN0ZWRSZXN1bHRUeXBl
KCkgew0KKwkJTWV0aG9kQmluZGluZyBzaW5nbGVBYnN0cmFjdE1ldGhvZCA9IGV4cGVjdGVkVHlw
ZSgpLmdldFNpbmdsZUFic3RyYWN0TWV0aG9kKCk7DQorCQlpZiAoc2luZ2xlQWJzdHJhY3RNZXRo
b2QgIT0gbnVsbCkgcmV0dXJuIHNpbmdsZUFic3RyYWN0TWV0aG9kLnJldHVyblR5cGU7DQorCQly
ZXR1cm4gVHlwZUJpbmRpbmcuTlVMTDsNCisJfQ0KIH0NCmRpZmYgLS1naXQgY29tcGlsZXIvb3Jn
L2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9SZXR1cm5TdGF0ZW1lbnQuamF2YSBj
b21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L1JldHVyblN0YXRl
bWVudC5qYXZhDQppbmRleCA1M2VkMzU1Li5iY2YyOTBmIDEwMDY0NA0KLS0tIGNvbXBpbGVyL29y
Zy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmV0dXJuU3RhdGVtZW50LmphdmEN
CisrKyBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L1JldHVy
blN0YXRlbWVudC5qYXZhDQpAQCAtMjEsNiArMjEsOCBAQA0KICAqCQkJCQkJCQlidWcgMzQ1MzA1
IC0gW2NvbXBpbGVyXVtudWxsXSBDb21waWxlciBtaXNpZGVudGlmaWVzIGEgY2FzZSBvZiAidmFy
aWFibGUgY2FuIG9ubHkgYmUgbnVsbCINCiAgKgkJCQkJCQkJYnVnIDM4ODk5NiAtIFtjb21waWxl
cl1bcmVzb3VyY2VdIEluY29ycmVjdCAncG90ZW50aWFsIHJlc291cmNlIGxlYWsnDQogICoJCQkJ
CQkJCWJ1ZyAzOTQ3NjggLSBbY29tcGlsZXJdW3Jlc291cmNlXSBJbmNvcnJlY3QgcmVzb3VyY2Ug
bGVhayB3YXJuaW5nIHdoZW4gY3JlYXRpbmcgc3RyZWFtIGluIGNvbmRpdGlvbmFsDQorICogICAg
IEplc3BlciBTIE1vbGxlciAtIENvbnRyaWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJYnVnIDM4Mjcw
MSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMgb2YgTGFtYmRh
IGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4cHJlc3Npb24NCiAgKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5hc3Q7DQog
DQpAQCAtMjU5LDYgKzI2MSw3IEBADQogCU1ldGhvZFNjb3BlIG1ldGhvZFNjb3BlID0gc2NvcGUu
bWV0aG9kU2NvcGUoKTsNCiAJTWV0aG9kQmluZGluZyBtZXRob2RCaW5kaW5nOw0KIAlUeXBlQmlu
ZGluZyBtZXRob2RUeXBlID0NCisJCShtZXRob2RTY29wZS5yZWZlcmVuY2VDb250ZXh0IGluc3Rh
bmNlb2YgTGFtYmRhRXhwcmVzc2lvbikgPyAoKExhbWJkYUV4cHJlc3Npb24pIG1ldGhvZFNjb3Bl
LnJlZmVyZW5jZUNvbnRleHQpLmV4cGVjdGVkUmVzdWx0VHlwZSgpIDoNCiAJCShtZXRob2RTY29w
ZS5yZWZlcmVuY2VDb250ZXh0IGluc3RhbmNlb2YgQWJzdHJhY3RNZXRob2REZWNsYXJhdGlvbikN
CiAJCQk/ICgobWV0aG9kQmluZGluZyA9ICgoQWJzdHJhY3RNZXRob2REZWNsYXJhdGlvbikgbWV0
aG9kU2NvcGUucmVmZXJlbmNlQ29udGV4dCkuYmluZGluZykgPT0gbnVsbA0KIAkJCQk/IG51bGwN
CmRpZmYgLS1naXQgY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xv
b2t1cC9NZXRob2RTY29wZS5qYXZhIGNvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9j
b21waWxlci9sb29rdXAvTWV0aG9kU2NvcGUuamF2YQ0KaW5kZXggZWI4MTMyMS4uMjllZjZhNiAx
MDA2NDQNCi0tLSBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9v
a3VwL01ldGhvZFNjb3BlLmphdmENCisrKyBjb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJu
YWwvY29tcGlsZXIvbG9va3VwL01ldGhvZFNjb3BlLmphdmENCkBAIC0xNiw2ICsxNiw4IEBADQog
ICoJCQkJCQkJCWJ1ZyAzNzQ2MDUgLSBVbnJlYXNvbmFibGUgd2FybmluZyBmb3IgZW51bS1iYXNl
ZCBzd2l0Y2ggc3RhdGVtZW50cw0KICAqCQkJCQkJCQlidWcgMzgyMzUzIC0gWzEuOF1bY29tcGls
ZXJdIEltcGxlbWVudGF0aW9uIHByb3BlcnR5IG1vZGlmaWVycyBzaG91bGQgYmUgYWNjZXB0ZWQg
b24gZGVmYXVsdCBtZXRob2RzLg0KICAqCQkJCQkJCQlidWcgMzgyMzU0IC0gWzEuOF1bY29tcGls
ZXJdIENvbXBpbGVyIHNpbGVudCBvbiBjb25mbGljdGluZyBtb2RpZmllcg0KKyAqICAgICBKZXNw
ZXIgUyBNb2xsZXIgLSBDb250cmlidXRpb25zIGZvcg0KKyAqCQkJCQkJCWJ1ZyAzODI3MDEgLSBb
MS44XVtjb21waWxlcl0gSW1wbGVtZW50IHNlbWFudGljIGFuYWx5c2lzIG9mIExhbWJkYSBleHBy
ZXNzaW9ucyAmIFJlZmVyZW5jZSBleHByZXNzaW9uDQogICoqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiov
DQogcGFja2FnZSBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwOw0KIA0K
QEAgLTYzLDcgKzY1LDcgQEANCiAJLy8gcmVtZW1iZXIgc3VwcHJlc3NlZCB3YXJuaW5nIHJlIG1p
c3NpbmcgJ2RlZmF1bHQ6JyB0byBnaXZlIGhpbnRzIG9uIHBvc3NpYmx5IHJlbGF0ZWQgZmxvdyBw
cm9ibGVtcw0KIAlwdWJsaWMgYm9vbGVhbiBoYXNNaXNzaW5nU3dpdGNoRGVmYXVsdDsgLy8gVE9E
TyhzdGVwaGFuKTogY29tYmluZSBmbGFncyB0byBhIGJpdHNldD8NCiANCi1wdWJsaWMgTWV0aG9k
U2NvcGUoQ2xhc3NTY29wZSBwYXJlbnQsIFJlZmVyZW5jZUNvbnRleHQgY29udGV4dCwgYm9vbGVh
biBpc1N0YXRpYykgew0KK3B1YmxpYyBNZXRob2RTY29wZShTY29wZSBwYXJlbnQsIFJlZmVyZW5j
ZUNvbnRleHQgY29udGV4dCwgYm9vbGVhbiBpc1N0YXRpYykgew0KIAlzdXBlcihNRVRIT0RfU0NP
UEUsIHBhcmVudCk7DQogCXRoaXMubG9jYWxzID0gbmV3IExvY2FsVmFyaWFibGVCaW5kaW5nWzVd
Ow0KIAl0aGlzLnJlZmVyZW5jZUNvbnRleHQgPSBjb250ZXh0Ow0KZGlmZiAtLWdpdCBjb21waWxl
ci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvcGFyc2VyL1BhcnNlci5qYXZhIGNv
bXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wYXJzZXIvUGFyc2VyLmph
dmENCmluZGV4IDE2ZTIxYmIuLjA2YjQ5ZjEgMTAwNjQ0DQotLS0gY29tcGlsZXIvb3JnL2VjbGlw
c2UvamR0L2ludGVybmFsL2NvbXBpbGVyL3BhcnNlci9QYXJzZXIuamF2YQ0KKysrIGNvbXBpbGVy
L29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9wYXJzZXIvUGFyc2VyLmphdmENCkBA
IC0xNiw2ICsxNiw4IEBADQogICoJCQkJCQkJCWJ1ZyAzNjYwMDMgLSBDQ0UgaW4gQVNUTm9kZS5y
ZXNvbHZlQW5ub3RhdGlvbnMoQVNUTm9kZS5qYXZhOjYzOSkNCiAgKgkJCQkJCQkJYnVnIDM3NDYw
NSAtIFVucmVhc29uYWJsZSB3YXJuaW5nIGZvciBlbnVtLWJhc2VkIHN3aXRjaCBzdGF0ZW1lbnRz
DQogICoJCQkJCQkJCWJ1ZyAzODIzNTMgLSBbMS44XVtjb21waWxlcl0gSW1wbGVtZW50YXRpb24g
cHJvcGVydHkgbW9kaWZpZXJzIHNob3VsZCBiZSBhY2NlcHRlZCBvbiBkZWZhdWx0IG1ldGhvZHMu
DQorICogICAgIEplc3BlciBTIE1vbGxlciAtIENvbnRyaWJ1dGlvbnMgZm9yDQorICoJCQkJCQkJ
YnVnIDM4MjcwMSAtIFsxLjhdW2NvbXBpbGVyXSBJbXBsZW1lbnQgc2VtYW50aWMgYW5hbHlzaXMg
b2YgTGFtYmRhIGV4cHJlc3Npb25zICYgUmVmZXJlbmNlIGV4cHJlc3Npb24NCiAgKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKi8NCiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxl
ci5wYXJzZXI7DQogDQpAQCAtNzcwNSw3ICs3NzA3LDcgQEANCiAJCQlwcm9ibGVtUmVwb3J0ZXIo
KS5pbGxlZ2FsVGhpcyhhcmd1bWVudHNbaV0pOw0KIAkJfQ0KIAl9DQotCUxhbWJkYUV4cHJlc3Np
b24gbGV4cCA9IG5ldyBMYW1iZGFFeHByZXNzaW9uKGFyZ3VtZW50cywgYm9keSk7DQorCUxhbWJk
YUV4cHJlc3Npb24gbGV4cCA9IG5ldyBMYW1iZGFFeHByZXNzaW9uKHRoaXMuY29tcGlsYXRpb25V
bml0LmNvbXBpbGF0aW9uUmVzdWx0LCBhcmd1bWVudHMsIGJvZHkpOw0KIAl0aGlzLmludFB0ci0t
OyAgLy8gJyknIHBvc2l0aW9uLCBkaXNjYXJkIGZvciBub3cuDQogCWxleHAuc291cmNlU3RhcnQg
PSB0aGlzLmludFN0YWNrW3RoaXMuaW50UHRyLS1dOyAvLyAnKCcgcG9zaXRpb24gb3IgaWRlbnRp
ZmllciBwb3NpdGlvbi4NCiAJbGV4cC5zb3VyY2VFbmQgPSBib2R5LnNvdXJjZUVuZDsNCiA=
</data>

          </attachment>
          <attachment
              isobsolete="1"
              ispatch="0"
              isprivate="0"
          >
            <attachid>226357</attachid>
            <date>2013-01-30 20:16:00 -0500</date>
            <delta_ts>2013-02-01 03:33:19 -0500</delta_ts>
            <desc>Test case for basic semantic tests in lambdas</desc>
            <filename>file_382701.txt</filename>
            <type>text/plain</type>
            <size>3462</size>
            <attacher name="Jesper Moller">jesper</attacher>
            
              <data encoding="base64">IyMjIEVjbGlwc2UgV29ya3NwYWNlIFBhdGNoIDEuMA0KI1Agb3JnLmVjbGlwc2UuamR0LmNvcmUu
dGVzdHMuY29tcGlsZXINCmRpZmYgLS1naXQgc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3Rz
L2NvbXBpbGVyL3JlZ3Jlc3Npb24vTmVnYXRpdmVMYW1iZGFFeHByZXNzaW9uc1Rlc3QuamF2YSBz
cmMvb3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9OZWdhdGl2
ZUxhbWJkYUV4cHJlc3Npb25zVGVzdC5qYXZhDQppbmRleCBlNzYxNzVmLi5iNjlhZWEyIDEwMDY0
NA0KLS0tIHNyYy9vcmcvZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9u
L05lZ2F0aXZlTGFtYmRhRXhwcmVzc2lvbnNUZXN0LmphdmENCisrKyBzcmMvb3JnL2VjbGlwc2Uv
amR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9OZWdhdGl2ZUxhbWJkYUV4cHJlc3Np
b25zVGVzdC5qYXZhDQpAQCAtMjY2LDYgKzI2Niw3NiBAQA0KIAkJCQkiWm9yayBjYW5ub3QgYmUg
cmVzb2x2ZWQgdG8gYSB0eXBlXG4iICsgDQogCQkJCSItLS0tLS0tLS0tXG4iKTsNCiB9DQorLy9o
dHRwczovL2J1Z3MuZWNsaXBzZS5vcmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9MzgyNzAxLCBbMS44
XVtjb21waWxlcl0gSW1wbGVtZW50IHNlbWFudGljIGFuYWx5c2lzIG9mIExhbWJkYSBleHByZXNz
aW9ucyAmIFJlZmVyZW5jZSBleHByZXNzaW9ucy4NCitwdWJsaWMgdm9pZCB0ZXN0MDExKCkgew0K
KwkvLyBUaGlzIHRlc3QgY2hlY2tzIHRoYXQgY29tbW9uIHNlbWFudGljIGNoZWNrcyBhcmUgaW5k
ZWVkIA0KKwl0aGlzLnJ1bk5lZ2F0aXZlVGVzdCgNCisJCQluZXcgU3RyaW5nW10gew0KKwkJCQkJ
IlguamF2YSIsDQorCQkJCQkiaW50ZXJmYWNlIEkge1xuIiArDQorCQkJCQkiCU9iamVjdCBmb28o
aW50IFtdIGlhKTtcbiIgKw0KKwkJCQkJIn1cbiIgKw0KKwkJCQkJInB1YmxpYyBjbGFzcyBYIHtc
biIgKw0KKwkJCQkJIglJIGkgPSAoaW50IFtdIGlhKSAtPiB7XG4iICsNCisJCQkJCSIJCVpvcmsg
ejtcbiIgKyAgLy8gRXJyb3I6IE5vIHN1Y2ggdHlwZQ0KKwkJCQkJIgkJdW5rbm93biA9IDA7XG47
IiArIC8vIEVycm9yOiBObyBzdWNoIHZhcmlhYmxlDQorCQkJCQkiCQlpbnQgYSA9IDQyICsgaWE7
XG4iICsgLy8gRXJyb3I6IGludCArIGludFtdIGlzIHdyb25nIA0KKwkJCQkJIgkJcmV0dXJuIGlh
LmNsb25lKCk7XG4iICsNCisJCQkJCSIJfTtcbiIgKw0KKwkJCQkJIglzdGF0aWMgdm9pZCBzdGF0
aWNMYW1iZGEoKSB7XG4iICsNCisJCQkJCSIJCUkgaSA9IChpbnQgW10gaWEpIC0+IHRoaXM7XG4i
ICsgLy8gJ3RoaXMnIGlzIHN0YXRpYw0KKwkJCQkJIgl9XG4iICsNCisJCQkJCSIJSSBqID0gYXJy
YXkgLT4ge1xuIiArDQorCQkJCQkiCQlpbnQgYSA9IGFycmF5WzJdICsgMztcbiIgKyAvLyBObyBl
cnJvciwgaWEgbXVzdCBiZSBjb3JyZWN0bHkgaWRlbnRpZmllcyBhcyBpbnRbXQ0KKwkJCQkJIgkJ
aW50IGIgPSA0MiArIGFycmF5O1xuIiArIC8vIEVycm9yOiBpbnQgKyBpbnRbXSBpcyB3cm9uZyAt
IHllcyBpdCBpcyENCisJCQkJCSIJCVN5c3RlbS5vdXQucHJpbnRsbihcImkoYXJyYXkpID0gXCIg
KyBpLmZvbyhhcnJheSkpO1xuIiArIC8vIGZpZWxkcyBhcmUgYWNjZXNzaWJsZSENCisJCQkJCSIJ
CXJldHVybjtcbiIgKyAvLyBFcnJvciBoZXJlLCBleHBlY3RpbmcgT2JqZWN0LCBub3Qgdm9pZA0K
KwkJCQkJIgl9O1xuIiArDQorCQkJCQkiCVJ1bm5hYmxlIHIgPSAoKSAtPiB7IHJldHVybiA0Mjsg
fTtcbiIgKyAvLyBSdW5uYWJsZS5ydW4gbm90IGV4cGVjdGluZyByZXR1cm4gdmFsdWUNCisJCQkJ
CSIJdm9pZCBhbm90aGVyTGFtYmRhKCkge1xuIiArDQorCQkJCQkiCQlmaW5hbCBpbnQgYmVlZiA9
IDA7XG4iICsNCisJCQkJCSIJCUkgayA9IChpbnQgW10gYSkgLT4gYS5sZW5ndGggKyBiZWVmO1xu
IiArIC8vIE5vIGVycm9yLCBiZWVmIGlzIGluIHNjb3BlDQorCQkJCQkiCX1cbiIgKw0KKwkJCQkJ
In1cbiIsDQorCQkJCX0sDQorCQkJCSItLS0tLS0tLS0tXG4iICsgDQorCQkJCSIxLiBFUlJPUiBp
biBYLmphdmEgKGF0IGxpbmUgNilcbiIgKyANCisJCQkJIglab3JrIHo7XG4iICsgDQorCQkJCSIJ
Xl5eXlxuIiArIA0KKwkJCQkiWm9yayBjYW5ub3QgYmUgcmVzb2x2ZWQgdG8gYSB0eXBlXG4iICsg
DQorCQkJCSItLS0tLS0tLS0tXG4iICsgDQorCQkJCSIyLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxp
bmUgNylcbiIgKyANCisJCQkJIgl1bmtub3duID0gMDtcbiIgKyANCisJCQkJIgleXl5eXl5eXG4i
ICsgDQorCQkJCSJ1bmtub3duIGNhbm5vdCBiZSByZXNvbHZlZCB0byBhIHZhcmlhYmxlXG4iICsg
DQorCQkJCSItLS0tLS0tLS0tXG4iICsgDQorCQkJCSIzLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxp
bmUgOClcbiIgKyANCisJCQkJIgk7CQlpbnQgYSA9IDQyICsgaWE7XG4iICsgDQorCQkJCSIJIAkJ
ICAgICAgICBeXl5eXl5eXG4iICsgDQorCQkJCSJUaGUgb3BlcmF0b3IgKyBpcyB1bmRlZmluZWQg
Zm9yIHRoZSBhcmd1bWVudCB0eXBlKHMpIGludCwgaW50W11cbiIgKyANCisJCQkJIi0tLS0tLS0t
LS1cbiIgKyANCisJCQkJIjQuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSAxMilcbiIgKyANCisJ
CQkJIglJIGkgPSAoaW50IFtdIGlhKSAtPiB0aGlzO1xuIiArIA0KKwkJCQkiCSAgICAgICAgICAg
ICAgICAgICAgIF5eXl5cbiIgKyANCisJCQkJIkNhbm5vdCB1c2UgdGhpcyBpbiBhIHN0YXRpYyBj
b250ZXh0XG4iICsgDQorCQkJCSItLS0tLS0tLS0tXG4iICsNCisJCQkJIjUuIEVSUk9SIGluIFgu
amF2YSAoYXQgbGluZSAxNilcbiIgKyANCisJCQkJIglpbnQgYiA9IDQyICsgYXJyYXk7XG4iICsg
DQorCQkJCSIJICAgICAgICBeXl5eXl5eXl5eXG4iICsgDQorCQkJCSJUaGUgb3BlcmF0b3IgKyBp
cyB1bmRlZmluZWQgZm9yIHRoZSBhcmd1bWVudCB0eXBlKHMpIGludCwgaW50W11cbiIgKyANCisJ
CQkJIi0tLS0tLS0tLS1cbiIgKyANCisJCQkJIjYuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSAx
OClcbiIgKyANCisJCQkJIglyZXR1cm47XG4iICsgDQorCQkJCSIJXl5eXl5eXlxuIiArIA0KKwkJ
CQkiVGhpcyBtZXRob2QgbXVzdCByZXR1cm4gYSByZXN1bHQgb2YgdHlwZSBPYmplY3RcbiIgKw0K
KwkJCQkiLS0tLS0tLS0tLVxuIiArIA0KKwkJCQkiNy4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5l
IDIwKVxuIiArIA0KKwkJCQkiCVJ1bm5hYmxlIHIgPSAoKSAtPiB7IHJldHVybiA0MjsgfTtcbiIg
KyANCisJCQkJIgkgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXG4iICsgDQorCQkJCSJW
b2lkIG1ldGhvZHMgY2Fubm90IHJldHVybiBhIHZhbHVlXG4iICsgDQorCQkJCSItLS0tLS0tLS0t
XG4iDQorKTsNCit9DQogcHVibGljIHN0YXRpYyBDbGFzcyB0ZXN0Q2xhc3MoKSB7DQogCXJldHVy
biBOZWdhdGl2ZUxhbWJkYUV4cHJlc3Npb25zVGVzdC5jbGFzczsNCiB9
</data>

          </attachment>
      

    </bug>

</bugzilla>