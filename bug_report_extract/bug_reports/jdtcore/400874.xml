<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>400874</bug_id>
          
          <creation_ts>2013-02-14 22:46:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Inference infrastructure should evolve to meet JLS8 18.x (Part G of JSR335 spec)</short_desc>
          <delta_ts>2013-12-14 15:24:32 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.3</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          <dependson>400982</dependson>
    
    <dependson>401170</dependson>
    
    <dependson>403847</dependson>
    
    <dependson>404042</dependson>
    
    <dependson>418807</dependson>
    
    <dependson>419048</dependson>
    
    <dependson>423070</dependson>
          <blocked>380188</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>anchakrk</cc>
    
    <cc>daniel_megert</cc>
    
    <cc>incoming</cc>
    
    <cc>jarthana</cc>
    
    <cc>jesper</cc>
    
    <cc>kasperni</cc>
    
    <cc>markus_keller</cc>
    
    <cc>snorthov</cc>
          
          <votes>0</votes>

      

      

      <flag name="review"
          id="55972"
          type_id="1"
          status="?"
          setter="srikanth_sankaran"
          requestee="srikanth_sankaran"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2217160</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-14 22:46:35 -0500</bug_when>
    <thetext>BETA_JAVA8:

A number of changes are being made to type inference mechanism to
fix specification bugs, clarify issues, to address poly expressions
etc.

These are captured in section 18 of JLS8 - part G of JSR335 specification.
ECJ should evolve to cope with these changes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217161</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-14 22:48:26 -0500</bug_when>
    <thetext>Stephan, thanks for leading this effort - I am available to consult/discuss,
code review, or implement fixes for broken down tasks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217247</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-15 04:52:36 -0500</bug_when>
    <thetext>ack</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217713</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-16 18:20:01 -0500</bug_when>
    <thetext>Here&apos;s a first assessment after spending some time in and around the sub task bug 400982.

== CODE CHANGES: ==
This bug will require some heavy refactoring of our code, e.g.:

- during resolve we need to know whether any expression is a poly expression, which in turn requires knowledge about the context.
  -&gt; most obvious solution would be to replicate the &apos;valueRequired&apos; argument (from generateCode) into all &apos;resolveType&apos; methods throughout the AST.
  Time ago we had a similar request for analyseCode, but that refactoring has been voted down due to the risk involved.

- resolving of a MessageSend needs to propagate knowledge about argument expressions into locations like Scope.findMethod and PGMB.computeCompatibleMethod, which are AST agnostic.
  -&gt; easiest solution could be to extend the interface InvocationSite, which is a significant but manageable change.

With all the lifting of constraints from inner contexts to outer contexts, it&apos;s not even clear if a single tree-traversal is a good strategy for resolveType().
The informal discussion mentions two &quot;rounds&quot; of inference for finding the type of a method invocation.

== STATE OF THE SPEC: ==
While some parts of the spec make for a good read, I&apos;m worried about the incompleteness of the spec:
The main algorithm consists of these phases:
- building initial constraints and bounds
- reduction
- incorporation
- resolution
Of these four phases, less than two are actually specified as of 0.6.1. The two essential phases &quot;incorporation&quot; and &quot;resolution&quot; are sketched by mere place holders.
From my pov the spec of this algorithm is nowhere near the state to be implemented.
E.g., termination of the algorithm seems to be controlled by the notion of an inference variable being &quot;resolved&quot;, which is given by a type equality bound  = T.
I could find no location in the spec, however, that would actually reduce any given constraints to the required type equality bound.

== CONCLUSION: ==
To control the risks of the required refactorings, we wouldn&apos;t want to waste a single day before implementing, in order to keep a large margin for testing and fixing.
OTOH, I&apos;m very reluctant to spend much time in implementing an utterly unfinished spec.

I wish I had better news, but I don&apos;t.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217721</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-16 20:14:32 -0500</bug_when>
    <thetext>(In reply to comment #3)
&gt; Here&apos;s a first assessment after spending some time in and around the sub
&gt; task bug 400982.

[...]

&gt; To control the risks of the required refactorings, we wouldn&apos;t want to waste
&gt; a single day before implementing, in order to keep a large margin for
&gt; testing and fixing.
&gt; OTOH, I&apos;m very reluctant to spend much time in implementing an utterly
&gt; unfinished spec.
&gt; 
&gt; I wish I had better news, but I don&apos;t.

Stephan, could you eliminate the implementation concerns and share with
a note just about spec state and I&apos;ll forward it to the EG.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217727</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-16 23:45:05 -0500</bug_when>
    <thetext>(In reply to comment #3)
&gt; Here&apos;s a first assessment after spending some time in and around the sub
&gt; task bug 400982.
&gt; 
&gt; == CODE CHANGES: ==
&gt; This bug will require some heavy refactoring of our code, e.g.:
&gt; 
&gt; - during resolve we need to know whether any expression is a poly
&gt; expression, which in turn requires knowledge about the context.

For casting context, I introduced Expression.isPolyExpressionInCastingContext().
Don&apos;t know is such a simplistic solution is enough for all other contexs.

&gt; - resolving of a MessageSend needs to propagate knowledge about argument
&gt; expressions into locations like Scope.findMethod and
&gt; PGMB.computeCompatibleMethod, which are AST agnostic.
&gt;   -&gt; easiest solution could be to extend the interface InvocationSite, which
&gt; is a significant but manageable change.

In my early stage prototype for overload resolution, I had a solution
where for argument expressions that are polyexpressions in invocation context,
instead of calling resolveType, I invoke partialResolveType, which returns
a subtype object of ReferenceBinding which stores the ASTnode type.

This should avoid having to tunnel the ASTnodes to various places, but again, I 
don&apos;t know if that will lend well to other situations.

Before, any major refactoring/redesign: if you could post a short snippet
that shows the motivation/need along with a pointer to the relevant portion
of the spec, it can get the benefit of another pair of eyes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2217747</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-17 06:18:38 -0500</bug_when>
    <thetext>(In reply to comment #5)
&gt; For casting context, I introduced
&gt; Expression.isPolyExpressionInCastingContext().
&gt; Don&apos;t know is such a simplistic solution is enough for all other contexs.

I&apos;m afraid that won&apos;t cover this part of the spec:
  &quot;Generic method invocation expressions, along with class instance creation expressions that use a diamond &lt;&gt;, are poly expressions when they appear in assignment or invocation contexts. This allows type argument inference to depend on context.&quot;

Maybe we could use ASTNode.InsideExpressionStatement to discriminate?
 
&gt; In my early stage prototype for overload resolution, I had a solution
&gt; where for argument expressions that are polyexpressions in invocation
&gt; context,
&gt; instead of calling resolveType, I invoke partialResolveType, which returns
&gt; a subtype object of ReferenceBinding which stores the ASTnode type.

Do you have a draft of this that I could look at?

&gt; Before, any major refactoring/redesign: if you could post a short snippet
&gt; that shows the motivation/need along with a pointer to the relevant portion
&gt; of the spec, it can get the benefit of another pair of eyes.

In attachment 227161 (from bug 400982) you can see a sketch of a possible
addition to InvocationSite, requesting that each invocation site can answer
an InferenceContext18, which collects all constraints and bounds for that
particular context.

Maybe this together with the use of InsideExpressionStatement will already
get us going. 

Another option would be to revisit all locations calling 
Expression.setExpectedType and use these for a dual purpose:
- mark the target expression as needing a value (candidate for poly expr)
- pass down the inference context instead of just a fixed type

BTW: looking at setExpectedType I&apos;m reminded of return statements which I
don&apos;t see mentioned in the spec (when it speaks of &quot;assignment or invocation
contexts&quot;). One informal discussion alludes to the inclusion of &quot;return 
statements, etc.&quot; (intro of sect 5) but this is missing from sect 5.2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2218922</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-19 15:56:05 -0500</bug_when>
    <thetext>(In reply to comment #3)
&gt; Here&apos;s a first assessment after spending some time in and around the sub
&gt; task bug 400982.
&gt; 
&gt; == CODE CHANGES: ==
&gt; This bug will require some heavy refactoring of our code, e.g.:
&gt; 
&gt; - during resolve we need to know whether any expression is a poly
&gt; expression, which in turn requires knowledge about the context.
&gt;   -&gt; most obvious solution would be to replicate the &apos;valueRequired&apos;
&gt; argument (from generateCode) into all &apos;resolveType&apos; methods throughout the
&gt; AST.

For https://bugs.eclipse.org/bugs/show_bug.cgi?id=399778, I released
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=677bf3763b6e383c756f5ca8cbbd80c6dec30c1f which introduces
the abstraction ExpressionContext and the propagation of it.

See Expression.setExpressionContext and Expression.isPolyExpression

(the comment in MessageSend#isPolyExpression about grabbing the expected
type and not touching it, is misplaced as there is nothing to grab).

&gt; - resolving of a MessageSend needs to propagate knowledge about argument
&gt; expressions into locations like Scope.findMethod and
&gt; PGMB.computeCompatibleMethod, which are AST agnostic.
&gt;   -&gt; easiest solution could be to extend the interface InvocationSite, which
&gt; is a significant but manageable change.

My plan to tackle this in bug 400871 is through a new type of binding
PolyTypeBinding that is a subtype of ReferenceBinding that would be
returned by poly expressions (i.e lambda, reference expressions and 
messagesend) whenever resolveType is invoked on them in invocation context 
and there is no target type - this binding would capture the resolution 
scope and the AST node.

Anytime PolyTypeBinding#isCompatibleWith is called, we have the functional
interface type against which compatibility is to be determined, we have the
AST and the resolution scope. 

&gt; With all the lifting of constraints from inner contexts to outer contexts,
&gt; it&apos;s not even clear if a single tree-traversal is a good strategy for
&gt; resolveType().

I have some ideas here. Via a ASTVisitor, traverse the lambda and
gather just the declarations and return statements and build a lambda&apos;
that can be analyzed over and over if required: the bit about 
&quot;A block lambda body is value-compatible if it cannot complete normally
and ...&quot; is worrisome and needs to be thought through though.

Part B discussion box says: &quot;It&apos;s worth noting that the void/value compatible definition is not a strictly structural property: &quot;can complete normally&quot; depends on the values of constant expressions, and these may include names that reference constant variables.&quot; - This makes it a lot more challenging.

But then this begs the question: why is not strictly a structural property ?
How can control flow affect type inference/compatibility whatever ?
This looks like over-specification to me.

Did you find something that would show why/how this improves/facilitates
overload resolution ? I can&apos;t think of any reasons just now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221230</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-24 08:20:39 -0500</bug_when>
    <thetext>Running through the list of concerns from comment#3, 

&gt; Here&apos;s a first assessment after spending some time in and around the sub
&gt; task bug 400982.
&gt; 
&gt; == CODE CHANGES: ==
&gt; This bug will require some heavy refactoring of our code, e.g.:
&gt; 
&gt; - during resolve we need to know whether any expression is a poly
&gt; expression, which in turn requires knowledge about the context.

I believe this is taken care of. 

&gt; - resolving of a MessageSend needs to propagate knowledge about argument
&gt; expressions into locations like Scope.findMethod and
&gt; PGMB.computeCompatibleMethod, which are AST agnostic.
&gt;   -&gt; easiest solution could be to extend the interface InvocationSite, which
&gt; is a significant but manageable change.

Ditto. PolyTypeBinding captures the PolyExpression. This binding can be
passed around as a TypeBinding. Most existing code shouldn&apos;t even have
to know of a new TypeBinding kind - isCompatibleWith() is overridden, so
for the most part things should automagically work.

&gt; With all the lifting of constraints from inner contexts to outer contexts,
&gt; it&apos;s not even clear if a single tree-traversal is a good strategy for
&gt; resolveType().
&gt; The informal discussion mentions two &quot;rounds&quot; of inference for finding the
&gt; type of a method invocation.

What we need to do for part F&apos;s requirements is to gather &quot;result expressions&quot;
expressed as a function of concrete types and synthesized type variables for
elided types. Then for most specific analysis, we can &quot;instantiate&quot; these
type variables with types from the candidate methods. So there is no real
need for multiple tree traversal. The multiple &quot;traversals&quot; are over result
expressions which are computed and lifted out of the tree. See LambdaExpression.discoverShape in https://bugs.eclipse.org/bugs/show_bug.cgi?id=401610#c1 for early nuggets of this proposed solution.

Not sure yet, if this will suffice the requirements for type inference.

Overall, the picture I would say is much clearer and brighter.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221234</commentid>
    <comment_count>9</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-24 09:30:31 -0500</bug_when>
    <thetext>I&apos;ll happily address all technical difficulties once I have a somewhat
complete version of part G. Right now I&apos;d say it&apos;s too early to judge
how one solution or the other will help for the future type inference.

Please let me know if any of this is blocking the efforts in bug 400871,
otherwise I&apos;ll just wait, OK?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221249</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-24 12:45:46 -0500</bug_when>
    <thetext>(In reply to comment #9)

&gt; Please let me know if any of this is blocking the efforts in bug 400871,
&gt; otherwise I&apos;ll just wait, OK?

Well, many of the sections in part F start with something like &quot;if the
candidate method is generic, then apply 18.x.y&quot; - we can address these
as part of type inference work rather than as part of Chapter F - I am
fine with that.

There are two possible actions that we can take as we wait - (a) see if
there are any infrastructure elements we can put in place even as we wait
- This may or may not be possible based on how unfinished the chapter is
(b) start putting together a set of disabled tests that we think would
offer good coverage for the new piece once it is ready.

I expect to finish Part F within the next 10 days. Before I switch
gears to code generation, I&apos;ll study part G so we will be able to
discuss more meaningfully than I am able to do now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221275</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-24 14:56:15 -0500</bug_when>
    <thetext>(In reply to comment #10)
&gt; There are two possible actions that we can take as we wait - (a) see if
&gt; there are any infrastructure elements we can put in place even as we wait
&gt; - This may or may not be possible based on how unfinished the chapter is

that&apos;s what I started in bug 400982, until I realized that I was beginning
to invent things that have not yet been specified, just in order to allow me
to actually run some of the new code. That&apos;s when I stopped work in that bug.

&gt; (b) start putting together a set of disabled tests that we think would
&gt; offer good coverage for the new piece once it is ready.

The better part of sect. 18 makes no statement of what programs will be 
accepted or rejected by the new inference. At that level we would be
creating pure white box tests, that check, e.g., for the proper creation
of inference variables, constraint formulas etc. I don&apos;t think we want/need
that kind of tests.

OTOH, a number of existing tests will in fact trigger the new inference.

I&apos;m thinking of ensuring a first level of test coverage with the help of 
JaCoCo, with 100% branch coverage of relevant code (excepting, e.g., debug
output) as the initial quality gate.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221446</commentid>
    <comment_count>12</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 06:20:46 -0500</bug_when>
    <thetext>(In reply to comment #8)

&gt; &gt; With all the lifting of constraints from inner contexts to outer contexts,
&gt; &gt; it&apos;s not even clear if a single tree-traversal is a good strategy for
&gt; &gt; resolveType().
&gt; &gt; The informal discussion mentions two &quot;rounds&quot; of inference for finding the
&gt; &gt; type of a method invocation.

&gt; What we need to do for part F&apos;s requirements is to gather &quot;result
&gt; expressions&quot;
&gt; expressed as a function of concrete types and synthesized type variables for
&gt; elided types. Then for most specific analysis, we can &quot;instantiate&quot; these
&gt; type variables with types from the candidate methods. So there is no real
&gt; need for multiple tree traversal. The multiple &quot;traversals&quot; are over result
&gt; expressions which are computed and lifted out of the tree. See

I am a bind now - A lambda expression is compatible with target type if
among other things every return expression&apos;s type is assignment compatible
with the descriptor&apos;s return type.

This requires resolving arguments (because they can be referenced in
return expressions), local declarations (because ... same reason), 
processing (not necessarily resolving) blocks (because they introduce
scopes and the meaning of names used in return expressions could change 
with scopes.) and resolving return expressions (because we need their 
type to establish assignment compatibility)

I prototyped a solution based on ASTVisitor that would minimally process
the lambda nodes and extract result expressions. It works beautifully,
but then such selective ahead of time resolution leaves the concerned
AST nodes &quot;dirty&quot; and leads to sporadic misbehavior at a later time.

Either we need to view this problem of dirty bits in the AST nodes as a
series of bugs and fix them (not at all a happy picture) or 

(a)Come up with a ASTReplicator class that can clone a subtree. Looking at
how many node types would be involved (lambda can return a lambda and
lambda can have a block body pulling in really all node types in the worst
case) - Selective replication is possible, but satisfying ourselves of
correctness is going to be a nightmare.

(b) check out how the shallow copy model of Object.clone would work in
this scenario. Not very promising.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221462</commentid>
    <comment_count>13</comment_count>
    <who name="Jesper Moller">jesper</who>
    <bug_when>2013-02-25 07:13:41 -0500</bug_when>
    <thetext>(In reply to comment #12)

&gt; Either we need to view this problem of dirty bits in the AST nodes as a
&gt; series of bugs and fix them (not at all a happy picture) or 
&gt; 
&gt; (a)Come up with a ASTReplicator class that can clone a subtree. Looking at
&gt; how many node types would be involved (lambda can return a lambda and
&gt; lambda can have a block body pulling in really all node types in the worst
&gt; case) - Selective replication is possible, but satisfying ourselves of
&gt; correctness is going to be a nightmare.
&gt; 
&gt; (b) check out how the shallow copy model of Object.clone would work in
&gt; this scenario. Not very promising.

or (c) introduce a ASTNode.resetResolve() which handles resetting all the bits set by the individual resolve. Wouldn&apos;t that be less work than cloning?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221503</commentid>
    <comment_count>14</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 08:37:02 -0500</bug_when>
    <thetext>(In reply to comment #13)

&gt; or (c) introduce a ASTNode.resetResolve() which handles resetting all the
&gt; bits set by the individual resolve. Wouldn&apos;t that be less work than cloning?

I did consider that option, (&quot;unresolve&quot;) - Cloning is mindless boilerplate 
code, figuring out actually which bits in the AST got dirty is tough work. 
The bits may not be modified directly by resolve and may be modified by some
method called by it. Alternately, knowing what is the initial state of each
of the AST nodes is also complex as return statements could be arbitrarily
complex i.e 

    return () -&gt; {
                   // block with locals, various control flow statements,
                   // local classes, try-catch-finally blocks, more lambda etc.
                 }

At the moment, I am leaning towards a ASTReplicator facility.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221528</commentid>
    <comment_count>15</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 09:13:30 -0500</bug_when>
    <thetext>(In reply to comment #14)

&gt;     return () -&gt; {
&gt;                    // block with locals, various control flow statements,
&gt;                    // local classes, try-catch-finally blocks, more lambda
&gt; etc.
&gt;                  }

(Not that we expect such code in reality, but compilers must be prepared
for any possible input)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221568</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-25 09:47:50 -0500</bug_when>
    <thetext>Are you discussing details of Part G or Part F here?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221663</commentid>
    <comment_count>17</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 12:26:29 -0500</bug_when>
    <thetext>Here is another idea: We could serialize the LambdaExpression node
by calling toString on it and then reparse the string into LambdaExpression&apos; :)

This solution can also be mechanically verified by running it through our
entire test suite and making sure that Serialized(LambdaExpression) == Serialized(LambdaExpression&apos;) (ignoring white space differences). 

Yes Stephan, we are discussing part F here, your observation in comment#3
started it :) Further discussion in the right bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221670</commentid>
    <comment_count>18</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 12:39:40 -0500</bug_when>
    <thetext>(In reply to comment #17)
&gt; Here is another idea: We could serialize the LambdaExpression node
&gt; by calling toString on it and then reparse the string into LambdaExpression&apos;
&gt; :)

That is dumb, we don&apos;t even have to serialize it. If we know the start and
end positions of the lambda expression, we can simply reset the scanner to
those points and reparse.

&gt; Yes Stephan, we are discussing part F here, your observation in comment#3
&gt; started it :) Further discussion in the right bug.

Further discussions really in the other place :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221824</commentid>
    <comment_count>19</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-25 18:29:41 -0500</bug_when>
    <thetext>While wondering how many modes of resolving we&apos;ll need, I anticipate these
requirements from Part G:

A) standalone expression can basically be resolved in old-style.

B) poly expressions are resolved using the new type inference, which applies
   a reduced form of constraint solving

(B) inherently breaks the single-traversal rule of old-style resolving.
This approach rather works on sets of constraints and bounds over so called
inference variables. I envision that this will be integrated with the
existing code somewhat along these lines:
- an initial tree traversal (e.g., &quot;createInitialBoundSet()&quot;) creates a re-
  presentation using inference variables, constraint formulas and type bounds
- actual inference will work on only these variables, formulas and bounds
  in order to compute valid instantiations for the inference variables.
- assuming that inference variables hold back-pointers into the AST,
  whenever an inference variable is resolved this result can be pushed into
  the AST.
- when inference fails, all unresolved inference variables should push a
  problem binding into their AST nodes.
This enables us to attach type bindings in arbitrary order, no further
tree traversal needed.

By performing all the interim work on inference variables, not the AST,
this part doesn&apos;t seem to require any un-resolving, as discussed above.

A tricky part is in the switch between strategies (A) and (B), since the
detection of a poly expression needs some resolved type information,
which we don&apos;t have before we start resolving using either strategy (A)
or (B) ...

Let&apos;s assume we start in strategy (A) until we find s.t. that from a
syntactic pov could be a poly expression.
Here we could throw an exception and restart at the enclosing syntactic
context using strategy (B) (alternatively, we could already collect that
information as early as during parsing and let it bubble out somehow).
- Now, while initializing type inference we&apos;d find some already resolved
  AST nodes.
  -&gt; need to check if any of this could be wrong, but for those parts that
     are not poly we might be allowed to keep the resolved type information.
  -&gt; if so, simply convert resolved types into (resolved) inference
     variables, to participate in the inference game.
- At the end of inference we might have to check if inference was actually
  applicable, by re-checking polyness.
  -&gt; need to check if using inference where it wasn&apos;t called for could
     cause any harm
     -&gt; inference is soundness preserving, thus any solution found by
        inference is sound
     -&gt; inference is not completeness preserving: not having found a solution
        by inference doesn&apos;t mean there isn&apos;t one.
     Is it possible for an actually-not-poly expression (that looked like
     one in syntactic terms) that either (A) or (B) finds a solution which
     the other strategy doesn&apos;t?


This is drawn mostly from my current understanding of just section 18.
I don&apos;t have a clear picture whether any of this could help for overload
resolution using the concept of &quot;potentially compatible&quot;.

As soon as I have a more complete specification I will continue work in
bug 400982 which will allow you to investigate, whether overload resolution
can piggy-back on that infra structure. I hope, I soon have that material.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221827</commentid>
    <comment_count>20</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-25 19:10:47 -0500</bug_when>
    <thetext>(In reply to comment #19)

&gt; Let&apos;s assume we start in strategy (A) until we find s.t. that from a
&gt; syntactic pov could be a poly expression.
&gt; Here we could throw an exception and restart at the enclosing syntactic
&gt; context using strategy (B) (alternatively, we could already collect that
&gt; information as early as during parsing and let it bubble out somehow).

This parenthesized piece is already in place. Only class instance creation 
expressions, lambdas and reference expressions can be detected to be poly 
expressions apriori. For method invocation, we can categorize them as 
polyexpressions only after inference has proceeded to a near completion 
stage and we still have unresolved type variables and need the expected
type. The very fact of the expected type being called into question and
being used to successfully complete inference is what makes a method 
invocation a poly expression.  

&gt; - At the end of inference we might have to check if inference was actually
&gt;   applicable, by re-checking polyness.
&gt;   -&gt; need to check if using inference where it wasn&apos;t called for could
&gt;      cause any harm

In the present JLS7 model, I believe the trees would not be touched if
inference did not succeed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221927</commentid>
    <comment_count>21</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-02-26 04:33:14 -0500</bug_when>
    <thetext>(In reply to comment #20)
&gt; (In reply to comment #19)
&gt; 
&gt; &gt; Let&apos;s assume we start in strategy (A) until we find s.t. that from a
&gt; &gt; syntactic pov could be a poly expression.
&gt; &gt; Here we could throw an exception and restart at the enclosing syntactic
&gt; &gt; context using strategy (B) (alternatively, we could already collect that
&gt; &gt; information as early as during parsing and let it bubble out somehow).
&gt; 
&gt; This parenthesized piece is already in place. Only class instance creation 
&gt; expressions, lambdas and reference expressions can be detected to be poly 
&gt; expressions apriori.

We both have implemented some detection of *isPolyExpression*.
For part G we might need to know, whether an expression, a statement,
*contains* a poly expression somewhere inside. That&apos;s why I mentioned
possible &quot;bubbling out&quot; of this information.

&gt; For method invocation, we can categorize them as 
&gt; polyexpressions only after inference has proceeded to a near completion ...

That&apos;s why I made the distinction &quot;from a syntactic pov&quot;, so we might
defer the final decision on polyness till later.

&gt; &gt;   -&gt; need to check if using inference where it wasn&apos;t called for could
&gt; &gt;      cause any harm
&gt; 
&gt; In the present JLS7 model, I believe the trees would not be touched if
&gt; inference did not succeed.

My idea was to actually use the information from inference, although
after the fact we know that no inference would have been necessary.
Sure, if that would create wrong results we can still chose to simply
discard the inference result and retry with old-style resolving.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221928</commentid>
    <comment_count>22</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-26 04:41:37 -0500</bug_when>
    <thetext>(In reply to comment #21)

&gt; We both have implemented some detection of *isPolyExpression*.
&gt; For part G we might need to know, whether an expression, a statement,
&gt; *contains* a poly expression somewhere inside. That&apos;s why I mentioned
&gt; possible &quot;bubbling out&quot; of this information.

Perhaps an example would help me see your point better, to see why the
present scheme will fall short in some situations and/or how it can be 
enhanced to meet the slightly different needs.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2221947</commentid>
    <comment_count>23</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-02-26 05:20:29 -0500</bug_when>
    <thetext>Not having understood Part G properly yet, perhaps I am not contributing to
a meaningful dialog from my end: But thinking about it from part F pov,
a lambda or a method/constructor reference cannot steer the inference
process towards the solution anymuch. They cannot constrain the type
variables in any form (well they can constrain them to be interfaces and
functional interfaces at that, but I doubt if that constraint is actually
to be used actually.) Because these are not typed until after overload 
resolution is over, these can at best take part in a post inference 
compatibility check. If so, I would think LambdaExpression.isCompatibleWith
and the soon to come LambdaExpression.isMoreSpecificThan(type1, type2)
should be good enough.

Part F also has this: &quot;if an argument is a lambda expression that cannot yet be typed due to unfinished inference (thus, the method is considered provisionally applicable), we conservatively make no attempt to compare the two methods; typically, an ambiguity error would be the result.&quot;

I&apos;ll hold on these &quot;core dumps&quot; until after I have read up on G.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2226521</commentid>
    <comment_count>24</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-05 20:01:24 -0500</bug_when>
    <thetext>Given the new version 0.6.2 of the spec I finally find myself in a position where I can start serious work in this bug.

Indeed the missing parts as called out in comment 3 have been filled in, to the degree that the basic framework of the algorithm can now be implemented, which is what I just did.

As of now I only sketched a very narrow integration into the existing code, not worrying about particular call chains and retries and watnot, focusing just on the inference engine.

The good news: this engine is already able to give some correct answers, as witnessed by an initial experiment:
- Invoke the new inference only from PGMB.computeCompatibleMethod(), and if successful use its result instead of calling the old inference.
- Run GenericTypeTest at 1.8
Result: in 410 situations the new inference successfully kicked in, 118 of which caused the corresponding test to fail.
Should I call this 70% complete? Probably not :)

The next road-block is in sect. 18.2.3 which defines how subtyping constraints are reduced. For parameterized types it instructs you 
   &quot;let C&lt;B1, ..., Bn&gt; be the parameterization of C for S, as defined below; &quot;. 
If you look below, you see: 
   &quot;To do: define the parameterization of a class C for a type T;...&quot;.

This could well be the reason for most of the test failures mentioned above as I had to make a lot of guesses in this area.

I&apos;ve pushed my current draft to a feature branch http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference 
Please expect lots of TODOs inside.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2226929</commentid>
    <comment_count>25</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-03-06 13:04:14 -0500</bug_when>
    <thetext>I offer to review this once a near final form is available. Likewise
I&apos;ll request review from you/Jesper on the parts of 335 I worked on once 
they are near completion. This review can be scheduled at convenience 
without any time pressure.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2227386</commentid>
    <comment_count>26</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-07 08:50:12 -0500</bug_when>
    <thetext>Status update based on a code instrumentation experiment:

in version 0.6.2 JLS 18.2.3 says:
&quot;If T is an array type, T&apos;[], then let S&apos;[] be the most specific array supertype of S, as defined below; ...
 To do: ... define the most specific array supertype of a type T.&quot;

I instrumented the code to report as error all test cases that trigger this scenario, resulting in the following outcome for GenericTypeTest:
- 56 errors
- 92 failures
=&gt; more than 1/3 of all non-passing tests in GenericTypeTest are due to this single incompleteness.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2227542</commentid>
    <comment_count>27</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-07 11:45:31 -0500</bug_when>
    <thetext>I&apos;m now confident that the newly implemented infrastructure is capable of performing real type inference :)

(In reply to comment #25)
&gt; I offer to review this once a near final form is available. 

I&apos;d say work in the sub-task bug 400982 is ready for an initial review any time now, see bug 400982 comment 2.
Up-to this point my focus was on providing the general infrastructure.
At this point I&apos;m shifting gears towards addressing individual issues for specific code/type situations.

Clearly, it is impossible to resolve this bug using spec version 0.6.2, but a good milestone has been reached already and a good deal of detail work is now enabled.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2317627</commentid>
    <comment_count>28</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-10-13 11:51:58 -0400</bug_when>
    <thetext>After closing the foundational bug 400982, a few words on the status of the implementation:

Several locations would throw UnsupportedOperationException if called, all these are routed through InferenceContext18.missingImplementation() for easier reference. None of these are currently triggered when running all compiler.regression tests. This may be due to the fact, that the implementation is currently integrated *only* into ParameterizedGenericMethodBinding.computeCompatibleMethod(..).

In the code that does not call missingImplementation() a few locations are marked FIXME or TODO where more investigation is needed. If neither of these marks can be found then the code in question is considered complete by me.

The current score wrt all compiler.regression tests at level 1.8:
0 Error / 134 Failures (+/- a couple of non-deterministic issues).

I know of the following causes for failure (but haven&apos;t looked at all failures):
- unspecified integration of unchecked conversions into 18.5.1 / 18.5.2.
- some var arg issues (regarding pass-through of an array)
- error messages leaking internal info etc. How to turn inference failure
  into a nice user friendly message is a cute sub-project on its own right,
  see bug 404675

A message has been sent to the EG: http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-October/000384.html seeking further clarification in various questions.

The current status is available in the feature branch sherrmann/NewTypeInference for the curious to inspect. For best use of my time I might actually wait for the next spec update, since - again - open spec issues seem to be responsible for the bulk of remaining problems. Debugging regressions and recognizing that I&apos;m not entitled to fix them sounds like a waste of time - with one exception, I might already spend a few hours on preparing for better error reporting ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2330124</commentid>
    <comment_count>29</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-14 06:19:10 -0500</bug_when>
    <thetext>When revisiting the impact of raw types on inference, we should also look at the existing differences between javac and ecj reported in bug 402237.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2333075</commentid>
    <comment_count>30</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-21 12:23:38 -0500</bug_when>
    <thetext>As I&apos;m using GenericTypeTest as my main test suite, let me highlight my current status against these tests:

In http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=0a4d3bd078f11e6acd061d904f26e9a17caa1140
I adjusted several tests, where inference used to fail, but the new inference actually finds a valid solution.

Next I disabled all tests the are failing because the new inference no longer supports unchecked conversions. While I&apos;m awaiting answer from the EG, whether or not Java 8 will actually bring this change (not yet implemeneted in javac), I marked this bunch of tests with the prefix _UNCHECKED_.

Another request for clarification can be found here: http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-November/000428.html
For reasons unknown to me I cannot see how the spec would produce the desired result. While waiting for clarification, tests affected by this issue are disabled with the prefix _EG_.

Disablement has been pushed to http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=ded8cb0e1c42745a274b70bc918e0d2a7ba33533

So, after disabling 43 out of 1993 tests, I&apos;m down to 84 failures in this suite.

In comparison to comment 28 we have more failures now, mostly because invocation type inference has been enabled in the mean time.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2333165</commentid>
    <comment_count>31</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-21 15:37:32 -0500</bug_when>
    <thetext>The previous filtering of tests missed several. Pushed an update to http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=3f8dd32bda29becea2fc0074fafbcf7f15c83bf6

Status from originally 1493 (sic) tests in GTT
- 46 are disabled _UNCHECKED_
- 39 are disabled _EG_

Remaining regressions: 45

During these tests
- inference succeeds 405 times
- inference fails 66 times

From the remaining failures (ca. 10% of all uses of inference?!) 
- a significant number is due to details of error reporting -&gt; defer
- some show incompatibilities involving either captures or fresh type
  variables from the new inference.
  Some of these might be caused by the &quot;_EG_&quot; issue.
- some more can still be related to unchecked conversions.
Plain inference bugs I could not identity at this level of scrutiny.


Anyway, with fewer regressions than tests waiting for spec clarification I&apos;ll stop this game for now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2335508</commentid>
    <comment_count>32</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-28 08:58:09 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #31)
&gt; Status from originally 1493 (sic) tests in GTT
&gt; - 46 are disabled _UNCHECKED_
&gt; - 39 are disabled _EG_
&gt; 
&gt; Remaining regressions: 45

I received clarification on the EG list via http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-November/000429.html

I&apos;ve adjusted my implementation accordingly and enabled tests previously marked _EG_, result:

GTT (1448 tests):
- 46 are disabled _UNCHECKED_
Remaining regressions: 39 failures

TestAll (compiler.regression) (7901 tests):
- disablement as above
Remaining regressions: 6 errors, 73 failures

Here&apos;s the corresponding commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=2b2a09cc41484ec62e8a6f3a4fb7d1e79e26e9eb</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2335651</commentid>
    <comment_count>33</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-28 12:22:32 -0500</bug_when>
    <thetext>Test results were still oscillating, one reason being: on one code path inference failure would cause us to fall back to the old inference. After disabling this fallback I get:

GTT (1448 tests):
- 46 are disabled _UNCHECKED_
Remaining regressions: 78 failures

TestAll (compiler.regression) (7901 tests):
- disablement as above
Remaining regressions: 6 errors, 137 failures

Back to analysing causes of failures.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336202</commentid>
    <comment_count>34</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-29 20:17:31 -0500</bug_when>
    <thetext>Updates:
--------
- implemented two phase check (loose &amp; vararg invocation, not yet: strict)
- started to implement javac bug re unchecked conversion in illegal situations
- re-enabled all tests previously marked as _UNCHECKED_
- make lub() computation capable of handling the null type

Test Status:
------------
GTT (1494 tests):
- all specific disablement reverted
Remaining regressions: 41 failures

Many of these failures actually relate to *how* exactly we report an error.


TestAll (compiler.regression) (7964 tests):
Remaining regressions: 5 errors, 67 failures (incl. the 41 from above)

The 5 errors simply signal that some code is missing for inferring lambdas.

We might be on the home stretch already for this chapter (viz. using the new engine to infer types of generic method calls).

-----------

Branch has been merged with head from BETA_JAVA8, which required adjustments regarding Expression.isPertinentToApplicability(). One part being: these methods need to cope with targetType==null.

Srikanth: do you think it&apos;s OK to return true in that case??


Current state has been pushed as http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=d6921eb70cb6869e11ea480cc7a189bb4aac3bbc</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336209</commentid>
    <comment_count>35</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-30 04:13:02 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #34)

&gt; We might be on the home stretch already for this chapter (viz. using the new
&gt; engine to infer types of generic method calls).

That is terrific progress and great news ! Thanks Stephan. 

&gt; Branch has been merged with head from BETA_JAVA8, which required adjustments
&gt; regarding Expression.isPertinentToApplicability(). One part being: these
&gt; methods need to cope with targetType==null.
&gt; 
&gt; Srikanth: do you think it&apos;s OK to return true in that case??

Yes, isCompatibleWith should answer false and isPertinent* should answer true.
BTW, the latter method is also missing handling of TVB from 15.12.2.2 i.e:

If m is a generic method and the method invocation does not provide explicit 
type arguments, an explicitly-typed lambda expression for which the 
corresponding target type (as derived from the signature of m) is a type 
parameter of m.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336256</commentid>
    <comment_count>36</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-30 16:13:39 -0500</bug_when>
    <thetext>In bug 422064 I&apos;m tracking general issues re comparing ecj and javac behavior against GenericTypeTest. In this comment I&apos;m listing those deviations that are introduced as of 1.8:

Obvious:
========
AbstractRegressionTest.JavacTestOptions.JavacHasABug.IntArrayAsTypeBound:
javac8 no longer complains at
  public class X&lt;T extends int[]&gt; { }
!!!

Need investigation:
===================

Newly rejected by javac8, many of which I suspect to be fresh javac bugs:
- test1167
- test1045
- test1167
- test1273
- test1275
- test1278
- test1325
- test1406
- test1407
- test1429
- test1434
- test1381
- test1386
- test1387
- test1388
- test0921

Newly rejected by javac8, probably conforming to the spec:
- test277643
- test283306
Ecj in my branch would normally reject these, too, but I had to apply a hack (against the SPEC) in order to fix approx. 20 other deviations of javac, which now breaks these two !!!!!

Errors no longer found by javac8 (still found by ecj)
- test1421
- test1445
- test0803</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336257</commentid>
    <comment_count>37</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-30 16:15:16 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #36)
&gt; In bug 422064 I&apos;m tracking general issues re comparing ecj and javac
&gt; behavior against GenericTypeTest.

Oops, wrong number, should read: bug 422896.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336270</commentid>
    <comment_count>38</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-30 20:32:54 -0500</bug_when>
    <thetext>Updates since comment 34:

Improved handling of rawtypes:
- implement additions in 18.2.2 as of 0.7.0

Initial handling of nested inference to allow an outer target type to influence the type of an inner poly expression. Currently only for MessageSend. Two design decisions may be worth discussing:
- when resolving an inner invocation finds it applicable as varargs,
  store this flag so that re-checking in the outer context only needs 1 phase
- after outer inference I re-bind any inner poly expressions, currently:
  assign new #binding and #resolvedType with improved types to an inner
  MessageSend
During outer inference the pre-resolved PGMB of an inner is actually unwrapped to freshly start from unbound type variables.

Analysed deviations between javac &amp; ecj (see comment 36)

Updated several tests to expect better inference.

Analysed and classified all remaining regressions in GTT:
-difference only in error message, some only in how inferred types are printed
  -&gt; 28 tests
- missing warning or error (also javac fails to show some warnings here)
  -&gt; 5 tests
- inappropriate errors
  -&gt; 5 tests

Let me just fix the latter 5 + 5 tests (where it&apos;s clear what should be expected) before I&apos;ll move on to addressing lambdas and method references.

The corresponding commit is http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=b782c3ef6e216cdcd365dba6077a7cf049bcd30e</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336271</commentid>
    <comment_count>39</comment_count>
      <attachid>237885</attachid>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-30 22:12:42 -0500</bug_when>
    <thetext>Created attachment 237885
Patch that may have some useful APIs

This is a core dump of some prototyping work I did for https://bugs.eclipse.org/bugs/show_bug.cgi?id=401783. It is
stale by 10 days worth of changes. 

You may want to browse through the patch to see if there are elements 
that could be leveraged and if so after review release them into 
BETA_JAVA8 and merge them into your branch.

Expression.isBoxingCompatibleWith 
PolyExpression Overrides of Expression.resolveTypeExpecting

etc may be useful. If these APIs could be useful and you have problems
selectively applying them, add a note in https://bugs.eclipse.org/bugs/show_bug.cgi?id=419315 and I&apos;ll work on it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336272</commentid>
    <comment_count>40</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-30 22:17:07 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #38)

&gt; MessageSend. Two design decisions may be worth discussing:
&gt; - when resolving an inner invocation finds it applicable as varargs,
&gt;   store this flag so that re-checking in the outer context only needs 1 phase

See org.eclipse.jdt.internal.compiler.ast.Expression.tagAsEllipsisArgument()
Polyexpressions are already notified of this, but TypeBinding.isCompatibleWith
used by overload resolution code in Scope.findMethod returns a boolean.
Perhaps the overload resolution &quot;engine&quot; could be changed to use another
version of isCompatibleWith that would return a level ala Scope.parameterCompatibilityLevel</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336296</commentid>
    <comment_count>41</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-01 09:20:46 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #40)

&gt; See org.eclipse.jdt.internal.compiler.ast.Expression.tagAsEllipsisArgument()
&gt; Polyexpressions are already notified of this, but
&gt; TypeBinding.isCompatibleWith

&gt; used by overload resolution code in Scope.findMethod returns a boolean.
&gt; Perhaps the overload resolution &quot;engine&quot; could be changed to use another
&gt; version of isCompatibleWith that would return a level ala
&gt; Scope.parameterCompatibilityLevel

Scope.parameterCompatibilityLevel already takes care of unboxing the array
type to see element compatibility as witnessed by the passing of 
org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8.testVarargs()</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336316</commentid>
    <comment_count>42</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-01 12:30:08 -0500</bug_when>
    <thetext>I&apos;ve pushed another bunch of changes as http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=983d7c23e3ef9522672506642e4f4250a6d45571

At this point I declare a first milestone to be completed.
The status is best described along the remaining regressions in GTT along with pending questions on the EG list (use the all-caps term for searching in the test class):

SHOULD FAIL
23 tests *pass* to be conform with javac but violating the spec (re unchecked conversions), see
http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000443.html

FAIL FIXME
The &quot;fix&quot; for the above breaks 4 other tests. Help needed from the EG list.

FAIL ERRMSG
several tests correctly detect an error but the error message should be reconsidered.

MISSING WARNINGS
3 tests should probably show more warnings re unchecked conversions.

EXTRA ERR
1 test reports an error which seems mandated by the spec, but none of the existing compilers report this. This is an issue of array-of-wildcard, should it be captured? See http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000444.html

EXTRA ERR
1 test fails due to missing integration into normal resolve().

IMHO, only the last one of the above issues calls for direct action from us, to be discussed in a subsequent comment. All others can be deferred until either we get answers in the EG list or until implementation reaches a polish phase.


This means I can now enter the next stage where I will include reference expressions and lambdas into the inference.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336318</commentid>
    <comment_count>43</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-01 13:11:41 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #42)
&gt; EXTRA ERR
&gt; 1 test fails due to missing integration into normal resolve().

Please see GenericTypeTest.test1031():
A regular invocation contains a poly expression as its argument.
When we resolve the inner we don&apos;t have an expected type (aka target type), hence inference produces sub-optimal results. We have no second round of inference, because the outer invocation does not require inference. At the end the sub-optimal inference result doesn&apos;t fit the outer call.

Looking at usage of PolyTypeBinding I wonder if the following is intended:
- initial resolving of the inner MessageSend produces a PolyTypeBinding
- then we lookup the outer method
- resolvePolyExpressionArguments() will do the rest.
Is this how it should work?

If so, then the missing piece would be: MessageSend never resolves to a PolyTypeBinding, only these 4 do:
- AllocationExpression
- LambdaExpression
- ReferenceExpression
- ConditionalExpression
Should I add a stanza to the beginning of MessageSend.resolveType() that reads similar to the start of AllocationExpression.resolveType() (the early exit using PolyTypeBinding)??


On a similar note I had a quick look at tagAsEllipsisArgument() but couldn&apos;t exactly figure out its meaning: is this for the last actual argument that is being passed into a varargs method? Why is that needed?

(In reply to Srikanth Sankaran from comment #41)
&gt; Scope.parameterCompatibilityLevel already takes care of unboxing the array
&gt; type to see element compatibility as witnessed by the passing of 
&gt; org.eclipse.jdt.core.tests.compiler.regression.OverloadResolutionTest8.
&gt; testVarargs()

In part G the parameterCompatibilityLevel() mechanism is of little help, because we can&apos;t decide varargs vs. direct passing by looking at one parameter in isolation. We need to run the full inference for strict/loose invocations. If it finds a solution, we&apos;re fine, if not it should (hopefully) fail fast and a subsequent inference will look for a varargs solution.

I still hope, that for the strict/loose distinction we can be less pedantic.


So, for part G I need to know at each message send how I want to check for applicability (strict, loose, variable-arity). For the time being I extended the flag mentioned in comment 38 into an int, to record what kind of inference (if any) found the current method candidate. This is now used also to short-circuit the obsolete parameterCompatibilityLevel() checks if inference has worked instead. We should eventually prune / short-circuit even more of the old implementation, but I&apos;m still trying to keep my changes to existing code at a minimum.

We may even keep both inference machines in separate universes, so we wouldn&apos;t have to squeeze any legacy hacks into the new machine. Let&apos;s see how this spells out in real life...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336322</commentid>
    <comment_count>44</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-01 13:25:19 -0500</bug_when>
    <thetext>Srikanth, if you have a minute I&apos;d appreciate a comment regarding this little change: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/diff/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/TypeBinding.java?h=sherrmann/NewTypeInference&amp;id=1832aee5d00f04e89e8ecf939e65051ef1f988cd

In GTT.test1060() I encountered a situation where isTypeArgumentContainedBy() needs to be answered regarding a WildcardBinding whose bound is an IntersectionCastTypeBinding. The change achieves what it is intended for and doesn&apos;t break existing regression tests, but working with &quot;? super A &amp; B&quot; is not my daily business, so a second opinion would be great :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336324</commentid>
    <comment_count>45</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-01 13:51:07 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #43)
&gt; (In reply to Stephan Herrmann from comment #42)
&gt; &gt; EXTRA ERR
&gt; &gt; 1 test fails due to missing integration into normal resolve().
&gt; 
&gt; Please see GenericTypeTest.test1031():
&gt; A regular invocation contains a poly expression as its argument.
&gt; When we resolve the inner we don&apos;t have an expected type (aka target type),
&gt; hence inference produces sub-optimal results. We have no second round of
&gt; inference, because the outer invocation does not require inference. At the
&gt; end the sub-optimal inference result doesn&apos;t fit the outer call.
&gt; 
&gt; Looking at usage of PolyTypeBinding I wonder if the following is intended:
&gt; - initial resolving of the inner MessageSend produces a PolyTypeBinding
&gt; - then we lookup the outer method
&gt; - resolvePolyExpressionArguments() will do the rest.
&gt; Is this how it should work?

Yes - Please see the attached patch for a skeleton
of how MessageSend would/could play as a poly expression. Unlike other poly 
expressions, a generic method invocation cannot be deduced to be one till deep
into PGMB.computeCompatibleMethod. In the prototype I did, I am throwing
a PolyTypeException when we need the expected type, but don&apos;t have one yet.
This allows the MessageSend to declare itself to be a PolyExpression and
return a PolyTypeBinding to its caller.

In general, PolyExpression handling happens in 3 phases:

(1) Initial resolution : resolveType(BlockScope) If in INVOCATION_CONTEXT and
an expected type is missing, the poly expression immediately returns a
PolyTypeBinding as its type.

(2) The abstraction that originally invoked the resolution of a poly expression
is always a call i.e one of (MessageSend, AllocationExpression, 
QualifiedAllocationExpression, ExplicitConstructorCall).

This abstraction proceeds into overload resolution &quot;normally&quot; albeit after
recording the fact some of the argument expressions are poly expressions.

Overload resolution (Scope.findMethod) itself is (mostly) unaware of 
PolyTypeBinding (other than the part about sIsMoreSpecific()) and simply
goes its its job by invoking isCompatibleWith. isCompatibleWith on
the PolyTypeBinding deflects to the PolyExpression.

So the poly expression compatibility is tried out one by against the
candidates and if we are still left with &gt; 1, we go into most specific method
search.

isCompatibleWith (and resolveTypeExpecting from the patch - not yet on
the branch) may be called many times and may have to resolve the poly expression
against the target type offered by the matching positional parameter type
of the candidate method. It is crucial that these multiple resolutions should
not dirty the original node. This is easily achieved by carefully segregating
&quot;once only&quot; code (e.g everything to the left of :: in a reference expression)
from &quot;potentially once for every target type&quot; code. Not so easily
achieved for LE, so we actually go back to the parser and ask it to materialize
a fresh copy: see LE.copy()

(3) Eventually resolution against the real target type or error handling.

&gt; If so, then the missing piece would be: MessageSend never resolves to a
&gt; PolyTypeBinding, only these 4 do:

[...]

&gt; Should I add a stanza to the beginning of MessageSend.resolveType() that
&gt; reads similar to the start of AllocationExpression.resolveType() (the early
&gt; exit using PolyTypeBinding)??

Yes, the patch has this capability.

&gt; On a similar note I had a quick look at tagAsEllipsisArgument() but couldn&apos;t
&gt; exactly figure out its meaning: is this for the last actual argument that is
&gt; being passed into a varargs method? Why is that needed?

This is to flag that the last formal parameter is a vararg parameter.
So the poly expression can know. 

See org.eclipse.jdt.internal.compiler.ast.FunctionalExpression.setExpectedType(TypeBinding)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336327</commentid>
    <comment_count>46</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-01 14:08:16 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #43)

&gt; In part G the parameterCompatibilityLevel() mechanism is of little help,
&gt; because we can&apos;t decide varargs vs. direct passing by looking at one
&gt; parameter in isolation. We need to run the full inference for strict/loose
&gt; invocations. If it finds a solution, we&apos;re fine, if not it should
&gt; (hopefully) fail fast and a subsequent inference will look for a varargs
&gt; solution.

I think this is something like the distinction between NFA/DFA, Scope.findMethod
implements a &quot;parallel&quot; model for 15.12.2.2, 15.12.2.3 and 15.12.2.4

I haven&apos;t yet had a chance to look through your branch or that specific portion
of the spec to know if PGMB.computeCompatibleMethod could similarly parallelize.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336913</commentid>
    <comment_count>47</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-03 06:25:07 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #46)
&gt; (In reply to Stephan Herrmann from comment #43)
&gt; 
&gt; &gt; In part G the parameterCompatibilityLevel() mechanism is of little help,
&gt; &gt; because we can&apos;t decide varargs vs. direct passing by looking at one
&gt; &gt; parameter in isolation. We need to run the full inference for strict/loose
&gt; &gt; invocations. If it finds a solution, we&apos;re fine, if not it should
&gt; &gt; (hopefully) fail fast and a subsequent inference will look for a varargs
&gt; &gt; solution.
&gt; 
&gt; I think this is something like the distinction between NFA/DFA,
&gt; Scope.findMethod
&gt; implements a &quot;parallel&quot; model for 15.12.2.2, 15.12.2.3 and 15.12.2.4
&gt; 
&gt; I haven&apos;t yet had a chance to look through your branch or that specific
&gt; portion
&gt; of the spec to know if PGMB.computeCompatibleMethod could similarly
&gt; parallelize.

If you are recommending to run applicability checks for strict/loose context in parallel with those for variable-arity context: I doubt that this will be an improvement - if possible: each inference produces lots of effects into the bound set(s) on which it operates. The spec explicitly states what can be shared (result of reduction) and cannot (result of resolve) and this part works fine.

IOW: I&apos;m fine with doing these checks in sequence and don&apos;t see possibility for substantial simplification.

The more fundamental issue, which I&apos;d like to co-operate on, is the integration of PolyTypeBinding for MessageSends with type inference, possibly coordinated by throwing an exception when we detect the poly nature of the message send.

Srikanth, please let me know when you have some cycles to work on this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336927</commentid>
    <comment_count>48</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-03 07:04:53 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #47)

&gt; IOW: I&apos;m fine with doing these checks in sequence and don&apos;t see possibility
&gt; for substantial simplification.

OK, I&apos;ll stop harping on this point :)

&gt; The more fundamental issue, which I&apos;d like to co-operate on, is the
&gt; integration of PolyTypeBinding for MessageSends with type inference,
&gt; possibly coordinated by throwing an exception when we detect the poly nature
&gt; of the message send.

Sure, take a look at the patch I posted already, it is work in progress and
can stand for quite a bit of polish. I haven&apos;t studied the problem fully well
to know if better models than throwing exception is possible.

BTW, pertinent to what you noted elsewhere about weak inference due to the 
absence of target: the patch throws an exception only when target type is
absolutely required. This may not be correct for Java 8.

&gt; Srikanth, please let me know when you have some cycles to work on this.

Sure: Code assist (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422468) is
killing me :) In just a couple of days I should be done.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2336944</commentid>
    <comment_count>49</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-03 07:50:54 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #48)
&gt; (In reply to Stephan Herrmann from comment #47)
&gt; &gt; The more fundamental issue, which I&apos;d like to co-operate on, is the
&gt; &gt; integration of PolyTypeBinding for MessageSends with type inference,
&gt; &gt; possibly coordinated by throwing an exception when we detect the poly nature
&gt; &gt; of the message send.
&gt; 
&gt; Sure, take a look at the patch I posted already, it is work in progress and
&gt; can stand for quite a bit of polish. I haven&apos;t studied the problem fully well
&gt; to know if better models than throwing exception is possible.

I think I need your help to identify and polish the parts needed for inference.

&gt; &gt; Srikanth, please let me know when you have some cycles to work on this.
&gt; 
&gt; Sure: Code assist (https://bugs.eclipse.org/bugs/show_bug.cgi?id=422468) is
&gt; killing me :)

OH NO!!!

&gt; In just a couple of days I should be done.

So we have an appointment for Thursday, it seems :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2337304</commentid>
    <comment_count>50</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-03 18:31:24 -0500</bug_when>
    <thetext>Time to take stock of changes since comment 42 (current corresponding commit is http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=5204e01613cd10256db86b8603542424c3ad02ee)

I made a full round of all compiler.regression.TestAll, fixing various issues on the way:

- implemented reduction of LambdaExpressions

- impl. CaptureBinding18.isCompatibleWith(..): compatible to upper bound

- implement null checking of &apos;@NonNull T&apos; if T is inferred to &apos;null&apos;.
  (we don&apos;t want to create a binding for &apos;@NonNull null&apos;, do we? :) )

- unify handling of MessageSend, AllocationExpression, ExplicitConstructorCall
  using new abstraction &quot;Invocation&quot;; use only this during inference.
  Treat ctor.declaringClass as the invocation&apos;s returnType.
  =&gt; better inference for diamonds

- in javadoc super-ctor analysis was getting too smart with this inference,
  need to use asRawMethod to analyse parameter correspondence.

- analysis for redundant type parameters must now fake a diamond to trigger
  inference, which depends on isPolyExpression().

- when resolving a ReferenceExpression in the middle of inference, we may
  end up calling InferenceVariable.isCompatibleWith(). In such situations
  its best to consider inference variables as compatible to all.
  (Inference will never directly ask this, and inference variables should
  never escape inference)

- Lots of adjustments of test, mostly because inference finds more/better
  solutions.

In all of compiler.regression.TestAll I&apos;m down to approx. 44 failures (some are intermittent, like depending on random order in error messages). NONE of these failures are blocking IMHO. Lots of diamond, lambda and reference expression situations are already correctly handled.

Hot on my agenda: hook up inference for conditional expressions, which, too, gets a lot smarter in 1.8.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2337364</commentid>
    <comment_count>51</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-03 22:59:22 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #47)

&gt; The more fundamental issue, which I&apos;d like to co-operate on, is the
&gt; integration of PolyTypeBinding for MessageSends with type inference,
&gt; possibly coordinated by throwing an exception when we detect the poly nature
&gt; of the message send.

See that we can&apos;t throw an exception to signal the poly nature of the message send
(e.g as done in the prototype on the other bug) for two reasons: (e.

    - This in itself does not allow for constraints to be lifted up. Even if
      this is solved:
    - There could be more than one potentially applicable generic method at
      a nested call site. If the first one throws an exception and manages
      somehow bubble up its constraints at the aggregated equation solving site,
      we will be missing the constraints from the 2 and subsequent potentially
      applicable generic methods.

Perhaps it is a bit early to be thinking about it, but It looks to me we need new 
abstractions: UnresolvedParameterizedGenericMethodBinding and a PolyMethodBinding.
Perhaps UnionTypeBinding and a beefed up IntersectionTypeBinding.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2338242</commentid>
    <comment_count>52</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-05 11:50:55 -0500</bug_when>
    <thetext>Look Ma, no exceptions!
:)

I&apos;ve pushed  http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=b2095c86e12d72811582952d0e8a54029849500d

In that commit you can see a solution that allows us do the required lifting of inference constraints from an inner invocation to its outer - all without throwing any inference specific exceptions, but essentially by performing inference by the book:

If inference happens in a context that is not VANILLA_CONTEXT and if the expected type is still unknown (null), we only perform invocation applicability inference (see the change in ParameterizedGenericMethodBinding) *not* invocation type inference.

When an invocation resolves its arguments &amp; finds that the argument is an invocation with inferenceKind() &gt; 0 (i.e., inference is involved), then we remember polyExpressionSeen (using the existing local) (see changes in AllocationExpression, MessageSend &amp; ExplicitConstructorCall).

In all invocations I extracted the part doing the MethodBinding lookup into findConstructorBinding(), resp., MethodBinding.findMethodBinding(). In these twin methods I simply do:

  lookup
  if (polyExpressionSeen)
    if (resolvePolyExpressionArguments(..))
      lookup

For this to work I modified resolvePolyExpressionArguments(): If argument is an Invocation perform Invocation Type inference (the part previously skipped). If successful, update the method binding in the invocation and also update one type in argumentTypes[] for downstream soundness checks. True is returned if an update has been performed to signal that method binding lookup should be repeated.

Some infrastructure additions/changes to support the above:

- Store the InferenceContext18 in all Invocations to resume inference later
- Expose expressionContext and inferenceContext from all Invocations

Also contained: two corrections in CaptureBinding18:
- Enable method lookup through a capture binding according to 15.12.1 (old)
- Consider all upper bounds during compatibility checks, treat as intersection

This commit fixes bug 423070 plus a regression in GTT.test1031()</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2338447</commentid>
    <comment_count>53</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-05 19:26:10 -0500</bug_when>
    <thetext>*** Bug 423070 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2338987</commentid>
    <comment_count>54</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-07 07:35:55 -0500</bug_when>
    <thetext>Notes about integrating ReferenceExpression into the inference:

The body of work for resolving ReferenceExpression has already been done including some trickery with PolyTypeBinding etc., nice work! What&apos;s needed for inference is just flipping a few switches:

- all functional expressions are always poly as per part D intro (0.7.0)

- reference expressions need to provide an InferenceContext18 to participate in inference

- we need to differentiate two kinds of asking expectedType(): normally its exactly what type the outer context provided as expected type, but when a FunctionalExpressions mimics as an InvocationSite for inference, we pretend an actual *invocation* of the SAM. Hence in this context the target type for method lookup is the *return type* of the expected SAM. (Usage by CompletionEngine should be unaffected by this - hence splitting into two methods).

- expect the situation where during inference RE.resolveType finds a SAM referencing an inference variable in its signature. Need to short-circuit isCompatibleWith() calls, since we can&apos;t yet give an answer.

The above has been implemented as per http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=7bf7a1c5b4e8c6a986d5bd01c34d7901a6b364a6


I see potential for optimization by caching the results of RE.resolveType() per expected type. I didn&apos;t yet implement this, because it wasn&apos;t immediately clear which fields need caching, simply caching only the #resolvedType didn&apos;t cut it.


A little insight from debugging:
I was surprised that inference sometimes happens in different nested levels, instead of lifting more constraints into the outer inference. The basic trigger for starting a nested inference is the first item in 18.2.1:
  &quot;If T is a proper type, the constraint reduces to true if the expression is compatible in a loose invocation context with T&quot;

For a ReferenceExpression computing compatibility indeed requires a nested inference. Lifting only happens, if T mentions any inference variables. The apparent reason behind this: if T is already known, lifting can no longer influence the inner inference, hence inference can indeed happen in isolation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2339001</commentid>
    <comment_count>55</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-07 10:53:39 -0500</bug_when>
    <thetext>For the existing test GenericsRegressionTest.testBug415734() the new inference actually found a solution, but I was alerted by the facts that
(a) javac8 no longer accepts this
(b) our solution would break intermittently.

Turned out to be a positive bug (spec bug) and half a negative bug (implementation bug) to yield just half a bug.

I&apos;ve filed bug 423496 to follow up, once a new spec rule becomes available.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2339041</commentid>
    <comment_count>56</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-07 15:57:20 -0500</bug_when>
    <thetext>I&apos;ve filed two new bugs for unimplemented parts of the spec:

Bug 423504 - [1.8] Implement &quot;18.5.3 Functional Interface Parameterization Inference&quot;

Bug 423505 - [1.8] Implement &quot;18.5.4 More Specific Method Inference&quot;


I don&apos;t see any existing test cases affected by the lack. I&apos;d highly welcome if s.o. contributes some test cases for these areas :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2339052</commentid>
    <comment_count>57</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-07 16:23:17 -0500</bug_when>
    <thetext>I made a full round of cleanup with special focus on changes made in existing classes. These I consider to be ready for review any time now - at your convenience, Srikanth.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2339067</commentid>
    <comment_count>58</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-07 18:47:16 -0500</bug_when>
    <thetext>After clarification on the EG list [1] I wrapped up the task around GenericTypeTest.test0939():

Inference must generally include type parameters of enclosing types during subtype reduction (18.2.3 bullet 5.2 fails to mention this). Fixed and test improved by invoking a method on the inferred type (this technique challenges the inference result without pushing an expected type into the inference, which would skew the outcome).

This fix caused many regressions in GenericsRegressionTest_1_7, mostly related to bug 345968. The symptom was that the above fix pulled &quot;alien&quot; type variables into the inference, which could not be resolved, because they do not participate in substitution with inference variables. This could be fixed inside Scope.getStaticFactory(..): be careful to not lose the concrete type argument from originalEnclosingType. In this situation, allocationType is the generic type and thus using allocationType.enclosingType() pulled in the non-inferrable type variable.

[1] http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000449.html</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2339165</commentid>
    <comment_count>59</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-08 18:40:02 -0500</bug_when>
    <thetext>*** Bug 401783 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340249</commentid>
    <comment_count>60</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-10 19:54:49 -0500</bug_when>
    <thetext>Here&apos;s some significant progress driven by the example from bug 419048:

Fixed an assumed spec bug see http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000460.html
(ask me how I found that one, phew!)

Improved Scope.substitution to handle inference variables which represent arbitrary types, not just type variables. For this purpose I invented a nested class Scope.Substitutor and created an indirection from the existing static methods, in order to enable OOP, viz. overriding one variant of substitute with our own preamble.


What&apos;s more complex in terms of code changes: how we detect how much work resolveType should perform for poly expressions at different points in time, when to report/suppress error reports, how much to clean up after tentative resolves ...

To start organize this business I invented two methods in Expression:
- resolveTentatively(BlockScope scope, TypeBinding targetType)
- checkAgainstFinalTargetType(TypeBinding targetType)
These roughly correspond to the two main phases of inference.

For phase 1 a few more methods are introduced in FunctionalExpression:
- findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope)
- internalResolveTentatively(TypeBinding targetType, Scope scope)
- cleanUpAfterTentativeResolve()
It turned out, *a lot* of clean up is necessary to avoid influencing subsequent work. Notably, LE.cleanUpAfterTentativeResolve() even has to remove any traces of lambda arguments which may have been resolved to the wrong type, including references to these arguments from the lambda body ...

In ReferenceExpression I stumbled over an exactMethodBinding that still needed to apply explicit type arguments - not sure if this is intended??


Another dimension relates to marking inference progress into poly expressions, to avoid spurious resolving after inference has already given a definite answer. The tiny new interface PolyExpression lets clients set and query this information. Currently the following classes participate in this protocol: FunctionalExpression, AllocationExpression, ExplicitConstructorCall, MessageSend.


Much of the above is combined into more smarts in ASTNode.resolvePolyExpressionArguments(). Here we coordinate type information from an outer lookup (inference?) with re-resolving inner expressions (arguments) and finally triggering another method lookup of the outer with new argument types. See comments in that method.


A related method is InferenceContext18.rebindInnerPolies(), which propagates type information from an outer inference into poly expressions that have been included in the inference. Also this method has been significantly improved. 


With this in place we successfully infer types across multiple levels of poly invocations / lambdas.

The commit corresponding to this status is http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=d72b33df7e926bdba104646a573cf60af359abd4</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340250</commentid>
    <comment_count>61</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-10 20:12:43 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #60)
&gt; Here&apos;s some significant progress driven by the example from bug 419048:
&gt; 
&gt; What&apos;s more complex in terms of code changes: how we detect how much work
&gt; resolveType should perform for poly expressions at different points in time,
&gt; when to report/suppress error reports, how much to clean up after tentative
&gt; resolves ...

Stephan, did you look at my earlier patch for generic methods in message send ?
That had a prototype for resolveTypeExpecting which I think probably serves the 
same purpose as the tentative resolve you have in mind. That would have taken
care of clean ups because for lambda&apos;s it operates on a copy().

&gt; For phase 1 a few more methods are introduced in FunctionalExpression:
&gt; - findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope)
&gt; - internalResolveTentatively(TypeBinding targetType, Scope scope)
&gt; - cleanUpAfterTentativeResolve()


Again, there was a ReferenceExpression.resolveTypeExpecting which handled
cleanups. 

The resolveTypeExpecting and isCompatibleWith were intended to be used for
multiple look ups with no stale data being carried over between lookups.

&gt; In ReferenceExpression I stumbled over an exactMethodBinding that still
&gt; needed to apply explicit type arguments - not sure if this is intended??

A method reference is exact only if explicit type arguments are provided
for a generic method.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340251</commentid>
    <comment_count>62</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-10 20:38:22 -0500</bug_when>
    <thetext>Looking at the example referenced in bug 418807:

The collect(..) call is now accepted, but now we have trouble with the constructor reference:

----------
1. ERROR in /tmp/Word.java (at line 20)
        Stream&lt;Word&gt; ws = names.stream().map(Word::new);
                                         ^^^
The method map(Function&lt;? super String,? extends R&gt;) in the type Stream&lt;String&gt; is not applicable for the arguments (Word::new)
----------
2. ERROR in /tmp/Word.java (at line 20)
        Stream&lt;Word&gt; ws = names.stream().map(Word::new);
                                             ^^^^^^^^^
The constructed object of type Word is incompatible with the descriptor&apos;s return type: R
----------

I didn&apos;t yet pay much attention to constructor references, sounds like I should look into these, next.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340253</commentid>
    <comment_count>63</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-10 20:52:25 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #61)
&gt; (In reply to Stephan Herrmann from comment #60)
&gt; &gt; Here&apos;s some significant progress driven by the example from bug 419048:
&gt; &gt; 
&gt; &gt; What&apos;s more complex in terms of code changes: how we detect how much work
&gt; &gt; resolveType should perform for poly expressions at different points in time,
&gt; &gt; when to report/suppress error reports, how much to clean up after tentative
&gt; &gt; resolves ...
&gt; 
&gt; Stephan, did you look at my earlier patch for generic methods in message
&gt; send ?
&gt; That had a prototype for resolveTypeExpecting which I think probably serves
&gt; the 
&gt; same purpose as the tentative resolve you have in mind. That would have taken
&gt; care of clean ups because for lambda&apos;s it operates on a copy().

I had a brief look at that, yes. Maybe that would have killed my bird, too, but I didn&apos;t understand that patch well enough for adopting it.
I may have missed one or two details but basically my latest commit seems to achieve the same without copying

Maybe this approach is too naive, but it helped me figure out the effect on inference and fix bugs there. I&apos;m happy to discuss those integration parts as soon as you have some cycles to review portions of my code.
 
&gt; &gt; For phase 1 a few more methods are introduced in FunctionalExpression:
&gt; &gt; - findCompileTimeMethodTargeting(TypeBinding targetType, Scope scope)
&gt; &gt; - internalResolveTentatively(TypeBinding targetType, Scope scope)
&gt; &gt; - cleanUpAfterTentativeResolve()
&gt; 
&gt; 
&gt; Again, there was a ReferenceExpression.resolveTypeExpecting which handled
&gt; cleanups. 
&gt; The resolveTypeExpecting and isCompatibleWith were intended to be used for
&gt; multiple look ups with no stale data being carried over between lookups.

Yes, actually I started by copying from one of these methods - and added more cleanup as it showed necessary. So the business of switching error reporting policies is directly copied from there.

 
&gt; &gt; In ReferenceExpression I stumbled over an exactMethodBinding that still
&gt; &gt; needed to apply explicit type arguments - not sure if this is intended??
&gt; 
&gt; A method reference is exact only if explicit type arguments are provided
&gt; for a generic method.

Good, so shouldn&apos;t these type arguments be applied before assigning exactMethodBinding? According to my observations an env.createParameterizedMethod(..) call was still necessary before using what I found in exactMethodBinding.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340259</commentid>
    <comment_count>64</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-10 23:04:31 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #63)

&gt; Maybe this approach is too naive, but it helped me figure out the effect on
&gt; inference and fix bugs there. I&apos;m happy to discuss those integration parts
&gt; as soon as you have some cycles to review portions of my code.

I think you did the right thing by proceeding by putting together a version
that meets your needs so you are not blocked. Yes, let us discuss this later 
at the time of code review to ensure that we have a minimal, coherent APIs.


(The way I had envisioned (without having understood part G fully) was that
nobody outside of LE would use anything other than isCompatibleWith,
resolveTypeExpecting and sIsMoreSpecific - i.e result expressions,
void/value compatibility checks etc would happen implicitly without there
being separate APIs - don&apos;t know that this is possible, certainly for thrown
exceptions we need something because the threesome mentioned does not copy
with exceptions.)

&gt; Good, so shouldn&apos;t these type arguments be applied before assigning
&gt; exactMethodBinding? According to my observations an
&gt; env.createParameterizedMethod(..) call was still necessary before using what
&gt; I found in exactMethodBinding.

yes, this is an oversight that needs to be fixed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2340827</commentid>
    <comment_count>65</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-11 18:28:41 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #64)
&gt; (The way I had envisioned (without having understood part G fully) was that
&gt; nobody outside of LE would use anything other than isCompatibleWith,
&gt; resolveTypeExpecting and sIsMoreSpecific - i.e result expressions,
&gt; void/value compatibility checks etc would happen implicitly without there
&gt; being separate APIs - don&apos;t know that this is possible, certainly for thrown
&gt; exceptions we need something because the threesome mentioned does not copy
&gt; with exceptions.)

Inference needs a few kind-of unexpected queries. I wondered how to best identify all calls from a given set of classes into another set of classes. Shouldn&apos;t JDT be the right tool to thus identify all calls &quot;from inference&quot; &quot;into AST&quot;? :)

OTOH, the number of such calls isn&apos;t large, we should be able to find and examine all these locations during code review. In fact I consider the new API introduced yesterday more important than it&apos;s implementation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341243</commentid>
    <comment_count>66</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-12 13:59:04 -0500</bug_when>
    <thetext>*** Bug 423839 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341298</commentid>
    <comment_count>67</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-12 16:25:05 -0500</bug_when>
    <thetext>The next batch of changes was driven by bug 423839, which features a diamond inside a ternary inside a generic invocation (status corresponds to http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=c03bb7b6b1cd8a6d883d640a383ab0d92ad4b43b )

To cope with ternary expressions I had to overhaul ASTNode.resolvePolyExpressionArguments() (candidate to being pushed into AST classes). This method now
- descends into ConditionalExpression
- returns a marker POLY_ERROR TypeBinding to signal that we should update 
  nothing because some inner poly has an error
- detects poly allocations although they no longer have a PolyTypeBinding
  (s.below)


To let diamond allocations fully participate in inference (similar to generic methods) I made the following changes:
- AllocationExpression.resolveType(..) no longer returns early with a
  PolyTypeBinding but does a best effort at resolving a method binding as
  a starting point for inference.
- This required to use isPolyExpression() in more places rather than
  &apos;instanceof PolyTypeBinding&apos;
- Type parameters will be inferred only later, using invocation type inference
- To avoid type check errors in this preliminarily resolved state I derive
  the candidate method from a raw type
- Rawness warnings are suppressed during this phase by skipping
  checkInvocationArguments()
- diamonds now answer false to isPertinentToApplicability
  (*assuming* that this is what the spec intends to say)


Inside the inference engine diamonds are considered:
- Recognize diamonds
- Include class level type variables in inference (not mentioned in spec?)
- When all is said and done, InferenceContext18.rebindInnerPolies() updates
  class level type arguments of inner diamonds with inference solutions.


We are now doing even more duplicate resolves. Since resolve isn&apos;t safe against duplicate invocations, I started implementing a general Expression.unresolve(), to be overridden appropriately - currently only in NameReference. Called for message receivers and arguments at this point. Candidate to replacement by a copy mechanism, whichever works out better.

Finally, I made a start at improving error reporting: by connecting ProblemMethodBindings to InferenceContext18, and inner contexts to outer contexts, ProblemReporter.invalidMethod() can now see if an outer context exists and defer reporting to that context. No big deal yet, but may well support the idea to delegate much error reporting to the InferenceContext eventually.

We have one more regression now: OverloadResolutionTest8.test032() which doesn&apos;t seem to perform full inference against both candidate methods.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341327</commentid>
    <comment_count>68</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-12 17:50:56 -0500</bug_when>
    <thetext>While fixing bug 414631 I had to make these changes:

Before introducing a lambda body or its result expressions into inference, we need to resolve them (sigh!), because inference needs to know the type. This will require more unresolving or working with the lambda&apos;s copy...

During reduction of an expression compatibility constraint, we need to check whether the expression is a poly expression. When the expression is the body of a lambda that&apos;s both value compatible and void compatible then we don&apos;t know the expression context (vanilla or assignment), but we need to assume &apos;assignment&apos; to be able to infer a corresponding solution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341332</commentid>
    <comment_count>69</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-12 17:52:42 -0500</bug_when>
    <thetext>*** Bug 414631 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341360</commentid>
    <comment_count>70</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-12-12 19:51:59 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #67)

&gt; We are now doing even more duplicate resolves. Since resolve isn&apos;t safe
&gt; against duplicate invocations, I started implementing a general
&gt; Expression.unresolve(), to be overridden appropriately - currently only in
&gt; NameReference. Called for message receivers and arguments at this point.
&gt; Candidate to replacement by a copy mechanism, whichever works out better.

I went down that path earlier - it is full of land mines. I think given there
are just a handful of poly-expressions, on a case by case basis we should look
at (a) whether their resolveType methods could be clearly organized into
&quot;once-only&quot; vs &quot;once-per candidate target type&quot; evaluations and then look at
the latter path to see the state to involved to decide whether we should 
save/restore or (b) opt for a copy.

For example for ReferenceExpressions, everything falls neatly in place that
we don&apos;t copy() them, neither do need a unresolve() capability. For Lambda&apos;s
we go for copy()/

Earlier comments in this bug and elsewhere have documented the problems with
approaches to resolution clean up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341912</commentid>
    <comment_count>71</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-14 10:44:36 -0500</bug_when>
    <thetext>Work on bug 424038 further improves the interaction between type inference and LambdaExpression &amp; AllocationExpression.

- I was wrong in providing AllocationExpression.isPertinentToApplicability(), these are *never* pertinent ...

- LambdaExpression.isPertinentToApplicability() was missing a check for the case of single expression bodies, fixed.

- Inference now always pretends an assignment context when resolving against a known target type.
This method (ConstraintExpressionFormula.ensureResolved(..)) may, however, be obsoleted by the following change:

- Before inference reduces a compatibility constraint against a lambda expression, we now obtain a copy using a new method LambdaExpression.getResolvedCopyForInferenceTargeting(TypeBinding). This method is a modified extract from LambdaExpression.isCompatibleWith(..). Here copying seems to be the exact right thing to do, because inference will produce some bindings into this copy, which are not final results and should be discarded after inference. In contrast to isCompatibleWith the new method allows inference to perform several checks on the copy and produce new constraints against the copy&apos;s resolved result expressions. See ConstraintExpressionFormula.reduce(..) for usage.

Status corresponds to http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NewTypeInference&amp;id=24dd8ebf7370eee61f1fead599354a5fdf56a8e1</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341914</commentid>
    <comment_count>72</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-14 10:46:05 -0500</bug_when>
    <thetext>*** Bug 424038 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341916</commentid>
    <comment_count>73</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-14 10:52:47 -0500</bug_when>
    <thetext>Moving remaining child bugs to a new home in bug 424053.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341917</commentid>
    <comment_count>74</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-14 11:02:05 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #71)
&gt; - I was wrong in providing
&gt; AllocationExpression.isPertinentToApplicability(), these are *never*
&gt; pertinent ...

Oops, should say: &quot;*always* pertinent&quot;, as answered by Expression.isPertinentToApplicability()</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2341938</commentid>
    <comment_count>75</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-12-14 15:24:32 -0500</bug_when>
    <thetext>The first phase of implementing type inference according to part G of JSR 335 spec has been completed. I pushed all changes into BETA_JAVA8 via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=6940f5238f5f044dc7dc7f5472f64a2c5617a365

Follow-up work incl various levels of reviewing will be organized via bug 424053 into which I will soon extract all those questions from this bug that are still relevant.

This terminates the development in branch sherrmann/NewTypeInference, which is, however, left on the server to preserve the (fine grained) history.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="1"
              isprivate="0"
          >
            <attachid>237885</attachid>
            <date>2013-11-30 22:12:00 -0500</date>
            <delta_ts>2013-12-01 12:47:28 -0500</delta_ts>
            <desc>Patch that may have some useful APIs</desc>
            <filename>PMTIlast.patch</filename>
            <type>text/plain</type>
            <size>54913</size>
            <attacher name="Srikanth Sankaran">srikanth_sankaran</attacher>
            
              <data encoding="base64">ZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLmNvbXBpbGVyL3NyYy9vcmcv
ZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9uL0dlbmVyaWNUeXBlVGVz
dC5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9lY2xp
cHNlL2pkdC9jb3JlL3Rlc3RzL2NvbXBpbGVyL3JlZ3Jlc3Npb24vR2VuZXJpY1R5cGVUZXN0Lmph
dmEKaW5kZXggNDBlMGIxMC4uYjEyM2U3YSAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNv
cmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2NvbXBpbGVy
L3JlZ3Jlc3Npb24vR2VuZXJpY1R5cGVUZXN0LmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0LmNv
cmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2NvbXBpbGVy
L3JlZ3Jlc3Npb24vR2VuZXJpY1R5cGVUZXN0LmphdmEKQEAgLTI0MjcxLDE3ICsyNDI3MSwyNCBA
QAogCQkJIgl9CVxuIiArCiAJCQkifSBcbiIsCiAJCX0sCi0JCSItLS0tLS0tLS0tXG4iICsKLQkJ
IjEuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSAxNilcbiIgKwotCQkiCVg8SW50ZWdlcj4geDIg
PSBpdHNlbGYobWFrZSgpKTtcbiIgKwotCQkiCSAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5e
XlxuIiArCi0JCSJUeXBlIG1pc21hdGNoOiBjYW5ub3QgY29udmVydCBmcm9tIFg8T2JqZWN0PiB0
byBYPEludGVnZXI+XG4iICsKLQkJIi0tLS0tLS0tLS1cbiIgKwotCQkiMi4gRVJST1IgaW4gWC5q
YXZhIChhdCBsaW5lIDE5KVxuIiArCi0JCSIJWDxJbnRlZ2VyPiB4MiA9IGl0c2VsZigoWDxJbnRl
Z2VyPiltYWtlKCkpO1xuIiArCi0JCSIJICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5e
Xl5eXl5eXl5cbiIgKwotCQkiQ2Fubm90IGNhc3QgZnJvbSBYPE9iamVjdD4gdG8gWDxJbnRlZ2Vy
PlxuIiArCi0JCSItLS0tLS0tLS0tXG4iKTsKKwkJdGhpcy5jb21wbGlhbmNlTGV2ZWwgPCBDbGFz
c0ZpbGVDb25zdGFudHMuSkRLMV84ID8gCisJCQkiLS0tLS0tLS0tLVxuIiArCisJCQkiMS4gRVJS
T1IgaW4gWC5qYXZhIChhdCBsaW5lIDE2KVxuIiArCisJCQkiCVg8SW50ZWdlcj4geDIgPSBpdHNl
bGYobWFrZSgpKTtcbiIgKworCQkJIgkgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiIg
KworCQkJIlR5cGUgbWlzbWF0Y2g6IGNhbm5vdCBjb252ZXJ0IGZyb20gWDxPYmplY3Q+IHRvIFg8
SW50ZWdlcj5cbiIgKworCQkJIi0tLS0tLS0tLS1cbiIgKworCQkJIjIuIEVSUk9SIGluIFguamF2
YSAoYXQgbGluZSAxOSlcbiIgKworCQkJIglYPEludGVnZXI+IHgyID0gaXRzZWxmKChYPEludGVn
ZXI+KW1ha2UoKSk7XG4iICsKKwkJCSIJICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5e
Xl5eXl5eXl5cbiIgKworCQkJIkNhbm5vdCBjYXN0IGZyb20gWDxPYmplY3Q+IHRvIFg8SW50ZWdl
cj5cbiIgKworCQkJIi0tLS0tLS0tLS1cbiIgOgorCQkJCSItLS0tLS0tLS0tXG4iICsKKwkJCQki
MS4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDE5KVxuIiArCisJCQkJIglYPEludGVnZXI+IHgy
ID0gaXRzZWxmKChYPEludGVnZXI+KW1ha2UoKSk7XG4iICsKKwkJCQkiCSAgICAgICAgICAgICAg
ICAgICAgICAgXl5eXl5eXl5eXl5eXl5eXl5eXG4iICsKKwkJCQkiQ2Fubm90IGNhc3QgZnJvbSBY
PE9iamVjdD4gdG8gWDxJbnRlZ2VyPlxuIiArCisJCQkJIi0tLS0tLS0tLS1cbiIpOwogfQogLy9o
dHRwczovL2J1Z3MuZWNsaXBzZS5vcmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9MTAwNDIxCiBwdWJs
aWMgdm9pZCB0ZXN0MDc2MSgpIHsKQEAgLTI4Nzk2LDEyICsyODgwMywxMyBAQAogCQkJIgl9XG4i
ICsKIAkJCSJ9XG4iLAogCQl9LAotCQkiLS0tLS0tLS0tLVxuIiArCi0JCSIxLiBFUlJPUiBpbiBU
ZXN0LmphdmEgKGF0IGxpbmUgMTgpXG4iICsKLQkJIglTdHJpbmcgcyA9IGFwcGx5VG9TdHJpbmco
aWRlbnRpdHkoKSk7XG4iICsKLQkJIgkgICAgICAgICAgIF5eXl5eXl5eXl5eXl5cbiIgKwotCQki
VGhlIG1ldGhvZCBhcHBseVRvU3RyaW5nKEZ1bmN0aW9uPFN0cmluZyxCPikgaW4gdGhlIHR5cGUg
VGVzdCBpcyBub3QgYXBwbGljYWJsZSBmb3IgdGhlIGFyZ3VtZW50cyAoSWQ8T2JqZWN0PilcbiIg
KwotCQkiLS0tLS0tLS0tLVxuIik7CisJCXRoaXMuY29tcGxpYW5jZUxldmVsIDwgQ2xhc3NGaWxl
Q29uc3RhbnRzLkpESzFfOCA/IAorCQkJIi0tLS0tLS0tLS1cbiIgKworCQkJIjEuIEVSUk9SIGlu
IFRlc3QuamF2YSAoYXQgbGluZSAxOClcbiIgKworCQkJIglTdHJpbmcgcyA9IGFwcGx5VG9TdHJp
bmcoaWRlbnRpdHkoKSk7XG4iICsKKwkJCSIJICAgICAgICAgICBeXl5eXl5eXl5eXl5eXG4iICsK
KwkJCSJUaGUgbWV0aG9kIGFwcGx5VG9TdHJpbmcoRnVuY3Rpb248U3RyaW5nLEI+KSBpbiB0aGUg
dHlwZSBUZXN0IGlzIG5vdCBhcHBsaWNhYmxlIGZvciB0aGUgYXJndW1lbnRzIChJZDxPYmplY3Q+
KVxuIiArCisJCQkiLS0tLS0tLS0tLVxuIjogIiIpOwogfQogLy9odHRwczovL2J1Z3MuZWNsaXBz
ZS5vcmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9MTI2MTgwCiBwdWJsaWMgdm9pZCB0ZXN0MDg5Migp
IHsKQEAgLTQzNzMzLDQxICs0Mzc0MSw4NCBAQAogfQogLy9odHRwczovL2J1Z3MuZWNsaXBzZS5v
cmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9MjE2Njg2IC0gdmFyaWF0aW9uCiBwdWJsaWMgdm9pZCB0
ZXN0MTI3MygpIHsKLQl0aGlzLnJ1bkNvbmZvcm1UZXN0KAotCQkJbmV3IFN0cmluZ1tdIHsKLQkJ
CQkJIlguamF2YSIsCi0JCQkJCSJwdWJsaWMgY2xhc3MgWCB7XG4iICsKLQkJCQkJIgkvLyBzb21l
IGZ1bmN0b3IgYW5kIGZ1bmN0b3IgaW5zdGFuY2VzIGRlZmluaXRpb25zXG4iICsKLQkJCQkJIglz
dGF0aWMgaW50ZXJmYWNlIE9PPFQsIEU+IHsgXG4iICsKLQkJCQkJIgkJcHVibGljIFQgZXZhbChF
IHgpO1xuIiArCi0JCQkJCSIJfVxuIiArCi0JCQkJCSIJc3RhdGljIGludGVyZmFjZSBUTzxUPiBl
eHRlbmRzIE9PPFN0cmluZywgVD4ge1xuIiArCi0JCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChU
IHgpO1xuIiArCi0JCQkJCSIJfVxuIiArCi0JCQkJCSIJc3RhdGljIGludGVyZmFjZSBUVCBleHRl
bmRzIFRPPFN0cmluZz4ge1xuIiArCi0JCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChTdHJpbmcg
eCk7XG4iICsKLQkJCQkJIgl9XG4iICsKLQkJCQkJIglzdGF0aWMgZmluYWwgVE88T2JqZWN0PiBG
VU5DMSA9IG51bGw7XG4iICsKLQkJCQkJIglzdGF0aWMgZmluYWwgVFQgRlVOQzIgPSBudWxsO1xu
IiArCi0JCQkJCSJcbiIgKwotCQkJCQkiCS8vIHNvbWUgZnVuY3RvciBjb21iaW5hdG9yc1xuIiAr
Ci0JCQkJCSIJc3RhdGljIDxFPiBUTzxFPiBjb21iaW5lKGZpbmFsIFRUIHgsIGZpbmFsIFRPPD8g
c3VwZXIgRT4geSkgeyAvLyAjIDFcbiIgKwotCQkJCQkiCQlTeXN0ZW0ub3V0LnByaW50bG4oXCIj
MSNcIik7XG4iICsKLQkJCQkJIgkJcmV0dXJuIG5ldyBUTzxFPigpIHsgcHVibGljIFN0cmluZyBl
dmFsKEUgbykgeyByZXR1cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTsgXG4iICsKLQkJCQkJIgl9
XG4iICsKLQkJCQkJIglzdGF0aWMgPEUsIFQ+IFRPPFQ+IGNvbWJpbmUoZmluYWwgVE88PyBzdXBl
ciBFPiB4LCBmaW5hbCBPTzxFLCBUPiB5KSB7IC8vICMgMlxuIiArCi0JCQkJCSIJCVN5c3RlbS5v
dXQucHJpbnRsbihcIiMyI1wiKTtcbiIgKwotCQkJCQkiCQlyZXR1cm4gbmV3IFRPPFQ+KCkgeyBw
dWJsaWMgU3RyaW5nIGV2YWwoVCBvKSB7IHJldHVybiB4LmV2YWwoeS5ldmFsKG8pKTsgfSB9OyBc
biIgKwotCQkJCQkiCX1cbiIgKwotCQkJCQkiCS8vIGJvZHkgb2YgdGhlIHRlc3RcbiIgKwotCQkJ
CQkiCXN0YXRpYyA8RT4gdm9pZCBwdXQoQ2xhc3M8RT4gdHlwZSwgVE88PyBzdXBlciBFPiBmdW5j
KSB7XG4iICsKLQkJCQkJIgl9XG4iICsKLQkJCQkJIglwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihT
dHJpbmdbXSBhcmdzKSB7XG4iICsKLQkJCQkJIgkJcHV0KEludGVnZXIuY2xhc3MsIGNvbWJpbmUo
RlVOQzIsIEZVTkMxKSk7XG4iICsKLQkJCQkJIgl9XG4iICsKLQkJCQkJIn1cbiIsIC8vID09PT09
PT09PT09PT09PT09Ci0JCQl9LAotCQkJIiMxIyIpOworCWlmICh0aGlzLmNvbXBsaWFuY2VMZXZl
bCA8IENsYXNzRmlsZUNvbnN0YW50cy5KREsxXzgpIHsKKwkJdGhpcy5ydW5Db25mb3JtVGVzdCgK
KwkJCQluZXcgU3RyaW5nW10geworCQkJCQkJIlguamF2YSIsCisJCQkJCQkicHVibGljIGNsYXNz
IFgge1xuIiArCisJCQkJCQkiCS8vIHNvbWUgZnVuY3RvciBhbmQgZnVuY3RvciBpbnN0YW5jZXMg
ZGVmaW5pdGlvbnNcbiIgKworCQkJCQkJIglzdGF0aWMgaW50ZXJmYWNlIE9PPFQsIEU+IHsgXG4i
ICsKKwkJCQkJCSIJCXB1YmxpYyBUIGV2YWwoRSB4KTtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJ
CQkJCSIJc3RhdGljIGludGVyZmFjZSBUTzxUPiBleHRlbmRzIE9PPFN0cmluZywgVD4ge1xuIiAr
CisJCQkJCQkiCQlwdWJsaWMgU3RyaW5nIGV2YWwoVCB4KTtcbiIgKworCQkJCQkJIgl9XG4iICsK
KwkJCQkJCSIJc3RhdGljIGludGVyZmFjZSBUVCBleHRlbmRzIFRPPFN0cmluZz4ge1xuIiArCisJ
CQkJCQkiCQlwdWJsaWMgU3RyaW5nIGV2YWwoU3RyaW5nIHgpO1xuIiArCisJCQkJCQkiCX1cbiIg
KworCQkJCQkJIglzdGF0aWMgZmluYWwgVE88T2JqZWN0PiBGVU5DMSA9IG51bGw7XG4iICsKKwkJ
CQkJCSIJc3RhdGljIGZpbmFsIFRUIEZVTkMyID0gbnVsbDtcbiIgKworCQkJCQkJIlxuIiArCisJ
CQkJCQkiCS8vIHNvbWUgZnVuY3RvciBjb21iaW5hdG9yc1xuIiArCisJCQkJCQkiCXN0YXRpYyA8
RT4gVE88RT4gY29tYmluZShmaW5hbCBUVCB4LCBmaW5hbCBUTzw/IHN1cGVyIEU+IHkpIHsgLy8g
IyAxXG4iICsKKwkJCQkJCSIJCVN5c3RlbS5vdXQucHJpbnRsbihcIiMxI1wiKTtcbiIgKworCQkJ
CQkJIgkJcmV0dXJuIG5ldyBUTzxFPigpIHsgcHVibGljIFN0cmluZyBldmFsKEUgbykgeyByZXR1
cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTsgXG4iICsKKwkJCQkJCSIJfVxuIiArCisJCQkJCQki
CXN0YXRpYyA8RSwgVD4gVE88VD4gY29tYmluZShmaW5hbCBUTzw/IHN1cGVyIEU+IHgsIGZpbmFs
IE9PPEUsIFQ+IHkpIHsgLy8gIyAyXG4iICsKKwkJCQkJCSIJCVN5c3RlbS5vdXQucHJpbnRsbihc
IiMyI1wiKTtcbiIgKworCQkJCQkJIgkJcmV0dXJuIG5ldyBUTzxUPigpIHsgcHVibGljIFN0cmlu
ZyBldmFsKFQgbykgeyByZXR1cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTsgXG4iICsKKwkJCQkJ
CSIJfVxuIiArCisJCQkJCQkiCS8vIGJvZHkgb2YgdGhlIHRlc3RcbiIgKworCQkJCQkJIglzdGF0
aWMgPEU+IHZvaWQgcHV0KENsYXNzPEU+IHR5cGUsIFRPPD8gc3VwZXIgRT4gZnVuYykge1xuIiAr
CisJCQkJCQkiCX1cbiIgKworCQkJCQkJIglwdWJsaWMgc3RhdGljIHZvaWQgbWFpbihTdHJpbmdb
XSBhcmdzKSB7XG4iICsKKwkJCQkJCSIJCXB1dChJbnRlZ2VyLmNsYXNzLCBjb21iaW5lKEZVTkMy
LCBGVU5DMSkpO1xuIiArCisJCQkJCQkiCX1cbiIgKworCQkJCQkJIn1cbiIsIC8vID09PT09PT09
PT09PT09PT09CisJCQkJfSwKKwkJCQkiIzEjIik7CisJfSBlbHNlIHsKKwkJdGhpcy5ydW5OZWdh
dGl2ZVRlc3QoCisJCQkJbmV3IFN0cmluZ1tdIHsKKwkJCQkJCSJYLmphdmEiLAorCQkJCQkJInB1
YmxpYyBjbGFzcyBYIHtcbiIgKworCQkJCQkJIgkvLyBzb21lIGZ1bmN0b3IgYW5kIGZ1bmN0b3Ig
aW5zdGFuY2VzIGRlZmluaXRpb25zXG4iICsKKwkJCQkJCSIJc3RhdGljIGludGVyZmFjZSBPTzxU
LCBFPiB7IFxuIiArCisJCQkJCQkiCQlwdWJsaWMgVCBldmFsKEUgeCk7XG4iICsKKwkJCQkJCSIJ
fVxuIiArCisJCQkJCQkiCXN0YXRpYyBpbnRlcmZhY2UgVE88VD4gZXh0ZW5kcyBPTzxTdHJpbmcs
IFQ+IHtcbiIgKworCQkJCQkJIgkJcHVibGljIFN0cmluZyBldmFsKFQgeCk7XG4iICsKKwkJCQkJ
CSIJfVxuIiArCisJCQkJCQkiCXN0YXRpYyBpbnRlcmZhY2UgVFQgZXh0ZW5kcyBUTzxTdHJpbmc+
IHtcbiIgKworCQkJCQkJIgkJcHVibGljIFN0cmluZyBldmFsKFN0cmluZyB4KTtcbiIgKworCQkJ
CQkJIgl9XG4iICsKKwkJCQkJCSIJc3RhdGljIGZpbmFsIFRPPE9iamVjdD4gRlVOQzEgPSBudWxs
O1xuIiArCisJCQkJCQkiCXN0YXRpYyBmaW5hbCBUVCBGVU5DMiA9IG51bGw7XG4iICsKKwkJCQkJ
CSJcbiIgKworCQkJCQkJIgkvLyBzb21lIGZ1bmN0b3IgY29tYmluYXRvcnNcbiIgKworCQkJCQkJ
IglzdGF0aWMgPEU+IFRPPEU+IGNvbWJpbmUoZmluYWwgVFQgeCwgZmluYWwgVE88PyBzdXBlciBF
PiB5KSB7IC8vICMgMVxuIiArCisJCQkJCQkiCQlTeXN0ZW0ub3V0LnByaW50bG4oXCIjMSNcIik7
XG4iICsKKwkJCQkJCSIJCXJldHVybiBuZXcgVE88RT4oKSB7IHB1YmxpYyBTdHJpbmcgZXZhbChF
IG8pIHsgcmV0dXJuIHguZXZhbCh5LmV2YWwobykpOyB9IH07IFxuIiArCisJCQkJCQkiCX1cbiIg
KworCQkJCQkJIglzdGF0aWMgPEUsIFQ+IFRPPFQ+IGNvbWJpbmUoZmluYWwgVE88PyBzdXBlciBF
PiB4LCBmaW5hbCBPTzxFLCBUPiB5KSB7IC8vICMgMlxuIiArCisJCQkJCQkiCQlTeXN0ZW0ub3V0
LnByaW50bG4oXCIjMiNcIik7XG4iICsKKwkJCQkJCSIJCXJldHVybiBuZXcgVE88VD4oKSB7IHB1
YmxpYyBTdHJpbmcgZXZhbChUIG8pIHsgcmV0dXJuIHguZXZhbCh5LmV2YWwobykpOyB9IH07IFxu
IiArCisJCQkJCQkiCX1cbiIgKworCQkJCQkJIgkvLyBib2R5IG9mIHRoZSB0ZXN0XG4iICsKKwkJ
CQkJCSIJc3RhdGljIDxFPiB2b2lkIHB1dChDbGFzczxFPiB0eXBlLCBUTzw/IHN1cGVyIEU+IGZ1
bmMpIHtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSIJcHVibGljIHN0YXRpYyB2b2lkIG1h
aW4oU3RyaW5nW10gYXJncykge1xuIiArCisJCQkJCQkiCQlwdXQoSW50ZWdlci5jbGFzcywgY29t
YmluZShGVU5DMiwgRlVOQzEpKTtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSJ9XG4iLCAv
LyA9PT09PT09PT09PT09PT09PQorCQkJCX0sCisJCQkJIi0tLS0tLS0tLS1cbiIgKyAKKwkJCQki
MS4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDI4KVxuIiArIAorCQkJCSIJcHV0KEludGVnZXIu
Y2xhc3MsIGNvbWJpbmUoRlVOQzIsIEZVTkMxKSk7XG4iICsgCisJCQkJIgkgICAgICAgICAgICAg
ICAgICAgXl5eXl5eXlxuIiArIAorCQkJCSJUaGUgbWV0aG9kIGNvbWJpbmUoWC5UVCwgWC5UTzw/
IHN1cGVyIEU+KSBpcyBhbWJpZ3VvdXMgZm9yIHRoZSB0eXBlIFhcbiIgKyAKKwkJCQkiLS0tLS0t
LS0tLVxuIik7CisJfQogfQogLy9odHRwczovL2J1Z3MuZWNsaXBzZS5vcmcvYnVncy9zaG93X2J1
Zy5jZ2k/aWQ9MjE2Njg2IC0gdmFyaWF0aW9uCiBwdWJsaWMgdm9pZCB0ZXN0MTI3NCgpIHsKQEAg
LTQzOTIzLDQ1ICs0Mzk3NCw5MiBAQAogfQogLy9odHRwczovL2J1Z3MuZWNsaXBzZS5vcmcvYnVn
cy9zaG93X2J1Zy5jZ2k/aWQ9MjE2Njg2IC0gdmFyaWF0aW9uCiBwdWJsaWMgdm9pZCB0ZXN0MTI3
OCgpIHsKLQl0aGlzLnJ1bkNvbmZvcm1UZXN0KAotCQkJbmV3IFN0cmluZ1tdIHsKLQkJCQkJIlgu
amF2YSIsCi0JCQkJCSJwdWJsaWMgY2xhc3MgWCB7XG4iICsKLQkJCQkJIgkvLyBzb21lIGZ1bmN0
b3IgYW5kIGZ1bmN0b3IgaW5zdGFuY2VzIGRlZmluaXRpb25zXG4iICsKLQkJCQkJIglzdGF0aWMg
aW50ZXJmYWNlIE9PPFQsIEU+IHsgXG4iICsKLQkJCQkJIgkJcHVibGljIFQgZXZhbChFIHgpO1xu
IiArCi0JCQkJCSIJfVxuIiArCi0JCQkJCSIJc3RhdGljIGludGVyZmFjZSBUTzxUPiBleHRlbmRz
IE9PPFN0cmluZywgVD4ge1xuIiArCi0JCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChUIHgpO1xu
IiArCi0JCQkJCSIJfVxuIiArCi0JCQkJCSIJc3RhdGljIGludGVyZmFjZSBUVCBleHRlbmRzIFRP
PFN0cmluZz4ge1xuIiArCi0JCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChTdHJpbmcgeCk7XG4i
ICsKLQkJCQkJIgl9XG4iICsKLQkJCQkJIglzdGF0aWMgZmluYWwgVE88T2JqZWN0PiBGVU5DMSA9
IG51bGw7XG4iICsKLQkJCQkJIglzdGF0aWMgZmluYWwgVFQgRlVOQzIgPSBudWxsO1xuIiArCi0J
CQkJCSJcbiIgKwotCQkJCQkiCS8vIHNvbWUgZnVuY3RvciBjb21iaW5hdG9yc1xuIiArCi0JCQkJ
CSIJc3RhdGljIDxFPiBUTzxFPiBjb21iaW5lKGZpbmFsIFRUIHgsIGZpbmFsIFRPPD8gc3VwZXIg
RT4geSkgeyAvLyAjIDFcbiIgKwotCQkJCQkiCQlTeXN0ZW0ub3V0LnByaW50bG4oXCIjMSNcIik7
XG4iICsKLQkJCQkJIgkJcmV0dXJuIG5ldyBUTzxFPigpIHsgcHVibGljIFN0cmluZyBldmFsKEUg
bykgeyByZXR1cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTsgXG4iICsKLQkJCQkJIgl9XG4iICsK
LQkJCQkJIglzdGF0aWMgPEUsIFQ+IFRPPFQ+IGNvbWJpbmUoZmluYWwgVE88PyBzdXBlciBFPiB4
LCBmaW5hbCBPTzxFLCBUPiB5KSB7IC8vICMgMlxuIiArCi0JCQkJCSIJCVN5c3RlbS5vdXQucHJp
bnRsbihcIiMyI1wiKTtcbiIgKwotCQkJCQkiCQlyZXR1cm4gbmV3IFRPPFQ+KCkgeyBwdWJsaWMg
U3RyaW5nIGV2YWwoVCBvKSB7IHJldHVybiB4LmV2YWwoeS5ldmFsKG8pKTsgfSB9OyBcbiIgKwot
CQkJCQkiCX1cbiIgKwotCQkJCQkiCXN0YXRpYyA8RSwgVCwgVj4gT088RSwgVj4gY29tYmluZShm
aW5hbCBPTzxFLCA/IHN1cGVyIFQ+IHgsIGZpbmFsIE9PPFQsIFY+IHkpIHsgLy8gIyAzXG4iICsK
LQkJCQkJIgkJU3lzdGVtLm91dC5wcmludGxuKFwiIzMjXCIpO1xuIiArCi0JCQkJCSIJCXJldHVy
biBuZXcgT088RSwgVj4oKSB7IHB1YmxpYyBFIGV2YWwoViBvKSB7IHJldHVybiB4LmV2YWwoeS5l
dmFsKG8pKTsgfSB9O1xuIiArCi0JCQkJCSIJfVxuIiArCi0JCQkJCSIJLy8gYm9keSBvZiB0aGUg
dGVzdFxuIiArCi0JCQkJCSIJc3RhdGljIDxFPiB2b2lkIHB1dChDbGFzczxFPiB0eXBlLCBUTzw/
IHN1cGVyIEU+IGZ1bmMpIHtcbiIgKwotCQkJCQkiCX1cbiIgKwotCQkJCQkiCXB1YmxpYyBzdGF0
aWMgdm9pZCBtYWluKFN0cmluZ1tdIGFyZ3MpIHtcbiIgKwotCQkJCQkiCQlwdXQoSW50ZWdlci5j
bGFzcywgY29tYmluZShGVU5DMiwgRlVOQzEpKTtcbiIgKwotCQkJCQkiCX1cbiIgKwotCQkJCQki
fVxuIiwgLy8gPT09PT09PT09PT09PT09PT0KLQkJCX0sCi0JCQkiIzEjIik7CisJaWYgKHRoaXMu
Y29tcGxpYW5jZUxldmVsIDwgQ2xhc3NGaWxlQ29uc3RhbnRzLkpESzFfOCkgeworCQl0aGlzLnJ1
bkNvbmZvcm1UZXN0KAorCQkJCW5ldyBTdHJpbmdbXSB7CisJCQkJCQkiWC5qYXZhIiwKKwkJCQkJ
CSJwdWJsaWMgY2xhc3MgWCB7XG4iICsKKwkJCQkJCSIJLy8gc29tZSBmdW5jdG9yIGFuZCBmdW5j
dG9yIGluc3RhbmNlcyBkZWZpbml0aW9uc1xuIiArCisJCQkJCQkiCXN0YXRpYyBpbnRlcmZhY2Ug
T088VCwgRT4geyBcbiIgKworCQkJCQkJIgkJcHVibGljIFQgZXZhbChFIHgpO1xuIiArCisJCQkJ
CQkiCX1cbiIgKworCQkJCQkJIglzdGF0aWMgaW50ZXJmYWNlIFRPPFQ+IGV4dGVuZHMgT088U3Ry
aW5nLCBUPiB7XG4iICsKKwkJCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChUIHgpO1xuIiArCisJ
CQkJCQkiCX1cbiIgKworCQkJCQkJIglzdGF0aWMgaW50ZXJmYWNlIFRUIGV4dGVuZHMgVE88U3Ry
aW5nPiB7XG4iICsKKwkJCQkJCSIJCXB1YmxpYyBTdHJpbmcgZXZhbChTdHJpbmcgeCk7XG4iICsK
KwkJCQkJCSIJfVxuIiArCisJCQkJCQkiCXN0YXRpYyBmaW5hbCBUTzxPYmplY3Q+IEZVTkMxID0g
bnVsbDtcbiIgKworCQkJCQkJIglzdGF0aWMgZmluYWwgVFQgRlVOQzIgPSBudWxsO1xuIiArCisJ
CQkJCQkiXG4iICsKKwkJCQkJCSIJLy8gc29tZSBmdW5jdG9yIGNvbWJpbmF0b3JzXG4iICsKKwkJ
CQkJCSIJc3RhdGljIDxFPiBUTzxFPiBjb21iaW5lKGZpbmFsIFRUIHgsIGZpbmFsIFRPPD8gc3Vw
ZXIgRT4geSkgeyAvLyAjIDFcbiIgKworCQkJCQkJIgkJU3lzdGVtLm91dC5wcmludGxuKFwiIzEj
XCIpO1xuIiArCisJCQkJCQkiCQlyZXR1cm4gbmV3IFRPPEU+KCkgeyBwdWJsaWMgU3RyaW5nIGV2
YWwoRSBvKSB7IHJldHVybiB4LmV2YWwoeS5ldmFsKG8pKTsgfSB9OyBcbiIgKworCQkJCQkJIgl9
XG4iICsKKwkJCQkJCSIJc3RhdGljIDxFLCBUPiBUTzxUPiBjb21iaW5lKGZpbmFsIFRPPD8gc3Vw
ZXIgRT4geCwgZmluYWwgT088RSwgVD4geSkgeyAvLyAjIDJcbiIgKworCQkJCQkJIgkJU3lzdGVt
Lm91dC5wcmludGxuKFwiIzIjXCIpO1xuIiArCisJCQkJCQkiCQlyZXR1cm4gbmV3IFRPPFQ+KCkg
eyBwdWJsaWMgU3RyaW5nIGV2YWwoVCBvKSB7IHJldHVybiB4LmV2YWwoeS5ldmFsKG8pKTsgfSB9
OyBcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSIJc3RhdGljIDxFLCBULCBWPiBPTzxFLCBW
PiBjb21iaW5lKGZpbmFsIE9PPEUsID8gc3VwZXIgVD4geCwgZmluYWwgT088VCwgVj4geSkgeyAv
LyAjIDNcbiIgKworCQkJCQkJIgkJU3lzdGVtLm91dC5wcmludGxuKFwiIzMjXCIpO1xuIiArCisJ
CQkJCQkiCQlyZXR1cm4gbmV3IE9PPEUsIFY+KCkgeyBwdWJsaWMgRSBldmFsKFYgbykgeyByZXR1
cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSIJ
Ly8gYm9keSBvZiB0aGUgdGVzdFxuIiArCisJCQkJCQkiCXN0YXRpYyA8RT4gdm9pZCBwdXQoQ2xh
c3M8RT4gdHlwZSwgVE88PyBzdXBlciBFPiBmdW5jKSB7XG4iICsKKwkJCQkJCSIJfVxuIiArCisJ
CQkJCQkiCXB1YmxpYyBzdGF0aWMgdm9pZCBtYWluKFN0cmluZ1tdIGFyZ3MpIHtcbiIgKworCQkJ
CQkJIgkJcHV0KEludGVnZXIuY2xhc3MsIGNvbWJpbmUoRlVOQzIsIEZVTkMxKSk7XG4iICsKKwkJ
CQkJCSIJfVxuIiArCisJCQkJCQkifVxuIiwgLy8gPT09PT09PT09PT09PT09PT0KKwkJCQl9LAor
CQkJCSIjMSMiKTsKKwl9IGVsc2UgeworCQl0aGlzLnJ1bk5lZ2F0aXZlVGVzdCgKKwkJCQluZXcg
U3RyaW5nW10geworCQkJCQkJIlguamF2YSIsCisJCQkJCQkicHVibGljIGNsYXNzIFgge1xuIiAr
CisJCQkJCQkiCS8vIHNvbWUgZnVuY3RvciBhbmQgZnVuY3RvciBpbnN0YW5jZXMgZGVmaW5pdGlv
bnNcbiIgKworCQkJCQkJIglzdGF0aWMgaW50ZXJmYWNlIE9PPFQsIEU+IHsgXG4iICsKKwkJCQkJ
CSIJCXB1YmxpYyBUIGV2YWwoRSB4KTtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSIJc3Rh
dGljIGludGVyZmFjZSBUTzxUPiBleHRlbmRzIE9PPFN0cmluZywgVD4ge1xuIiArCisJCQkJCQki
CQlwdWJsaWMgU3RyaW5nIGV2YWwoVCB4KTtcbiIgKworCQkJCQkJIgl9XG4iICsKKwkJCQkJCSIJ
c3RhdGljIGludGVyZmFjZSBUVCBleHRlbmRzIFRPPFN0cmluZz4ge1xuIiArCisJCQkJCQkiCQlw
dWJsaWMgU3RyaW5nIGV2YWwoU3RyaW5nIHgpO1xuIiArCisJCQkJCQkiCX1cbiIgKworCQkJCQkJ
IglzdGF0aWMgZmluYWwgVE88T2JqZWN0PiBGVU5DMSA9IG51bGw7XG4iICsKKwkJCQkJCSIJc3Rh
dGljIGZpbmFsIFRUIEZVTkMyID0gbnVsbDtcbiIgKworCQkJCQkJIlxuIiArCisJCQkJCQkiCS8v
IHNvbWUgZnVuY3RvciBjb21iaW5hdG9yc1xuIiArCisJCQkJCQkiCXN0YXRpYyA8RT4gVE88RT4g
Y29tYmluZShmaW5hbCBUVCB4LCBmaW5hbCBUTzw/IHN1cGVyIEU+IHkpIHsgLy8gIyAxXG4iICsK
KwkJCQkJCSIJCVN5c3RlbS5vdXQucHJpbnRsbihcIiMxI1wiKTtcbiIgKworCQkJCQkJIgkJcmV0
dXJuIG5ldyBUTzxFPigpIHsgcHVibGljIFN0cmluZyBldmFsKEUgbykgeyByZXR1cm4geC5ldmFs
KHkuZXZhbChvKSk7IH0gfTsgXG4iICsKKwkJCQkJCSIJfVxuIiArCisJCQkJCQkiCXN0YXRpYyA8
RSwgVD4gVE88VD4gY29tYmluZShmaW5hbCBUTzw/IHN1cGVyIEU+IHgsIGZpbmFsIE9PPEUsIFQ+
IHkpIHsgLy8gIyAyXG4iICsKKwkJCQkJCSIJCVN5c3RlbS5vdXQucHJpbnRsbihcIiMyI1wiKTtc
biIgKworCQkJCQkJIgkJcmV0dXJuIG5ldyBUTzxUPigpIHsgcHVibGljIFN0cmluZyBldmFsKFQg
bykgeyByZXR1cm4geC5ldmFsKHkuZXZhbChvKSk7IH0gfTsgXG4iICsKKwkJCQkJCSIJfVxuIiAr
CisJCQkJCQkiCXN0YXRpYyA8RSwgVCwgVj4gT088RSwgVj4gY29tYmluZShmaW5hbCBPTzxFLCA/
IHN1cGVyIFQ+IHgsIGZpbmFsIE9PPFQsIFY+IHkpIHsgLy8gIyAzXG4iICsKKwkJCQkJCSIJCVN5
c3RlbS5vdXQucHJpbnRsbihcIiMzI1wiKTtcbiIgKworCQkJCQkJIgkJcmV0dXJuIG5ldyBPTzxF
LCBWPigpIHsgcHVibGljIEUgZXZhbChWIG8pIHsgcmV0dXJuIHguZXZhbCh5LmV2YWwobykpOyB9
IH07XG4iICsKKwkJCQkJCSIJfVxuIiArCisJCQkJCQkiCS8vIGJvZHkgb2YgdGhlIHRlc3RcbiIg
KworCQkJCQkJIglzdGF0aWMgPEU+IHZvaWQgcHV0KENsYXNzPEU+IHR5cGUsIFRPPD8gc3VwZXIg
RT4gZnVuYykge1xuIiArCisJCQkJCQkiCX1cbiIgKworCQkJCQkJIglwdWJsaWMgc3RhdGljIHZv
aWQgbWFpbihTdHJpbmdbXSBhcmdzKSB7XG4iICsKKwkJCQkJCSIJCXB1dChJbnRlZ2VyLmNsYXNz
LCBjb21iaW5lKEZVTkMyLCBGVU5DMSkpO1xuIiArCisJCQkJCQkiCX1cbiIgKworCQkJCQkJIn1c
biIsIC8vID09PT09PT09PT09PT09PT09CisJCQkJfSwKKwkJCQkiLS0tLS0tLS0tLVxuIiArIAor
CQkJCSIxLiBFUlJPUiBpbiBYLmphdmEgKGF0IGxpbmUgMzIpXG4iICsgCisJCQkJIglwdXQoSW50
ZWdlci5jbGFzcywgY29tYmluZShGVU5DMiwgRlVOQzEpKTtcbiIgKyAKKwkJCQkiCSAgICAgICAg
ICAgICAgICAgICBeXl5eXl5eXG4iICsgCisJCQkJIlRoZSBtZXRob2QgY29tYmluZShYLlRULCBY
LlRPPD8gc3VwZXIgRT4pIGlzIGFtYmlndW91cyBmb3IgdGhlIHR5cGUgWFxuIiArIAorCQkJCSIt
LS0tLS0tLS0tXG4iKTsKKwl9CiB9CiAvL2h0dHBzOi8vYnVncy5lY2xpcHNlLm9yZy9idWdzL3No
b3dfYnVnLmNnaT9pZD0yMTY2ODYgLSB2YXJpYXRpb24KIHB1YmxpYyB2b2lkIHRlc3QxMjc5KCkg
ewpAQCAtNDkxNDAsMTIgKzQ5MjM4LDEzIEBACiAJCQkJIiAgICB9XG4iICsgCiAJCQkJIn1cbiIs
Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLQogCQkJfSwKLQkJCSItLS0tLS0tLS0tXG4iICsgCi0JCQkiMS4gRVJS
T1IgaW4gWC5qYXZhIChhdCBsaW5lIDYpXG4iICsgCi0JCQkiCVN0cmluZyBzID0gZ2V0SGVhZChu
aWwoKSk7XG4iICsgCi0JCQkiCSAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiIgKyAKLQkJCSJU
eXBlIG1pc21hdGNoOiBjYW5ub3QgY29udmVydCBmcm9tIE9iamVjdCB0byBTdHJpbmdcbiIgKyAK
LQkJCSItLS0tLS0tLS0tXG4iKTsKKwkJCXRoaXMuY29tcGxpYW5jZUxldmVsIDwgQ2xhc3NGaWxl
Q29uc3RhbnRzLkpESzFfOCA/IAorCQkJCSItLS0tLS0tLS0tXG4iICsgCisJCQkJIjEuIEVSUk9S
IGluIFguamF2YSAoYXQgbGluZSA2KVxuIiArIAorCQkJCSIJU3RyaW5nIHMgPSBnZXRIZWFkKG5p
bCgpKTtcbiIgKyAKKwkJCQkiCSAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiIgKyAKKwkJCQki
VHlwZSBtaXNtYXRjaDogY2Fubm90IGNvbnZlcnQgZnJvbSBPYmplY3QgdG8gU3RyaW5nXG4iICsg
CisJCQkJIi0tLS0tLS0tLS1cbiIgOiAiIik7CiB9CiAvL2h0dHBzOi8vYnVncy5lY2xpcHNlLm9y
Zy9idWdzL3Nob3dfYnVnLmNnaT9pZD0yMzkyMDMKIHB1YmxpYyB2b2lkIHRlc3QxNDI4KCkgewpk
aWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9l
Y2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2NvbXBpbGVyL3JlZ3Jlc3Npb24vR2VuZXJpY3NSZWdyZXNz
aW9uVGVzdF8xXzcuamF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLmNvbXBpbGVyL3Ny
Yy9vcmcvZWNsaXBzZS9qZHQvY29yZS90ZXN0cy9jb21waWxlci9yZWdyZXNzaW9uL0dlbmVyaWNz
UmVncmVzc2lvblRlc3RfMV83LmphdmEKaW5kZXggNTBmZDI1Yi4uMTJkNWMzZCAxMDA2NDQKLS0t
IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUudGVzdHMuY29tcGlsZXIvc3JjL29yZy9lY2xpcHNlL2pk
dC9jb3JlL3Rlc3RzL2NvbXBpbGVyL3JlZ3Jlc3Npb24vR2VuZXJpY3NSZWdyZXNzaW9uVGVzdF8x
XzcuamF2YQorKysgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS50ZXN0cy5jb21waWxlci9zcmMvb3Jn
L2VjbGlwc2UvamR0L2NvcmUvdGVzdHMvY29tcGlsZXIvcmVncmVzc2lvbi9HZW5lcmljc1JlZ3Jl
c3Npb25UZXN0XzFfNy5qYXZhCkBAIC0yNDE2LDEyICsyNDE2LDI0IEBACiAJCQkiCSB9XG4iICsK
IAkJCSJ9XG4iCiAJCX0sCi0JCSItLS0tLS0tLS0tXG4iICsgCi0JCSIxLiBFUlJPUiBpbiBYLmph
dmEgKGF0IGxpbmUgNSlcbiIgKyAKLQkJIglGaWxlU3lzdGVtcy48U3RyaW5nLCBPYmplY3Q+bmV3
RmlsZVN5c3RlbSh1cmksIENvbGxlY3Rpb25zLmVtcHR5TWFwKCkpO1xuIiArIAotCQkiCSAgICAg
ICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5eXG4iICsgCi0JCSJUaGUgbWV0aG9k
IG5ld0ZpbGVTeXN0ZW0oVVJJLCBNYXA8U3RyaW5nLD8+KSBpbiB0aGUgdHlwZSBGaWxlU3lzdGVt
cyBpcyBub3QgYXBwbGljYWJsZSBmb3IgdGhlIGFyZ3VtZW50cyAoVVJJLCBNYXA8T2JqZWN0LE9i
amVjdD4pXG4iICsgCi0JCSItLS0tLS0tLS0tXG4iKTsKKwkJdGhpcy5jb21wbGlhbmNlTGV2ZWwg
PCBDbGFzc0ZpbGVDb25zdGFudHMuSkRLMV84ID8gCisJCQkiLS0tLS0tLS0tLVxuIiArIAorCQkJ
IjEuIEVSUk9SIGluIFguamF2YSAoYXQgbGluZSA1KVxuIiArIAorCQkJIglGaWxlU3lzdGVtcy48
U3RyaW5nLCBPYmplY3Q+bmV3RmlsZVN5c3RlbSh1cmksIENvbGxlY3Rpb25zLmVtcHR5TWFwKCkp
O1xuIiArIAorCQkJIgkgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXlxu
IiArIAorCQkJIlRoZSBtZXRob2QgbmV3RmlsZVN5c3RlbShVUkksIE1hcDxTdHJpbmcsPz4pIGlu
IHRoZSB0eXBlIEZpbGVTeXN0ZW1zIGlzIG5vdCBhcHBsaWNhYmxlIGZvciB0aGUgYXJndW1lbnRz
IChVUkksIE1hcDxPYmplY3QsT2JqZWN0PilcbiIgKyAKKwkJCSItLS0tLS0tLS0tXG4iIDogCisJ
CQkJIi0tLS0tLS0tLS1cbiIgKyAKKwkJCQkiMS4gRVJST1IgaW4gWC5qYXZhIChhdCBsaW5lIDUp
XG4iICsgCisJCQkJIglGaWxlU3lzdGVtcy48U3RyaW5nLCBPYmplY3Q+bmV3RmlsZVN5c3RlbSh1
cmksIENvbGxlY3Rpb25zLmVtcHR5TWFwKCkpO1xuIiArIAorCQkJCSIJXl5eXl5eXl5eXl5eXl5e
Xl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxu
IiArIAorCQkJCSJVbmhhbmRsZWQgZXhjZXB0aW9uIHR5cGUgSU9FeGNlcHRpb25cbiIgKyAKKwkJ
CQkiLS0tLS0tLS0tLVxuIiArIAorCQkJCSIyLiBXQVJOSU5HIGluIFguamF2YSAoYXQgbGluZSA1
KVxuIiArIAorCQkJCSIJRmlsZVN5c3RlbXMuPFN0cmluZywgT2JqZWN0Pm5ld0ZpbGVTeXN0ZW0o
dXJpLCBDb2xsZWN0aW9ucy5lbXB0eU1hcCgpKTtcbiIgKyAKKwkJCQkiCSAgICAgICAgICAgICBe
Xl5eXl5eXl5eXl5eXlxuIiArIAorCQkJCSJVbnVzZWQgdHlwZSBhcmd1bWVudHMgZm9yIHRoZSBu
b24gZ2VuZXJpYyBtZXRob2QgbmV3RmlsZVN5c3RlbShVUkksIE1hcDxTdHJpbmcsPz4pIG9mIHR5
cGUgRmlsZVN5c3RlbXM7IGl0IHNob3VsZCBub3QgYmUgcGFyYW1ldGVyaXplZCB3aXRoIGFyZ3Vt
ZW50cyA8U3RyaW5nLCBPYmplY3Q+XG4iICsgCisJCQkJIi0tLS0tLS0tLS1cbiIpOwogfQogcHVi
bGljIHN0YXRpYyBDbGFzcyB0ZXN0Q2xhc3MoKSB7CiAJcmV0dXJuIEdlbmVyaWNzUmVncmVzc2lv
blRlc3RfMV83LmNsYXNzOwpkaWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvLnNldHRp
bmdzLy5hcGlfZmlsdGVycyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlLy5zZXR0aW5ncy8uYXBpX2Zp
bHRlcnMKaW5kZXggNmE0MzMxNS4uODhhYTRmZiAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0
LmNvcmUvLnNldHRpbmdzLy5hcGlfZmlsdGVycworKysgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS8u
c2V0dGluZ3MvLmFwaV9maWx0ZXJzCkBAIC0xLDExICsxLDEwIEBACi08P3htbCB2ZXJzaW9uPSIx
LjAiIGVuY29kaW5nPSJVVEYtOCIgc3RhbmRhbG9uZT0ibm8iPz4KLTxjb21wb25lbnQgaWQ9Im9y
Zy5lY2xpcHNlLmpkdC5jb3JlIiB2ZXJzaW9uPSIyIj4KKzw/eG1sIHZlcnNpb249IjEuMCIgZW5j
b2Rpbmc9IlVURi04Ij8+PGNvbXBvbmVudCBpZD0ib3JnLmVjbGlwc2UuamR0LmNvcmUiIHZlcnNp
b249IjIiPgogICAgIDxyZXNvdXJjZSBwYXRoPSJNRVRBLUlORi9NQU5JRkVTVC5NRiI+CiAgICAg
ICAgIDxmaWx0ZXIgY29tbWVudD0iQkVUQV9KQVZBOCIgaWQ9IjkyNDg0NDAzOSI+CiAgICAgICAg
ICAgICA8bWVzc2FnZV9hcmd1bWVudHM+CiAgICAgICAgICAgICAgICAgPG1lc3NhZ2VfYXJndW1l
bnQgdmFsdWU9IjMuOS4yIi8+Ci0gICAgICAgICAgICAgICAgPG1lc3NhZ2VfYXJndW1lbnQgdmFs
dWU9IjMuOS4xIi8+CisgICAgICAgICAgICAgICAgPG1lc3NhZ2VfYXJndW1lbnQgdmFsdWU9IjMu
OS4wIi8+CiAgICAgICAgICAgICA8L21lc3NhZ2VfYXJndW1lbnRzPgogICAgICAgICA8L2ZpbHRl
cj4KICAgICA8L3Jlc291cmNlPgotPC9jb21wb25lbnQ+Cis8L2NvbXBvbmVudD4KXCBObyBuZXds
aW5lIGF0IGVuZCBvZiBmaWxlCmRpZmYgLS1naXQgYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21w
aWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0NvbmRpdGlvbmFsRXhw
cmVzc2lvbi5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2Uv
amR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9Db25kaXRpb25hbEV4cHJlc3Npb24uamF2YQppbmRl
eCA1M2ZjMzFlLi5iOWFmMDFlIDEwMDY0NAotLS0gYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21w
aWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0NvbmRpdGlvbmFsRXhw
cmVzc2lvbi5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvQ29uZGl0aW9uYWxFeHByZXNzaW9uLmphdmEK
QEAgLTY2NCwxMCArNjY0LDE0IEBACiAJCXJldHVybiB0aGlzLnZhbHVlSWZUcnVlLmlzQ29tcGF0
aWJsZVdpdGgobGVmdCwgc2NvcGUpICYmIHRoaXMudmFsdWVJZkZhbHNlLmlzQ29tcGF0aWJsZVdp
dGgobGVmdCwgc2NvcGUpOwogCX0KIAkKLQlwdWJsaWMgYm9vbGVhbiBzSXNNb3JlU3BlY2lmaWMo
VHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcgdCkgeworCXB1YmxpYyBib29sZWFuIGlzQm94aW5n
Q29tcGF0aWJsZVdpdGgoVHlwZUJpbmRpbmcgbGVmdCwgU2NvcGUgc2NvcGUpIHsKKwkJcmV0dXJu
IHRoaXMudmFsdWVJZlRydWUuaXNCb3hpbmdDb21wYXRpYmxlV2l0aChsZWZ0LCBzY29wZSkgJiYg
dGhpcy52YWx1ZUlmRmFsc2UuaXNCb3hpbmdDb21wYXRpYmxlV2l0aChsZWZ0LCBzY29wZSk7CisJ
fQorCQorCXB1YmxpYyBib29sZWFuIHNJc01vcmVTcGVjaWZpYyhUeXBlQmluZGluZyBzLCBUeXBl
QmluZGluZyB0LCBTY29wZSBzY29wZSkgewogCQlyZXR1cm4gaXNQb2x5RXhwcmVzc2lvbigpID8K
LQkJCQl0aGlzLnZhbHVlSWZUcnVlLnNJc01vcmVTcGVjaWZpYyhzLCB0KSAmJiB0aGlzLnZhbHVl
SWZGYWxzZS5zSXNNb3JlU3BlY2lmaWMocywgdCk6Ci0JCQkJc3VwZXIuc0lzTW9yZVNwZWNpZmlj
KHMsIHQpOworCQkJCXRoaXMudmFsdWVJZlRydWUuc0lzTW9yZVNwZWNpZmljKHMsIHQsIHNjb3Bl
KSAmJiB0aGlzLnZhbHVlSWZGYWxzZS5zSXNNb3JlU3BlY2lmaWMocywgdCwgc2NvcGUpOgorCQkJ
CXN1cGVyLnNJc01vcmVTcGVjaWZpYyhzLCB0LCBzY29wZSk7CiAJfQogCQogCXB1YmxpYyB2b2lk
IHRhZ0FzRWxsaXBzaXNBcmd1bWVudCgpIHsKZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5j
b3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvRXhwcmVz
c2lvbi5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL2FzdC9FeHByZXNzaW9uLmphdmEKaW5kZXggMGE3NmIxNS4uNTk1
MGY5NSAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlw
c2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9FeHByZXNzaW9uLmphdmEKKysrIGIvb3JnLmVj
bGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVy
L2FzdC9FeHByZXNzaW9uLmphdmEKQEAgLTI5LDYgKzI5LDggQEAKIAogaW1wb3J0IG9yZy5lY2xp
cHNlLmpkdC5jb3JlLmNvbXBpbGVyLkNoYXJPcGVyYXRpb247CiBpbXBvcnQgb3JnLmVjbGlwc2Uu
amR0LmludGVybmFsLmNvbXBpbGVyLkFTVFZpc2l0b3I7CitpbXBvcnQgb3JnLmVjbGlwc2UuamR0
LmludGVybmFsLmNvbXBpbGVyLkRlZmF1bHRFcnJvckhhbmRsaW5nUG9saWNpZXM7CitpbXBvcnQg
b3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLklFcnJvckhhbmRsaW5nUG9saWN5Owog
aW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5jbGFzc2ZtdC5DbGFzc0Zp
bGVDb25zdGFudHM7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmNv
ZGVnZW4uQnJhbmNoTGFiZWw7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBp
bGVyLmNvZGVnZW4uQ29kZVN0cmVhbTsKQEAgLTU2LDYgKzU4LDggQEAKIGltcG9ydCBvcmcuZWNs
aXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIudXRpbC5NZXNzYWdlczsKIAogcHVibGljIGFic3Ry
YWN0IGNsYXNzIEV4cHJlc3Npb24gZXh0ZW5kcyBTdGF0ZW1lbnQgaW1wbGVtZW50cyBFeHByZXNz
aW9uQ29udGV4dCB7CisKKwlwcm90ZWN0ZWQgc3RhdGljIElFcnJvckhhbmRsaW5nUG9saWN5IHNp
bGVudEVycm9ySGFuZGxpbmdQb2xpY3kgPSBEZWZhdWx0RXJyb3JIYW5kbGluZ1BvbGljaWVzLmln
bm9yZUFsbFByb2JsZW1zKCk7CiAKIAlwdWJsaWMgQ29uc3RhbnQgY29uc3RhbnQ7CiAKQEAgLTEw
MzYsNiArMTA0MCw3IEBACiAJcmV0dXJuIG51bGw7CiB9CiAKKy8vIEphdmEgOCBub3RlOiBGb3Ig
cG9seS1leHByZXNzaW9ucyBpbiBJTlZPQ0FUSU9OX0NPTlRFWFRzLCB0aGlzIGlzIE5PVCB0aGUg
ZXZlbnR1YWwgcmVzb2x1dGlvbi4KIHB1YmxpYyBUeXBlQmluZGluZyByZXNvbHZlVHlwZUV4cGVj
dGluZyhCbG9ja1Njb3BlIHNjb3BlLCBUeXBlQmluZGluZyBleHBlY3RlZFR5cGUpIHsKIAlzZXRF
eHBlY3RlZFR5cGUoZXhwZWN0ZWRUeXBlKTsgLy8gbmVlZGVkIGluIGNhc2Ugb2YgZ2VuZXJpYyBt
ZXRob2QgaW52b2NhdGlvbgogCVR5cGVCaW5kaW5nIGV4cHJlc3Npb25UeXBlID0gdGhpcy5yZXNv
bHZlVHlwZShzY29wZSk7CkBAIC0xMTQwLDE0ICsxMTQ1LDE4IEBACiB9CiAKIHB1YmxpYyBib29s
ZWFuIGlzQ29tcGF0aWJsZVdpdGgoVHlwZUJpbmRpbmcgbGVmdCwgU2NvcGUgc2NvcGUpIHsKLQl0
aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oIlVuZXhwZWN0ZWQgY29udHJv
bCBmbG93LCBzaG91bGQgbm90IGhhdmUgcmVhY2hlZCBFeHByZXNzaW9uLmlzQ29tcGF0aWJsZVdp
dGgiKTsgLy8kTk9OLU5MUy0xJAorCXJldHVybiB0aGlzLnJlc29sdmVkVHlwZSAhPSBudWxsICYm
IHRoaXMucmVzb2x2ZWRUeXBlLmlzQ29tcGF0aWJsZVdpdGgobGVmdCwgc2NvcGUpOwogfQogCi1w
dWJsaWMgYm9vbGVhbiBzSXNNb3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcg
dCkgeworcHVibGljIGJvb2xlYW4gaXNCb3hpbmdDb21wYXRpYmxlV2l0aChUeXBlQmluZGluZyBs
ZWZ0LCBTY29wZSBzY29wZSkgeworCXJldHVybiB0aGlzLnJlc29sdmVkVHlwZSAhPSBudWxsICYm
IHNjb3BlLmlzQm94aW5nQ29tcGF0aWJsZVdpdGgodGhpcy5yZXNvbHZlZFR5cGUsIGxlZnQpOwor
fQorCitwdWJsaWMgYm9vbGVhbiBzSXNNb3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcgcywgVHlwZUJp
bmRpbmcgdCwgU2NvcGUgc2NvcGUpIHsKIAlUeXBlQmluZGluZyBleHByZXNzaW9uVHlwZSA9IHRo
aXMucmVzb2x2ZWRUeXBlOwogCWlmIChleHByZXNzaW9uVHlwZSA9PSBudWxsIHx8ICFleHByZXNz
aW9uVHlwZS5pc1ZhbGlkQmluZGluZygpKSAvLyBTaG91bGRuJ3QgZ2V0IGhlcmUsIGp1c3QgdG8g
cGxheSBpdCBzYWZlCiAJCXJldHVybiBmYWxzZTsgLy8gdHJpZ2dlciBhbWJpZ3VpdHkuCi0JcmV0
dXJuIHMuZmluZFN1cGVyVHlwZU9yaWdpbmF0aW5nRnJvbSh0KSAhPSBudWxsOworCXJldHVybiBz
LmlzQ29tcGF0aWJsZVdpdGgodCwgc2NvcGUpOwogfQogCiBwdWJsaWMgdm9pZCB0YWdBc0VsbGlw
c2lzQXJndW1lbnQoKSB7CmRpZmYgLS1naXQgYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxl
ci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L0Z1bmN0aW9uYWxFeHByZXNz
aW9uLmphdmEgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQv
aW50ZXJuYWwvY29tcGlsZXIvYXN0L0Z1bmN0aW9uYWxFeHByZXNzaW9uLmphdmEKaW5kZXggMWEz
NDZjMi4uNDZmNjFkOCAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIv
b3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9GdW5jdGlvbmFsRXhwcmVzc2lv
bi5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pk
dC9pbnRlcm5hbC9jb21waWxlci9hc3QvRnVuY3Rpb25hbEV4cHJlc3Npb24uamF2YQpAQCAtMTgs
OCArMTgsNiBAQAogcGFja2FnZSBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIuYXN0
OwogCiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLkNvbXBpbGF0aW9u
UmVzdWx0OwotaW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5EZWZhdWx0
RXJyb3JIYW5kbGluZ1BvbGljaWVzOwotaW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5j
b21waWxlci5JRXJyb3JIYW5kbGluZ1BvbGljeTsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50
ZXJuYWwuY29tcGlsZXIuZmxvdy5GbG93SW5mbzsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50
ZXJuYWwuY29tcGlsZXIuaW1wbC5Db25zdGFudDsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50
ZXJuYWwuY29tcGlsZXIubG9va3VwLkFycmF5QmluZGluZzsKQEAgLTQ2LDcgKzQ0LDYgQEAKIAlw
cm90ZWN0ZWQgQ29tcGlsYXRpb25SZXN1bHQgY29tcGlsYXRpb25SZXN1bHQ7CiAJcHJvdGVjdGVk
IEJsb2NrU2NvcGUgZW5jbG9zaW5nU2NvcGU7CiAJcHJvdGVjdGVkIGJvb2xlYW4gZWxsaXBzaXNB
cmd1bWVudDsKLQlwcm90ZWN0ZWQgc3RhdGljIElFcnJvckhhbmRsaW5nUG9saWN5IHNpbGVudEVy
cm9ySGFuZGxpbmdQb2xpY3kgPSBEZWZhdWx0RXJyb3JIYW5kbGluZ1BvbGljaWVzLmlnbm9yZUFs
bFByb2JsZW1zKCk7CiAJCiAJcHVibGljIEZ1bmN0aW9uYWxFeHByZXNzaW9uKENvbXBpbGF0aW9u
UmVzdWx0IGNvbXBpbGF0aW9uUmVzdWx0KSB7CiAJCXRoaXMuY29tcGlsYXRpb25SZXN1bHQgPSBj
b21waWxhdGlvblJlc3VsdDsKQEAgLTY5LDYgKzY2LDExIEBACiAJcHVibGljIGJvb2xlYW4gaXNQ
b2x5RXhwcmVzc2lvbigpIHsKIAkJcmV0dXJuIHRoaXMuZXhwcmVzc2lvbkNvbnRleHQgIT0gVkFO
SUxMQV9DT05URVhUOwogCX0KKwkKKwkvLyBmb3IgbGFtYmRhJ3MgYW5kIHJlZmVyZW5jZSBleHBy
ZXNzaW9ucyBib3hpbmcgY29tcGF0aWJpbGl0eSBpcyBpbXBsaWVkIGJ5IHZhbmlsbGEgY29tcGF0
aWJpbGl0eS4KKwlwdWJsaWMgYm9vbGVhbiBpc0JveGluZ0NvbXBhdGlibGVXaXRoKFR5cGVCaW5k
aW5nIGxlZnQsIFNjb3BlIHNvbWVTY29wZSkgeworCQlyZXR1cm4gaXNDb21wYXRpYmxlV2l0aChs
ZWZ0LCBzb21lU2NvcGUpOworCX0KIAogCXB1YmxpYyBUeXBlQmluZGluZyBleHBlY3RlZFR5cGUo
KSB7CiAJCXJldHVybiB0aGlzLmV4cGVjdGVkVHlwZTsKZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNl
LmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3Qv
TGFtYmRhRXhwcmVzc2lvbi5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3Jn
L2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9MYW1iZGFFeHByZXNzaW9uLmphdmEK
aW5kZXggMzkyZGJhNS4uYzhkMDg3MSAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0LmNvcmUv
Y29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9MYW1iZGFFeHBy
ZXNzaW9uLmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlw
c2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9MYW1iZGFFeHByZXNzaW9uLmphdmEKQEAgLTEz
MSw2ICsxMzEsNDQgQEAKIAkJcmV0dXJuIHN1cGVyLmtvc2hlckRlc2NyaXB0b3IoY3VycmVudFNj
b3BlLCBzYW0sIHNob3VsZENoYXR0ZXIpOwogCX0KIAkKKwlwdWJsaWMgVHlwZUJpbmRpbmcgcmVz
b2x2ZVR5cGVFeHBlY3RpbmcoQmxvY2tTY29wZSBzb21lU2NvcGUsIFR5cGVCaW5kaW5nIGxlZnQp
IHsKKwkJCisJCWZpbmFsIE1ldGhvZEJpbmRpbmcgc2FtID0gbGVmdCA9PSBudWxsID8gbnVsbCA6
IGxlZnQuZ2V0U2luZ2xlQWJzdHJhY3RNZXRob2QodGhpcy5lbmNsb3NpbmdTY29wZSk7CisJCWlm
IChzYW0gPT0gbnVsbCB8fCAhc2FtLmlzVmFsaWRCaW5kaW5nKCkpCisJCQlyZXR1cm4gbnVsbDsK
KwkJaWYgKHNhbS5wYXJhbWV0ZXJzLmxlbmd0aCAhPSB0aGlzLmFyZ3VtZW50cy5sZW5ndGgpCisJ
CQlyZXR1cm4gbnVsbDsKKwkJCisJCUxhbWJkYUV4cHJlc3Npb24gY29weSA9IG51bGw7CisJCUlF
cnJvckhhbmRsaW5nUG9saWN5IG9sZFBvbGljeSA9IHRoaXMuZW5jbG9zaW5nU2NvcGUucHJvYmxl
bVJlcG9ydGVyKCkuc3dpdGNoRXJyb3JIYW5kbGluZ1BvbGljeShzaWxlbnRFcnJvckhhbmRsaW5n
UG9saWN5KTsKKwkJdHJ5IHsKKwkJCWNvcHkgPSBjb3B5KCk7CisJCQlpZiAoY29weSA9PSBudWxs
KQorCQkJCXJldHVybiBudWxsOworCQkJY29weS5zZXRFeHByZXNzaW9uQ29udGV4dCh0aGlzLmV4
cHJlc3Npb25Db250ZXh0KTsKKwkJCWNvcHkuc2V0RXhwZWN0ZWRUeXBlKGxlZnQpOworCQkJY29w
eS5yZXNvbHZlVHlwZSh0aGlzLmVuY2xvc2luZ1Njb3BlKTsKKwkJCWlmIChjb3B5LnJlc29sdmVk
VHlwZSA9PSBudWxsKQorCQkJCXJldHVybiBudWxsOworCQkJaWYgKCF0aGlzLnNoYXBlQW5hbHlz
aXNDb21wbGV0ZSkgeworCQkJCWlmICghYXJndW1lbnRzVHlwZUVsaWRlZCgpKSB7CisJCQkJCXRo
aXMuYXJndW1lbnRUeXBlcyA9IGNvcHkuYXJndW1lbnRUeXBlczsKKwkJCQl9CisJCQkJaWYgKHRo
aXMuYm9keSBpbnN0YW5jZW9mIEJsb2NrKSB7CisJCQkJCWlmICghdGhpcy5yZXR1cm5zVm9pZCkg
eworCQkJCQkJdGhpcy52YWx1ZUNvbXBhdGlibGUgPSBjb3B5LmRvZXNOb3RDb21wbGV0ZU5vcm1h
bGx5KCk7CisJCQkJCX0KKwkJCQl9IGVsc2UgeworCQkJCQl0aGlzLnZvaWRDb21wYXRpYmxlID0g
KChFeHByZXNzaW9uKSB0aGlzLmJvZHkpLnN0YXRlbWVudEV4cHJlc3Npb24oKTsKKwkJCQl9CisJ
CQkJdGhpcy5zaGFwZUFuYWx5c2lzQ29tcGxldGUgPSB0cnVlOworCQkJfQorCQl9IGZpbmFsbHkg
eworCQkJdGhpcy5lbmNsb3NpbmdTY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5zd2l0Y2hFcnJvckhh
bmRsaW5nUG9saWN5KG9sZFBvbGljeSk7CisJCX0KKwkJcmV0dXJuIGNvcHkucmVzb2x2ZWRUeXBl
OworCX0KKwkKIAkvKiBUaGlzIGNvZGUgaXMgYXJyYW5nZWQgc28gdGhhdCB3ZSBjYW4gY29udGlu
dWUgd2l0aCBhcyBtdWNoIGFuYWx5c2lzIGFzIHBvc3NpYmxlIHdoaWxlIGF2b2lkaW5nIAogCSAq
IG1pbmUgZmllbGRzIHRoYXQgd291bGQgcmVzdWx0IGluIGEgc2xldyBvZiBzcHVyaW91cyBtZXNz
YWdlcy4gVGhpcyBtZXRob2QgaXMgYSBtZXJnZXIgb2Y6CiAJICogQHNlZSBvcmcuZWNsaXBzZS5q
ZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLk1ldGhvZFNjb3BlLmNyZWF0ZU1ldGhvZChBYnN0
cmFjdE1ldGhvZERlY2xhcmF0aW9uKQpAQCAtNDYyLDcgKzUwMCw3IEBACiAJcHVibGljIE1ldGhv
ZFNjb3BlIGdldFNjb3BlKCkgewogCQlyZXR1cm4gdGhpcy5zY29wZTsKIAl9Ci0JCQorCQogCXB1
YmxpYyBib29sZWFuIGlzQ29tcGF0aWJsZVdpdGgoZmluYWwgVHlwZUJpbmRpbmcgbGVmdCwgZmlu
YWwgU2NvcGUgc29tZVNjb3BlKSB7CiAJCQogCQlmaW5hbCBNZXRob2RCaW5kaW5nIHNhbSA9IGxl
ZnQuZ2V0U2luZ2xlQWJzdHJhY3RNZXRob2QodGhpcy5lbmNsb3NpbmdTY29wZSk7CkBAIC00NzMs
MzEgKzUxMSw5IEBACiAJCQlyZXR1cm4gZmFsc2U7CiAJCQogCQlpZiAoIXRoaXMuc2hhcGVBbmFs
eXNpc0NvbXBsZXRlKSB7Ci0JCQlJRXJyb3JIYW5kbGluZ1BvbGljeSBvbGRQb2xpY3kgPSB0aGlz
LmVuY2xvc2luZ1Njb3BlLnByb2JsZW1SZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xp
Y3koc2lsZW50RXJyb3JIYW5kbGluZ1BvbGljeSk7Ci0JCQl0cnkgewotCQkJCWZpbmFsIExhbWJk
YUV4cHJlc3Npb24gY29weSA9IGNvcHkoKTsKLQkJCQlpZiAoY29weSA9PSBudWxsKQotCQkJCQly
ZXR1cm4gZmFsc2U7Ci0JCQkJY29weS5zZXRFeHByZXNzaW9uQ29udGV4dCh0aGlzLmV4cHJlc3Np
b25Db250ZXh0KTsKLQkJCQljb3B5LnNldEV4cGVjdGVkVHlwZShsZWZ0KTsKLQkJCQljb3B5LnJl
c29sdmVUeXBlKHRoaXMuZW5jbG9zaW5nU2NvcGUpOwotCi0JCQkJaWYgKCFhcmd1bWVudHNUeXBl
RWxpZGVkKCkpIHsKLQkJCQkJdGhpcy5hcmd1bWVudFR5cGVzID0gY29weS5hcmd1bWVudFR5cGVz
OwotCQkJCX0KLQkJCQotCQkJCWlmICh0aGlzLmJvZHkgaW5zdGFuY2VvZiBCbG9jaykgewotCQkJ
CQlpZiAoIXRoaXMucmV0dXJuc1ZvaWQpIHsKLQkJCQkJCXRoaXMudmFsdWVDb21wYXRpYmxlID0g
Y29weS5kb2VzTm90Q29tcGxldGVOb3JtYWxseSgpOwotCQkJCQl9Ci0JCQkJfSBlbHNlIHsKLQkJ
CQkJdGhpcy52b2lkQ29tcGF0aWJsZSA9ICgoRXhwcmVzc2lvbikgdGhpcy5ib2R5KS5zdGF0ZW1l
bnRFeHByZXNzaW9uKCk7Ci0JCQkJfQotCQkJCi0JCQl9IGZpbmFsbHkgewotCQkJCXRoaXMuc2hh
cGVBbmFseXNpc0NvbXBsZXRlID0gdHJ1ZTsKLQkJCQl0aGlzLmVuY2xvc2luZ1Njb3BlLnByb2Js
ZW1SZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xpY3kob2xkUG9saWN5KTsKLQkJCX0K
KwkJCXJlc29sdmVUeXBlRXhwZWN0aW5nKHRoaXMuZW5jbG9zaW5nU2NvcGUsIGxlZnQpOworCQkJ
aWYgKCF0aGlzLnNoYXBlQW5hbHlzaXNDb21wbGV0ZSkKKwkJCQlyZXR1cm4gZmFsc2U7CiAJCX0K
IAogCQlpZiAoc2FtLnJldHVyblR5cGUuaWQgPT0gVHlwZUlkcy5UX3ZvaWQpIHsKQEAgLTUzMyw3
ICs1NDksNyBAQAogCQlyZXR1cm4gdHJ1ZTsKIAl9CiAJCi0JcHVibGljIGJvb2xlYW4gc0lzTW9y
ZVNwZWNpZmljKFR5cGVCaW5kaW5nIHMsIFR5cGVCaW5kaW5nIHQpIHsKKwlwdWJsaWMgYm9vbGVh
biBzSXNNb3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcgdCwgU2NvcGUgc29t
ZVNjb3BlKSB7CiAJCQogCQkvLyAxNS4xMi4yLjUgCiAJCQpAQCAtNTg3LDcgKzYwMyw3IEBACiAJ
CWlmIChyMS5pc0Z1bmN0aW9uYWxJbnRlcmZhY2UodGhpcy5lbmNsb3NpbmdTY29wZSkgJiYgcjIu
aXNGdW5jdGlvbmFsSW50ZXJmYWNlKHRoaXMuZW5jbG9zaW5nU2NvcGUpKSB7CiAJCQlmb3IgKGkg
PSAwOyBpIDwgcmV0dXJuRXhwcmVzc2lvbnNMZW5ndGg7IGkrKykgewogCQkJCUV4cHJlc3Npb24g
cmVzdWx0RXhwcmVzc2lvbiA9IHJldHVybkV4cHJlc3Npb25zW2ldOwotCQkJCWlmICghcmVzdWx0
RXhwcmVzc2lvbi5zSXNNb3JlU3BlY2lmaWMocjEsIHIyKSkKKwkJCQlpZiAoIXJlc3VsdEV4cHJl
c3Npb24uc0lzTW9yZVNwZWNpZmljKHIxLCByMiwgdGhpcy5lbmNsb3NpbmdTY29wZSkpCiAJCQkJ
CWJyZWFrOwogCQkJfQogCQkJaWYgKGkgPT0gcmV0dXJuRXhwcmVzc2lvbnNMZW5ndGgpCmRpZmYg
LS1naXQgYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50
ZXJuYWwvY29tcGlsZXIvYXN0L01lc3NhZ2VTZW5kLmphdmEgYi9vcmcuZWNsaXBzZS5qZHQuY29y
ZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L01lc3NhZ2VT
ZW5kLmphdmEKaW5kZXggZjBiMmQ3My4uOGYyZmNhYSAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2Uu
amR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2FzdC9N
ZXNzYWdlU2VuZC5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9l
Y2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvTWVzc2FnZVNlbmQuamF2YQpAQCAtNDYs
OCArNDYsMTEgQEAKICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLwogcGFja2FnZSBvcmcuZWNsaXBz
ZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIuYXN0OwogCitpbXBvcnQgamF2YS51dGlsLkhhc2hNYXA7
CisKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuY29yZS5jb21waWxlci5DaGFyT3BlcmF0aW9uOwog
aW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5BU1RWaXNpdG9yOworaW1w
b3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5JRXJyb3JIYW5kbGluZ1BvbGlj
eTsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIuY2xhc3NmbXQuQ2xh
c3NGaWxlQ29uc3RhbnRzOwogaW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxl
ci5jb2RlZ2VuLkNvZGVTdHJlYW07CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNv
bXBpbGVyLmNvZGVnZW4uT3Bjb2RlczsKQEAgLTY3LDYgKzcwLDggQEAKIGltcG9ydCBvcmcuZWNs
aXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLk1ldGhvZEJpbmRpbmc7CiBpbXBvcnQg
b3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5NaXNzaW5nVHlwZUJpbmRp
bmc7CiBpbXBvcnQgb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5QYXJh
bWV0ZXJpemVkR2VuZXJpY01ldGhvZEJpbmRpbmc7CitpbXBvcnQgb3JnLmVjbGlwc2UuamR0Lmlu
dGVybmFsLmNvbXBpbGVyLmxvb2t1cC5Qb2x5VHlwZUJpbmRpbmc7CitpbXBvcnQgb3JnLmVjbGlw
c2UuamR0LmludGVybmFsLmNvbXBpbGVyLmxvb2t1cC5Qb2x5VHlwZUV4Y2VwdGlvbjsKIGltcG9y
dCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlBvbHltb3JwaGljTWV0
aG9kQmluZGluZzsKIGltcG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIubG9v
a3VwLlByb2JsZW1NZXRob2RCaW5kaW5nOwogaW1wb3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5h
bC5jb21waWxlci5sb29rdXAuUHJvYmxlbVJlYXNvbnM7CkBAIC0xOTUsNiArMjAwLDEyIEBACiBw
cml2YXRlIHN0YXRpYyBmaW5hbCBpbnQgRkFMU0VfQVNTRVJUSU9OID0gMjsKIHByaXZhdGUgc3Rh
dGljIGZpbmFsIGludCBOVUxMX0FTU0VSVElPTiA9IDM7CiBwcml2YXRlIHN0YXRpYyBmaW5hbCBp
bnQgTk9OTlVMTF9BU1NFUlRJT04gPSA0OworcHJpdmF0ZSBUeXBlQmluZGluZ1tdIGFyZ3VtZW50
VHlwZXM7Citwcml2YXRlIGJvb2xlYW4gcmVjZWl2ZXJJc1R5cGU7Citwcml2YXRlIGJvb2xlYW4g
YXJnc0NvbnRhaW5DYXN0OworcHJpdmF0ZSBCbG9ja1Njb3BlIGVuY2xvc2luZ1Njb3BlOworcHJp
dmF0ZSBib29sZWFuIGlzUG9seUV4cHJlc3Npb24gPSBmYWxzZTsKK3ByaXZhdGUgSGFzaE1hcCBj
YW5kaWRhdGVUeXBlczsKIAogLy8gaXMgdGhlIGFyZ3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlv
biBiZWluZyBjaGVja2VkIGJ5IGEgd2VsbC1rbm93biBhc3NlcnRpb24gdXRpbGl0eT8KIC8vIGlm
IHNvIGFuc3dlciB3aGF0IGtpbmQgb2YgYXNzZXJ0aW9uIHdlIGFyZSBmYWNpbmcuCkBAIC00NTEs
MTAgKzQ2MiwyNCBAQAogCXJldHVybiB0aGlzLmdlbmVyaWNUeXBlQXJndW1lbnRzOwogfQogCitw
dWJsaWMgYm9vbGVhbiBpc0NvbXBhdGlibGVXaXRoKFR5cGVCaW5kaW5nIGxlZnQsIFNjb3BlIHNj
b3BlKSB7CisJVHlwZUJpbmRpbmcgdHlwZSA9IHJlc29sdmVUeXBlRXhwZWN0aW5nKHRoaXMuZW5j
bG9zaW5nU2NvcGUsIGxlZnQpOworCWlmICh0eXBlID09IG51bGwgfHwgIXR5cGUuaXNWYWxpZEJp
bmRpbmcoKSkKKwkJcmV0dXJuIGZhbHNlOworCXJldHVybiB0eXBlLmlzQ29tcGF0aWJsZVdpdGgo
bGVmdCwgc2NvcGUpOworfQorCitwdWJsaWMgYm9vbGVhbiBpc0JveGluZ0NvbXBhdGlibGVXaXRo
KFR5cGVCaW5kaW5nIGxlZnQsIFNjb3BlIHNjb3BlKSB7CisJVHlwZUJpbmRpbmcgdHlwZSA9IHJl
c29sdmVUeXBlRXhwZWN0aW5nKHRoaXMuZW5jbG9zaW5nU2NvcGUsIGxlZnQpOworCWlmICh0eXBl
ID09IG51bGwgfHwgIXR5cGUuaXNWYWxpZEJpbmRpbmcoKSkKKwkJcmV0dXJuIGZhbHNlOworCXJl
dHVybiBzY29wZS5pc0JveGluZ0NvbXBhdGlibGVXaXRoKHR5cGUsIGxlZnQpOworfQorCiBwdWJs
aWMgYm9vbGVhbiBpc1N1cGVyQWNjZXNzKCkgewogCXJldHVybiB0aGlzLnJlY2VpdmVyLmlzU3Vw
ZXIoKTsKIH0KLXB1YmxpYyBib29sZWFuIGlzVHlwZUFjY2VzcygpIHsKK3B1YmxpYyBib29sZWFu
IGlzVHlwZUFjY2VzcygpIHsgCiAJcmV0dXJuIHRoaXMucmVjZWl2ZXIgIT0gbnVsbCAmJiB0aGlz
LnJlY2VpdmVyLmlzVHlwZVJlZmVyZW5jZSgpOwogfQogcHVibGljIHZvaWQgbWFuYWdlU3ludGhl
dGljQWNjZXNzSWZOZWNlc3NhcnkoQmxvY2tTY29wZSBjdXJyZW50U2NvcGUsIEZsb3dJbmZvIGZs
b3dJbmZvKXsKQEAgLTU2OSwxMTEgKzU5NCwxNzQgQEAKIAlyZXR1cm4gb3V0cHV0LmFwcGVuZCgn
KScpOwogfQogCitwdWJsaWMgVHlwZUJpbmRpbmcgcmVzb2x2ZVR5cGVFeHBlY3RpbmcoQmxvY2tT
Y29wZSBzY29wZSwgVHlwZUJpbmRpbmcgdGFyZ2V0VHlwZSkgeworCQorCWlmICghdGhpcy5pc1Bv
bHlFeHByZXNzaW9uKCkgfHwgdGhpcy5leHByZXNzaW9uQ29udGV4dCAhPSBJTlZPQ0FUSU9OX0NP
TlRFWFQpCisJCXJldHVybiBzdXBlci5yZXNvbHZlVHlwZUV4cGVjdGluZyhzY29wZSwgdGFyZ2V0
VHlwZSk7CisKKwlUeXBlQmluZGluZyBjYW5kaWRhdGVUeXBlID0gKFR5cGVCaW5kaW5nKSAodGhp
cy5jYW5kaWRhdGVUeXBlcyA9PSBudWxsID8gbnVsbCA6IHRoaXMuY2FuZGlkYXRlVHlwZXMuZ2V0
KHRhcmdldFR5cGUpKTsKKwlpZiAoY2FuZGlkYXRlVHlwZSAhPSBudWxsKQorCQlyZXR1cm4gY2Fu
ZGlkYXRlVHlwZTsKKwkKKwlJRXJyb3JIYW5kbGluZ1BvbGljeSBvbGRQb2xpY3kgPSB0aGlzLmVu
Y2xvc2luZ1Njb3BlLnByb2JsZW1SZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xpY3ko
c2lsZW50RXJyb3JIYW5kbGluZ1BvbGljeSk7CisJdHJ5IHsgCisJCWludCBsZW5ndGggPSB0aGlz
LmFyZ3VtZW50cyA9PSBudWxsID8gMCA6IHRoaXMuYXJndW1lbnRzLmxlbmd0aDsKKwkJVHlwZUJp
bmRpbmcgW10gdHJpYWxUeXBlcyA9IG5ldyBUeXBlQmluZGluZ1tsZW5ndGhdOworCQlmb3IgKGlu
dCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CisJCQlpZiAodGhpcy5hcmd1bWVudFR5cGVzW2ld
LmtpbmQoKSA9PSBCaW5kaW5nLlBPTFlfVFlQRSkgeworCQkJCUV4cHJlc3Npb24gYXJndW1lbnQg
PSB0aGlzLmFyZ3VtZW50c1tpXTsKKwkJCQlhcmd1bWVudC5zZXRFeHByZXNzaW9uQ29udGV4dChJ
TlZPQ0FUSU9OX0NPTlRFWFQpOworCQkJCWlmICgodHJpYWxUeXBlc1tpXSA9IGFyZ3VtZW50LnJl
c29sdmVUeXBlRXhwZWN0aW5nKHRoaXMuZW5jbG9zaW5nU2NvcGUsIHRhcmdldFR5cGUpKSA9PSBu
dWxsKSB7CisJCQkJCXJldHVybiBudWxsOworCQkJCX0KKwkJCX0gZWxzZSB7CisJCQkJdHJpYWxU
eXBlc1tpXSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpXTsKKwkJCX0KKwkJfQorCQlzZXRFeHBlY3Rl
ZFR5cGUodGFyZ2V0VHlwZSk7CisJCU1ldGhvZEJpbmRpbmcgdHJpYWxNZXRob2QgPSB0aGlzLnJl
Y2VpdmVyLmlzSW1wbGljaXRUaGlzKCkKKwkJCQk/IHNjb3BlLmdldEltcGxpY2l0TWV0aG9kKHRo
aXMuc2VsZWN0b3IsIHRyaWFsVHlwZXMsIHRoaXMpCisJCQkJCQk6IHNjb3BlLmdldE1ldGhvZCh0
aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSwgdGhpcy5zZWxlY3RvciwgdHJpYWxUeXBlcywgdGhpcyk7
CisJCQkJaWYgKHRyaWFsTWV0aG9kID09IG51bGwgfHwgIXRyaWFsTWV0aG9kLmlzVmFsaWRCaW5k
aW5nKCkpCisJCQkJCXJldHVybiBudWxsOworCQkJCWlmICh0aGlzLmNhbmRpZGF0ZVR5cGVzID09
IG51bGwpIHsKKwkJCQkJdGhpcy5jYW5kaWRhdGVUeXBlcyA9IG5ldyBIYXNoTWFwKCk7CisJCQkJ
CXRoaXMuY2FuZGlkYXRlVHlwZXMucHV0KHRhcmdldFR5cGUsIHRyaWFsTWV0aG9kLnJldHVyblR5
cGUpOworCQkJCX0KKwkJCQkvLyBUT0RPOiBVbmNoZWNrZWQgbWV0aG9kIGludm9jYXRpb25zID8g
UmV2aWV3IHRoZSBib3R0b20gaGFsZiBvZiByZXNvbHZlVHlwZSgpIGZvciBzaWRlIGVmZmVjdHMu
CisJCQkJcmV0dXJuIHRyaWFsTWV0aG9kLnJldHVyblR5cGU7CisJfSBmaW5hbGx5IHsKKwkJdGhp
cy5lbmNsb3NpbmdTY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5zd2l0Y2hFcnJvckhhbmRsaW5nUG9s
aWN5KG9sZFBvbGljeSk7CisJfQorfQorCiBwdWJsaWMgVHlwZUJpbmRpbmcgcmVzb2x2ZVR5cGUo
QmxvY2tTY29wZSBzY29wZSkgewogCS8vIEFuc3dlciB0aGUgc2lnbmF0dXJlIHJldHVybiB0eXBl
CiAJLy8gQmFzZSB0eXBlIHByb21vdGlvbgotCi0JdGhpcy5jb25zdGFudCA9IENvbnN0YW50Lk5v
dEFDb25zdGFudDsKLQlib29sZWFuIHJlY2VpdmVyQ2FzdCA9IGZhbHNlLCBhcmdzQ29udGFpbkNh
c3QgPSBmYWxzZTsKLQlpZiAodGhpcy5yZWNlaXZlciBpbnN0YW5jZW9mIENhc3RFeHByZXNzaW9u
KSB7Ci0JCXRoaXMucmVjZWl2ZXIuYml0cyB8PSBBU1ROb2RlLkRpc2FibGVVbm5lY2Vzc2FyeUNh
c3RDaGVjazsgLy8gd2lsbCBjaGVjayBsYXRlciBvbgotCQlyZWNlaXZlckNhc3QgPSB0cnVlOwot
CX0KLQl0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSA9IHRoaXMucmVjZWl2ZXIucmVzb2x2ZVR5cGUo
c2NvcGUpOwotCWJvb2xlYW4gcmVjZWl2ZXJJc1R5cGUgPSB0aGlzLnJlY2VpdmVyIGluc3RhbmNl
b2YgTmFtZVJlZmVyZW5jZSAmJiAoKChOYW1lUmVmZXJlbmNlKSB0aGlzLnJlY2VpdmVyKS5iaXRz
ICYgQmluZGluZy5UWVBFKSAhPSAwOwotCWlmIChyZWNlaXZlckNhc3QgJiYgdGhpcy5hY3R1YWxS
ZWNlaXZlclR5cGUgIT0gbnVsbCkgewotCQkgLy8gZHVlIHRvIGNoYW5nZSBvZiBkZWNsYXJpbmcg
Y2xhc3Mgd2l0aCByZWNlaXZlciB0eXBlLCBvbmx5IGlkZW50aXR5IGNhc3Qgc2hvdWxkIGJlIG5v
dGlmaWVkCi0JCWlmIChUeXBlQmluZGluZy5lcXVhbHNFcXVhbHMoKChDYXN0RXhwcmVzc2lvbil0
aGlzLnJlY2VpdmVyKS5leHByZXNzaW9uLnJlc29sdmVkVHlwZSwgdGhpcy5hY3R1YWxSZWNlaXZl
clR5cGUpKSB7Ci0JCQlzY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS51bm5lY2Vzc2FyeUNhc3QoKENh
c3RFeHByZXNzaW9uKXRoaXMucmVjZWl2ZXIpOworCWJvb2xlYW4gcG9seUV4cHJlc3Npb25TZWVu
ID0gZmFsc2U7CisJaWYgKHRoaXMuY29uc3RhbnQgIT0gQ29uc3RhbnQuTm90QUNvbnN0YW50KSB7
CisJCXRoaXMuY29uc3RhbnQgPSBDb25zdGFudC5Ob3RBQ29uc3RhbnQ7CisJCXRoaXMuZW5jbG9z
aW5nU2NvcGUgPSBzY29wZTsKKwkJYm9vbGVhbiByZWNlaXZlckNhc3QgPSBmYWxzZTsKKwkJaWYg
KHRoaXMucmVjZWl2ZXIgaW5zdGFuY2VvZiBDYXN0RXhwcmVzc2lvbikgeworCQkJdGhpcy5yZWNl
aXZlci5iaXRzIHw9IEFTVE5vZGUuRGlzYWJsZVVubmVjZXNzYXJ5Q2FzdENoZWNrOyAvLyB3aWxs
IGNoZWNrIGxhdGVyIG9uCisJCQlyZWNlaXZlckNhc3QgPSB0cnVlOwogCQl9Ci0JfQotCS8vIHJl
c29sdmUgdHlwZSBhcmd1bWVudHMgKGZvciBnZW5lcmljIGNvbnN0cnVjdG9yIGNhbGwpCi0JaWYg
KHRoaXMudHlwZUFyZ3VtZW50cyAhPSBudWxsKSB7Ci0JCWludCBsZW5ndGggPSB0aGlzLnR5cGVB
cmd1bWVudHMubGVuZ3RoOwotCQlib29sZWFuIGFyZ0hhc0Vycm9yID0gc2NvcGUuY29tcGlsZXJP
cHRpb25zKCkuc291cmNlTGV2ZWwgPCBDbGFzc0ZpbGVDb25zdGFudHMuSkRLMV81OyAvLyB0eXBl
Q2hlY2tzIGFsbCBhcmd1bWVudHMKLQkJdGhpcy5nZW5lcmljVHlwZUFyZ3VtZW50cyA9IG5ldyBU
eXBlQmluZGluZ1tsZW5ndGhdOwotCQlmb3IgKGludCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7
Ci0JCQlUeXBlUmVmZXJlbmNlIHR5cGVSZWZlcmVuY2UgPSB0aGlzLnR5cGVBcmd1bWVudHNbaV07
Ci0JCQlpZiAoKHRoaXMuZ2VuZXJpY1R5cGVBcmd1bWVudHNbaV0gPSB0eXBlUmVmZXJlbmNlLnJl
c29sdmVUeXBlKHNjb3BlLCB0cnVlIC8qIGNoZWNrIGJvdW5kcyovKSkgPT0gbnVsbCkgewotCQkJ
CWFyZ0hhc0Vycm9yID0gdHJ1ZTsKLQkJCX0KLQkJCWlmIChhcmdIYXNFcnJvciAmJiB0eXBlUmVm
ZXJlbmNlIGluc3RhbmNlb2YgV2lsZGNhcmQpIHsKLQkJCQlzY29wZS5wcm9ibGVtUmVwb3J0ZXIo
KS5pbGxlZ2FsVXNhZ2VPZldpbGRjYXJkKHR5cGVSZWZlcmVuY2UpOworCQl0aGlzLmFjdHVhbFJl
Y2VpdmVyVHlwZSA9IHRoaXMucmVjZWl2ZXIucmVzb2x2ZVR5cGUoc2NvcGUpOworCQl0aGlzLnJl
Y2VpdmVySXNUeXBlID0gdGhpcy5yZWNlaXZlciBpbnN0YW5jZW9mIE5hbWVSZWZlcmVuY2UgJiYg
KCgoTmFtZVJlZmVyZW5jZSkgdGhpcy5yZWNlaXZlcikuYml0cyAmIEJpbmRpbmcuVFlQRSkgIT0g
MDsKKwkJaWYgKHJlY2VpdmVyQ2FzdCAmJiB0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSAhPSBudWxs
KSB7CisJCQkvLyBkdWUgdG8gY2hhbmdlIG9mIGRlY2xhcmluZyBjbGFzcyB3aXRoIHJlY2VpdmVy
IHR5cGUsIG9ubHkgaWRlbnRpdHkgY2FzdCBzaG91bGQgYmUgbm90aWZpZWQKKwkJCWlmIChUeXBl
QmluZGluZy5lcXVhbHNFcXVhbHMoKChDYXN0RXhwcmVzc2lvbil0aGlzLnJlY2VpdmVyKS5leHBy
ZXNzaW9uLnJlc29sdmVkVHlwZSwgdGhpcy5hY3R1YWxSZWNlaXZlclR5cGUpKSB7CisJCQkJc2Nv
cGUucHJvYmxlbVJlcG9ydGVyKCkudW5uZWNlc3NhcnlDYXN0KChDYXN0RXhwcmVzc2lvbil0aGlz
LnJlY2VpdmVyKTsKIAkJCX0KIAkJfQotCQlpZiAoYXJnSGFzRXJyb3IpIHsKLQkJCWlmICh0aGlz
LmFyZ3VtZW50cyAhPSBudWxsKSB7IC8vIHN0aWxsIGF0dGVtcHQgdG8gcmVzb2x2ZSBhcmd1bWVu
dHMKLQkJCQlmb3IgKGludCBpID0gMCwgbWF4ID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwg
bWF4OyBpKyspIHsKLQkJCQkJdGhpcy5hcmd1bWVudHNbaV0ucmVzb2x2ZVR5cGUoc2NvcGUpOwor
CQkvLyByZXNvbHZlIHR5cGUgYXJndW1lbnRzIChmb3IgZ2VuZXJpYyBjb25zdHJ1Y3RvciBjYWxs
KQorCQlpZiAodGhpcy50eXBlQXJndW1lbnRzICE9IG51bGwpIHsKKwkJCWludCBsZW5ndGggPSB0
aGlzLnR5cGVBcmd1bWVudHMubGVuZ3RoOworCQkJYm9vbGVhbiBhcmdIYXNFcnJvciA9IHNjb3Bl
LmNvbXBpbGVyT3B0aW9ucygpLnNvdXJjZUxldmVsIDwgQ2xhc3NGaWxlQ29uc3RhbnRzLkpESzFf
NTsgLy8gdHlwZUNoZWNrcyBhbGwgYXJndW1lbnRzCisJCQl0aGlzLmdlbmVyaWNUeXBlQXJndW1l
bnRzID0gbmV3IFR5cGVCaW5kaW5nW2xlbmd0aF07CisJCQlmb3IgKGludCBpID0gMDsgaSA8IGxl
bmd0aDsgaSsrKSB7CisJCQkJVHlwZVJlZmVyZW5jZSB0eXBlUmVmZXJlbmNlID0gdGhpcy50eXBl
QXJndW1lbnRzW2ldOworCQkJCWlmICgodGhpcy5nZW5lcmljVHlwZUFyZ3VtZW50c1tpXSA9IHR5
cGVSZWZlcmVuY2UucmVzb2x2ZVR5cGUoc2NvcGUsIHRydWUgLyogY2hlY2sgYm91bmRzKi8pKSA9
PSBudWxsKSB7CisJCQkJCWFyZ0hhc0Vycm9yID0gdHJ1ZTsKKwkJCQl9CisJCQkJaWYgKGFyZ0hh
c0Vycm9yICYmIHR5cGVSZWZlcmVuY2UgaW5zdGFuY2VvZiBXaWxkY2FyZCkgeworCQkJCQlzY29w
ZS5wcm9ibGVtUmVwb3J0ZXIoKS5pbGxlZ2FsVXNhZ2VPZldpbGRjYXJkKHR5cGVSZWZlcmVuY2Up
OwogCQkJCX0KIAkJCX0KLQkJCXJldHVybiBudWxsOwotCQl9Ci0JfQotCS8vIHdpbGwgY2hlY2sg
Zm9yIG51bGwgYWZ0ZXIgYXJncyBhcmUgcmVzb2x2ZWQKLQlUeXBlQmluZGluZ1tdIGFyZ3VtZW50
VHlwZXMgPSBCaW5kaW5nLk5PX1BBUkFNRVRFUlM7Ci0JYm9vbGVhbiBwb2x5RXhwcmVzc2lvblNl
ZW4gPSBmYWxzZTsKLQlpZiAodGhpcy5hcmd1bWVudHMgIT0gbnVsbCkgewotCQlib29sZWFuIGFy
Z0hhc0Vycm9yID0gZmFsc2U7IC8vIHR5cGVDaGVja3MgYWxsIGFyZ3VtZW50cwotCQlpbnQgbGVu
Z3RoID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOwotCQlhcmd1bWVudFR5cGVzID0gbmV3IFR5cGVC
aW5kaW5nW2xlbmd0aF07Ci0JCVR5cGVCaW5kaW5nIGFyZ3VtZW50VHlwZTsKLQkJZm9yIChpbnQg
aSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7Ci0JCQlFeHByZXNzaW9uIGFyZ3VtZW50ID0gdGhpcy5h
cmd1bWVudHNbaV07Ci0JCQlpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBDYXN0RXhwcmVzc2lvbikg
ewotCQkJCWFyZ3VtZW50LmJpdHMgfD0gQVNUTm9kZS5EaXNhYmxlVW5uZWNlc3NhcnlDYXN0Q2hl
Y2s7IC8vIHdpbGwgY2hlY2sgbGF0ZXIgb24KLQkJCQlhcmdzQ29udGFpbkNhc3QgPSB0cnVlOwot
CQkJfQotCQkJYXJndW1lbnQuc2V0RXhwcmVzc2lvbkNvbnRleHQoSU5WT0NBVElPTl9DT05URVhU
KTsKLQkJCWlmICgoYXJndW1lbnRUeXBlID0gYXJndW1lbnRUeXBlc1tpXSA9IGFyZ3VtZW50LnJl
c29sdmVUeXBlKHNjb3BlKSkgPT0gbnVsbCl7Ci0JCQkJYXJnSGFzRXJyb3IgPSB0cnVlOwotCQkJ
fQotCQkJaWYgKGFyZ3VtZW50VHlwZSAhPSBudWxsICYmIGFyZ3VtZW50VHlwZS5raW5kKCkgPT0g
QmluZGluZy5QT0xZX1RZUEUpCi0JCQkJcG9seUV4cHJlc3Npb25TZWVuID0gdHJ1ZTsKLQkJfQot
CQlpZiAoYXJnSGFzRXJyb3IpIHsKLQkJCWlmICh0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSBpbnN0
YW5jZW9mIFJlZmVyZW5jZUJpbmRpbmcpIHsKLQkJCQkvLyAgcmVjb3JkIGEgYmVzdCBndWVzcywg
Zm9yIGNsaWVudHMgd2hvIG5lZWQgaGludCBhYm91dCBwb3NzaWJsZSBtZXRob2QgbWF0Y2gKLQkJ
CQlUeXBlQmluZGluZ1tdIHBzZXVkb0FyZ3MgPSBuZXcgVHlwZUJpbmRpbmdbbGVuZ3RoXTsKLQkJ
CQlmb3IgKGludCBpID0gbGVuZ3RoOyAtLWkgPj0gMDspCi0JCQkJCXBzZXVkb0FyZ3NbaV0gPSBh
cmd1bWVudFR5cGVzW2ldID09IG51bGwgPyBUeXBlQmluZGluZy5OVUxMIDogYXJndW1lbnRUeXBl
c1tpXTsgLy8gcmVwbGFjZSBhcmdzIHdpdGggZXJyb3JzIHdpdGggbnVsbCB0eXBlCi0JCQkJdGhp
cy5iaW5kaW5nID0KLQkJCQkJdGhpcy5yZWNlaXZlci5pc0ltcGxpY2l0VGhpcygpCi0JCQkJCQk/
IHNjb3BlLmdldEltcGxpY2l0TWV0aG9kKHRoaXMuc2VsZWN0b3IsIHBzZXVkb0FyZ3MsIHRoaXMp
Ci0JCQkJCQk6IHNjb3BlLmZpbmRNZXRob2QoKFJlZmVyZW5jZUJpbmRpbmcpIHRoaXMuYWN0dWFs
UmVjZWl2ZXJUeXBlLCB0aGlzLnNlbGVjdG9yLCBwc2V1ZG9BcmdzLCB0aGlzLCBmYWxzZSk7Ci0J
CQkJaWYgKHRoaXMuYmluZGluZyAhPSBudWxsICYmICF0aGlzLmJpbmRpbmcuaXNWYWxpZEJpbmRp
bmcoKSkgewotCQkJCQlNZXRob2RCaW5kaW5nIGNsb3Nlc3RNYXRjaCA9ICgoUHJvYmxlbU1ldGhv
ZEJpbmRpbmcpdGhpcy5iaW5kaW5nKS5jbG9zZXN0TWF0Y2g7Ci0JCQkJCS8vIHJlY29yZCB0aGUg
Y2xvc2VzdCBtYXRjaCwgZm9yIGNsaWVudHMgd2hvIG1heSBzdGlsbCBuZWVkIGhpbnQgYWJvdXQg
cG9zc2libGUgbWV0aG9kIG1hdGNoCi0JCQkJCWlmIChjbG9zZXN0TWF0Y2ggIT0gbnVsbCkgewot
CQkJCQkJaWYgKGNsb3Nlc3RNYXRjaC5vcmlnaW5hbCgpLnR5cGVWYXJpYWJsZXMgIT0gQmluZGlu
Zy5OT19UWVBFX1ZBUklBQkxFUykgeyAvLyBnZW5lcmljIG1ldGhvZAotCQkJCQkJCS8vIHNob3Vs
ZG4ndCByZXR1cm4gZ2VuZXJpYyBtZXRob2Qgb3V0c2lkZSBpdHMgY29udGV4dCwgcmF0aGVyIGNv
bnZlcnQgaXQgdG8gcmF3IG1ldGhvZCAoMTc1NDA5KQotCQkJCQkJCWNsb3Nlc3RNYXRjaCA9IHNj
b3BlLmVudmlyb25tZW50KCkuY3JlYXRlUGFyYW1ldGVyaXplZEdlbmVyaWNNZXRob2QoY2xvc2Vz
dE1hdGNoLm9yaWdpbmFsKCksIChSYXdUeXBlQmluZGluZyludWxsKTsKLQkJCQkJCX0KLQkJCQkJ
CXRoaXMuYmluZGluZyA9IGNsb3Nlc3RNYXRjaDsKLQkJCQkJCU1ldGhvZEJpbmRpbmcgY2xvc2Vz
dE1hdGNoT3JpZ2luYWwgPSBjbG9zZXN0TWF0Y2gub3JpZ2luYWwoKTsKLQkJCQkJCWlmIChjbG9z
ZXN0TWF0Y2hPcmlnaW5hbC5pc09yRW5jbG9zZWRCeVByaXZhdGVUeXBlKCkgJiYgIXNjb3BlLmlz
RGVmaW5lZEluTWV0aG9kKGNsb3Nlc3RNYXRjaE9yaWdpbmFsKSkgewotCQkJCQkJCS8vIGlnbm9y
ZSBjYXNlcyB3aGVyZSBtZXRob2QgaXMgdXNlZCBmcm9tIHdpdGhpbiBpbnNpZGUgaXRzZWxmIChl
LmcuIGRpcmVjdCByZWN1cnNpb25zKQotCQkJCQkJCWNsb3Nlc3RNYXRjaE9yaWdpbmFsLm1vZGlm
aWVycyB8PSBFeHRyYUNvbXBpbGVyTW9kaWZpZXJzLkFjY0xvY2FsbHlVc2VkOwotCQkJCQkJfQor
CQkJaWYgKGFyZ0hhc0Vycm9yKSB7CisJCQkJaWYgKHRoaXMuYXJndW1lbnRzICE9IG51bGwpIHsg
Ly8gc3RpbGwgYXR0ZW1wdCB0byByZXNvbHZlIGFyZ3VtZW50cworCQkJCQlmb3IgKGludCBpID0g
MCwgbWF4ID0gdGhpcy5hcmd1bWVudHMubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHsKKwkJCQkJCXRo
aXMuYXJndW1lbnRzW2ldLnJlc29sdmVUeXBlKHNjb3BlKTsKIAkJCQkJfQogCQkJCX0KKwkJCQly
ZXR1cm4gbnVsbDsKIAkJCX0KKwkJfQorCQl0aGlzLmFyZ3VtZW50VHlwZXMgPSBCaW5kaW5nLk5P
X1BBUkFNRVRFUlM7CisJCXBvbHlFeHByZXNzaW9uU2VlbiA9IGZhbHNlOworCQlpZiAodGhpcy5h
cmd1bWVudHMgIT0gbnVsbCkgeworCQkJYm9vbGVhbiBhcmdIYXNFcnJvciA9IGZhbHNlOyAvLyB0
eXBlQ2hlY2tzIGFsbCBhcmd1bWVudHMKKwkJCWludCBsZW5ndGggPSB0aGlzLmFyZ3VtZW50cy5s
ZW5ndGg7CisJCQl0aGlzLmFyZ3VtZW50VHlwZXMgPSBuZXcgVHlwZUJpbmRpbmdbbGVuZ3RoXTsK
KwkJCVR5cGVCaW5kaW5nIGFyZ3VtZW50VHlwZTsKKwkJCWZvciAoaW50IGkgPSAwOyBpIDwgbGVu
Z3RoOyBpKyspeworCQkJCUV4cHJlc3Npb24gYXJndW1lbnQgPSB0aGlzLmFyZ3VtZW50c1tpXTsK
KwkJCQlpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBDYXN0RXhwcmVzc2lvbikgeworCQkJCQlhcmd1
bWVudC5iaXRzIHw9IEFTVE5vZGUuRGlzYWJsZVVubmVjZXNzYXJ5Q2FzdENoZWNrOyAvLyB3aWxs
IGNoZWNrIGxhdGVyIG9uCisJCQkJCXRoaXMuYXJnc0NvbnRhaW5DYXN0ID0gdHJ1ZTsKKwkJCQl9
CisJCQkJYXJndW1lbnQuc2V0RXhwcmVzc2lvbkNvbnRleHQoSU5WT0NBVElPTl9DT05URVhUKTsK
KwkJCQlpZiAoKGFyZ3VtZW50VHlwZSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpXSA9IGFyZ3VtZW50
LnJlc29sdmVUeXBlKHNjb3BlKSkgPT0gbnVsbCl7CisJCQkJCWFyZ0hhc0Vycm9yID0gdHJ1ZTsK
KwkJCQl9CisJCQkJaWYgKGFyZ3VtZW50VHlwZSAhPSBudWxsICYmIGFyZ3VtZW50VHlwZS5raW5k
KCkgPT0gQmluZGluZy5QT0xZX1RZUEUpCisJCQkJCXBvbHlFeHByZXNzaW9uU2VlbiA9IHRydWU7
CisJCQl9CisJCQlpZiAoYXJnSGFzRXJyb3IpIHsKKwkJCQlpZiAodGhpcy5hY3R1YWxSZWNlaXZl
clR5cGUgaW5zdGFuY2VvZiBSZWZlcmVuY2VCaW5kaW5nKSB7CisJCQkJCS8vICByZWNvcmQgYSBi
ZXN0IGd1ZXNzLCBmb3IgY2xpZW50cyB3aG8gbmVlZCBoaW50IGFib3V0IHBvc3NpYmxlIG1ldGhv
ZCBtYXRjaAorCQkJCQlUeXBlQmluZGluZ1tdIHBzZXVkb0FyZ3MgPSBuZXcgVHlwZUJpbmRpbmdb
bGVuZ3RoXTsKKwkJCQkJZm9yIChpbnQgaSA9IGxlbmd0aDsgLS1pID49IDA7KQorCQkJCQkJcHNl
dWRvQXJnc1tpXSA9IHRoaXMuYXJndW1lbnRUeXBlc1tpXSA9PSBudWxsID8gVHlwZUJpbmRpbmcu
TlVMTCA6IHRoaXMuYXJndW1lbnRUeXBlc1tpXTsgLy8gcmVwbGFjZSBhcmdzIHdpdGggZXJyb3Jz
IHdpdGggbnVsbCB0eXBlCisJCQkJCXRoaXMuYmluZGluZyA9CisJCQkJCQkJdGhpcy5yZWNlaXZl
ci5pc0ltcGxpY2l0VGhpcygpCisJCQkJCQkJPyBzY29wZS5nZXRJbXBsaWNpdE1ldGhvZCh0aGlz
LnNlbGVjdG9yLCBwc2V1ZG9BcmdzLCB0aGlzKQorCQkJCQkJCQkJOiBzY29wZS5maW5kTWV0aG9k
KChSZWZlcmVuY2VCaW5kaW5nKSB0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSwgdGhpcy5zZWxlY3Rv
ciwgcHNldWRvQXJncywgdGhpcywgZmFsc2UpOworCQkJCQkJCWlmICh0aGlzLmJpbmRpbmcgIT0g
bnVsbCAmJiAhdGhpcy5iaW5kaW5nLmlzVmFsaWRCaW5kaW5nKCkpIHsKKwkJCQkJCQkJTWV0aG9k
QmluZGluZyBjbG9zZXN0TWF0Y2ggPSAoKFByb2JsZW1NZXRob2RCaW5kaW5nKXRoaXMuYmluZGlu
ZykuY2xvc2VzdE1hdGNoOworCQkJCQkJCQkvLyByZWNvcmQgdGhlIGNsb3Nlc3QgbWF0Y2gsIGZv
ciBjbGllbnRzIHdobyBtYXkgc3RpbGwgbmVlZCBoaW50IGFib3V0IHBvc3NpYmxlIG1ldGhvZCBt
YXRjaAorCQkJCQkJCQlpZiAoY2xvc2VzdE1hdGNoICE9IG51bGwpIHsKKwkJCQkJCQkJCWlmIChj
bG9zZXN0TWF0Y2gub3JpZ2luYWwoKS50eXBlVmFyaWFibGVzICE9IEJpbmRpbmcuTk9fVFlQRV9W
QVJJQUJMRVMpIHsgLy8gZ2VuZXJpYyBtZXRob2QKKwkJCQkJCQkJCQkvLyBzaG91bGRuJ3QgcmV0
dXJuIGdlbmVyaWMgbWV0aG9kIG91dHNpZGUgaXRzIGNvbnRleHQsIHJhdGhlciBjb252ZXJ0IGl0
IHRvIHJhdyBtZXRob2QgKDE3NTQwOSkKKwkJCQkJCQkJCQljbG9zZXN0TWF0Y2ggPSBzY29wZS5l
bnZpcm9ubWVudCgpLmNyZWF0ZVBhcmFtZXRlcml6ZWRHZW5lcmljTWV0aG9kKGNsb3Nlc3RNYXRj
aC5vcmlnaW5hbCgpLCAoUmF3VHlwZUJpbmRpbmcpbnVsbCk7CisJCQkJCQkJCQl9CisJCQkJCQkJ
CQl0aGlzLmJpbmRpbmcgPSBjbG9zZXN0TWF0Y2g7CisJCQkJCQkJCQlNZXRob2RCaW5kaW5nIGNs
b3Nlc3RNYXRjaE9yaWdpbmFsID0gY2xvc2VzdE1hdGNoLm9yaWdpbmFsKCk7CisJCQkJCQkJCQlp
ZiAoY2xvc2VzdE1hdGNoT3JpZ2luYWwuaXNPckVuY2xvc2VkQnlQcml2YXRlVHlwZSgpICYmICFz
Y29wZS5pc0RlZmluZWRJbk1ldGhvZChjbG9zZXN0TWF0Y2hPcmlnaW5hbCkpIHsKKwkJCQkJCQkJ
CQkvLyBpZ25vcmUgY2FzZXMgd2hlcmUgbWV0aG9kIGlzIHVzZWQgZnJvbSB3aXRoaW4gaW5zaWRl
IGl0c2VsZiAoZS5nLiBkaXJlY3QgcmVjdXJzaW9ucykKKwkJCQkJCQkJCQljbG9zZXN0TWF0Y2hP
cmlnaW5hbC5tb2RpZmllcnMgfD0gRXh0cmFDb21waWxlck1vZGlmaWVycy5BY2NMb2NhbGx5VXNl
ZDsKKwkJCQkJCQkJCX0KKwkJCQkJCQkJfQorCQkJCQkJCX0KKwkJCQl9CisJCQkJcmV0dXJuIG51
bGw7CisJCQl9CisJCX0KKwkJaWYgKHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBlID09IG51bGwpIHsK
IAkJCXJldHVybiBudWxsOwogCQl9CisJCS8vIGJhc2UgdHlwZSBjYW5ub3QgcmVjZWl2ZSBhbnkg
bWVzc2FnZQorCQlpZiAodGhpcy5hY3R1YWxSZWNlaXZlclR5cGUuaXNCYXNlVHlwZSgpKSB7CisJ
CQlzY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5lcnJvck5vTWV0aG9kRm9yKHRoaXMsIHRoaXMuYWN0
dWFsUmVjZWl2ZXJUeXBlLCB0aGlzLmFyZ3VtZW50VHlwZXMpOworCQkJcmV0dXJuIG51bGw7CisJ
CX0KKwl9IGVsc2UgeworCQlwb2x5RXhwcmVzc2lvblNlZW4gPSB0cnVlOworCQlib29sZWFuIGFy
Z0hhc0Vycm9yID0gZmFsc2U7IC8vIHR5cGVDaGVja3MgYWxsIGFyZ3VtZW50cworCQlpbnQgbGVu
Z3RoID0gdGhpcy5hcmd1bWVudHMgPT0gbnVsbCA/IDAgOiB0aGlzLmFyZ3VtZW50cy5sZW5ndGg7
CisJCWZvciAoaW50IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHsKKwkJCWlmICh0aGlzLmFyZ3Vt
ZW50VHlwZXNbaV0ua2luZCgpID09IEJpbmRpbmcuUE9MWV9UWVBFKSB7CisJCQkJRXhwcmVzc2lv
biBhcmd1bWVudCA9IHRoaXMuYXJndW1lbnRzW2ldOworCQkJCWFyZ3VtZW50LnNldEV4cHJlc3Np
b25Db250ZXh0KElOVk9DQVRJT05fQ09OVEVYVCk7CisJCQkJaWYgKCh0aGlzLmFyZ3VtZW50VHlw
ZXNbaV0gPSBhcmd1bWVudC5yZXNvbHZlVHlwZShzY29wZSkpID09IG51bGwpIHsKKwkJCQkJYXJn
SGFzRXJyb3IgPSB0cnVlOworCQkJCX0KKwkJCX0KKwkJfQorCQlpZiAoYXJnSGFzRXJyb3IpCisJ
CQlyZXR1cm4gbnVsbDsKIAl9Ci0JaWYgKHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBlID09IG51bGwp
IHsKLQkJcmV0dXJuIG51bGw7CisJdHJ5IHsKKwkJdGhpcy5iaW5kaW5nID0gdGhpcy5yZWNlaXZl
ci5pc0ltcGxpY2l0VGhpcygpCisJCQkJPyBzY29wZS5nZXRJbXBsaWNpdE1ldGhvZCh0aGlzLnNl
bGVjdG9yLCB0aGlzLmFyZ3VtZW50VHlwZXMsIHRoaXMpCisJCQkJCQk6IHNjb3BlLmdldE1ldGhv
ZCh0aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSwgdGhpcy5zZWxlY3RvciwgdGhpcy5hcmd1bWVudFR5
cGVzLCB0aGlzKTsKKwl9IGNhdGNoIChQb2x5VHlwZUV4Y2VwdGlvbiBwKSB7CisJCXRoaXMuaXNQ
b2x5RXhwcmVzc2lvbiA9IHRydWU7CisJCXJldHVybiBuZXcgUG9seVR5cGVCaW5kaW5nKHRoaXMp
OwogCX0KLQkvLyBiYXNlIHR5cGUgY2Fubm90IHJlY2VpdmUgYW55IG1lc3NhZ2UKLQlpZiAodGhp
cy5hY3R1YWxSZWNlaXZlclR5cGUuaXNCYXNlVHlwZSgpKSB7Ci0JCXNjb3BlLnByb2JsZW1SZXBv
cnRlcigpLmVycm9yTm9NZXRob2RGb3IodGhpcywgdGhpcy5hY3R1YWxSZWNlaXZlclR5cGUsIGFy
Z3VtZW50VHlwZXMpOwotCQlyZXR1cm4gbnVsbDsKLQl9Ci0JdGhpcy5iaW5kaW5nID0gdGhpcy5y
ZWNlaXZlci5pc0ltcGxpY2l0VGhpcygpCi0JCQk/IHNjb3BlLmdldEltcGxpY2l0TWV0aG9kKHRo
aXMuc2VsZWN0b3IsIGFyZ3VtZW50VHlwZXMsIHRoaXMpCi0JCQk6IHNjb3BlLmdldE1ldGhvZCh0
aGlzLmFjdHVhbFJlY2VpdmVyVHlwZSwgdGhpcy5zZWxlY3RvciwgYXJndW1lbnRUeXBlcywgdGhp
cyk7CiAJCi0JaWYgKHBvbHlFeHByZXNzaW9uU2VlbiAmJiBwb2x5RXhwcmVzc2lvbnNIYXZlRXJy
b3JzKHNjb3BlLCB0aGlzLmJpbmRpbmcsIHRoaXMuYXJndW1lbnRzLCBhcmd1bWVudFR5cGVzKSkK
KwlpZiAocG9seUV4cHJlc3Npb25TZWVuICYmIHBvbHlFeHByZXNzaW9uc0hhdmVFcnJvcnMoc2Nv
cGUsIHRoaXMuYmluZGluZywgdGhpcy5hcmd1bWVudHMsIHRoaXMuYXJndW1lbnRUeXBlcykpCiAJ
CXJldHVybiBudWxsOwogCiAJaWYgKCF0aGlzLmJpbmRpbmcuaXNWYWxpZEJpbmRpbmcoKSkgewpA
QCAtNjgxLDcgKzc2OSw3IEBACiAJCQlpZiAodGhpcy5hY3R1YWxSZWNlaXZlclR5cGUgaW5zdGFu
Y2VvZiBSZWZlcmVuY2VCaW5kaW5nKSB7CiAJCQkJdGhpcy5iaW5kaW5nLmRlY2xhcmluZ0NsYXNz
ID0gKFJlZmVyZW5jZUJpbmRpbmcpIHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBlOwogCQkJfSBlbHNl
IHsKLQkJCQlzY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5lcnJvck5vTWV0aG9kRm9yKHRoaXMsIHRo
aXMuYWN0dWFsUmVjZWl2ZXJUeXBlLCBhcmd1bWVudFR5cGVzKTsKKwkJCQlzY29wZS5wcm9ibGVt
UmVwb3J0ZXIoKS5lcnJvck5vTWV0aG9kRm9yKHRoaXMsIHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBl
LCB0aGlzLmFyZ3VtZW50VHlwZXMpOwogCQkJCXJldHVybiBudWxsOwogCQkJfQogCQl9CkBAIC03
NTEsNyArODM5LDcgQEAKIAl9CiAJaWYgKCF0aGlzLmJpbmRpbmcuaXNTdGF0aWMoKSkgewogCQkv
LyB0aGUgInJlY2VpdmVyIiBtdXN0IG5vdCBiZSBhIHR5cGUKLQkJaWYgKHJlY2VpdmVySXNUeXBl
KSB7CisJCWlmICh0aGlzLnJlY2VpdmVySXNUeXBlKSB7CiAJCQlzY29wZS5wcm9ibGVtUmVwb3J0
ZXIoKS5tdXN0VXNlQVN0YXRpY01ldGhvZCh0aGlzLCB0aGlzLmJpbmRpbmcpOwogCQkJaWYgKHRo
aXMuYWN0dWFsUmVjZWl2ZXJUeXBlLmlzUmF3VHlwZSgpCiAJCQkJCSYmICh0aGlzLnJlY2VpdmVy
LmJpdHMgJiBBU1ROb2RlLklnbm9yZVJhd1R5cGVDaGVjaykgPT0gMApAQCAtNzcwLDE0ICs4NTgs
MTQgQEAKIAkJfQogCX0gZWxzZSB7CiAJCS8vIHN0YXRpYyBtZXNzYWdlIGludm9rZWQgdGhyb3Vn
aCByZWNlaXZlcj8gbGVnYWwgYnV0IHVub3B0aW1hbCAob3B0aW9uYWwgd2FybmluZykuCi0JCWlm
ICghKHRoaXMucmVjZWl2ZXIuaXNJbXBsaWNpdFRoaXMoKSB8fCB0aGlzLnJlY2VpdmVyLmlzU3Vw
ZXIoKSB8fCByZWNlaXZlcklzVHlwZSkpIHsKKwkJaWYgKCEodGhpcy5yZWNlaXZlci5pc0ltcGxp
Y2l0VGhpcygpIHx8IHRoaXMucmVjZWl2ZXIuaXNTdXBlcigpIHx8IHRoaXMucmVjZWl2ZXJJc1R5
cGUpKSB7CiAJCQlzY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5ub25TdGF0aWNBY2Nlc3NUb1N0YXRp
Y01ldGhvZCh0aGlzLCB0aGlzLmJpbmRpbmcpOwogCQl9CiAJCWlmICghdGhpcy5yZWNlaXZlci5p
c0ltcGxpY2l0VGhpcygpICYmIFR5cGVCaW5kaW5nLm5vdEVxdWFscyh0aGlzLmJpbmRpbmcuZGVj
bGFyaW5nQ2xhc3MsIHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBlKSkgewogCQkJc2NvcGUucHJvYmxl
bVJlcG9ydGVyKCkuaW5kaXJlY3RBY2Nlc3NUb1N0YXRpY01ldGhvZCh0aGlzLCB0aGlzLmJpbmRp
bmcpOwogCQl9CiAJfQotCWlmIChjaGVja0ludm9jYXRpb25Bcmd1bWVudHMoc2NvcGUsIHRoaXMu
cmVjZWl2ZXIsIHRoaXMuYWN0dWFsUmVjZWl2ZXJUeXBlLCB0aGlzLmJpbmRpbmcsIHRoaXMuYXJn
dW1lbnRzLCBhcmd1bWVudFR5cGVzLCBhcmdzQ29udGFpbkNhc3QsIHRoaXMpKSB7CisJaWYgKGNo
ZWNrSW52b2NhdGlvbkFyZ3VtZW50cyhzY29wZSwgdGhpcy5yZWNlaXZlciwgdGhpcy5hY3R1YWxS
ZWNlaXZlclR5cGUsIHRoaXMuYmluZGluZywgdGhpcy5hcmd1bWVudHMsIHRoaXMuYXJndW1lbnRU
eXBlcywgdGhpcy5hcmdzQ29udGFpbkNhc3QsIHRoaXMpKSB7CiAJCXRoaXMuYml0cyB8PSBBU1RO
b2RlLlVuY2hlY2tlZDsKIAl9CiAKQEAgLTgyNCw3ICs5MTIsNyBAQAogCX0KIAlpZiAodGhpcy5y
ZWNlaXZlci5pc1N1cGVyKCkgJiYgdGhpcy5hY3R1YWxSZWNlaXZlclR5cGUuaXNJbnRlcmZhY2Uo
KSkgewogCQkvLyAxNS4xMi4zIChKYXZhIDgpCi0JCXNjb3BlLmNoZWNrQXBwcm9wcmlhdGVNZXRo
b2RBZ2FpbnN0U3VwZXJzKHRoaXMuc2VsZWN0b3IsIHRoaXMuYmluZGluZywgYXJndW1lbnRUeXBl
cywgdGhpcyk7CisJCXNjb3BlLmNoZWNrQXBwcm9wcmlhdGVNZXRob2RBZ2FpbnN0U3VwZXJzKHRo
aXMuc2VsZWN0b3IsIHRoaXMuYmluZGluZywgdGhpcy5hcmd1bWVudFR5cGVzLCB0aGlzKTsKIAl9
CiAJaWYgKHRoaXMudHlwZUFyZ3VtZW50cyAhPSBudWxsICYmIHRoaXMuYmluZGluZy5vcmlnaW5h
bCgpLnR5cGVWYXJpYWJsZXMgPT0gQmluZGluZy5OT19UWVBFX1ZBUklBQkxFUykgewogCQlzY29w
ZS5wcm9ibGVtUmVwb3J0ZXIoKS51bm5lY2Vzc2FyeVR5cGVBcmd1bWVudHNGb3JNZXRob2RJbnZv
Y2F0aW9uKHRoaXMuYmluZGluZywgdGhpcy5nZW5lcmljVHlwZUFyZ3VtZW50cywgdGhpcy50eXBl
QXJndW1lbnRzKTsKQEAgLTg1Nyw0MCArOTQ1LDIyIEBACiB9CiAKIHB1YmxpYyBib29sZWFuIGlz
UG9seUV4cHJlc3Npb24oKSB7Ci0JCi0JLyogMTUuMTIgaGFzIGZvdXIgcmVxdWlyZW1lbnRzOiAx
KSBUaGUgaW52b2NhdGlvbiBhcHBlYXJzIGluIGFuIGFzc2lnbm1lbnQgY29udGV4dCBvciBhbiBp
bnZvY2F0aW9uIGNvbnRleHQKLSAgICAgICAyKSBUaGUgaW52b2NhdGlvbiBlbGlkZXMgTm9uV2ls
ZFR5cGVBcmd1bWVudHMgMykgdGhlIG1ldGhvZCB0byBiZSBpbnZva2VkIGlzIGEgZ2VuZXJpYyBt
ZXRob2QgKDguNC40KS4KLSAgICAgICA0KSBUaGUgcmV0dXJuIHR5cGUgb2YgdGhlIG1ldGhvZCB0
byBiZSBpbnZva2VkIG1lbnRpb25zIGF0IGxlYXN0IG9uZSBvZiB0aGUgbWV0aG9kJ3MgdHlwZSBw
YXJhbWV0ZXJzLgotCi0gICAgICAgV2UgYXJlIGluIG5vIHBvc2l0aW9uIHRvIGFzY2VydGFpbiB0
aGUgbGFzdCB0d28gdW50aWwgYWZ0ZXIgcmVzb2x1dGlvbiBoYXMgaGFwcGVuZWQuIFNvIG5vIGNs
aWVudCBzaG91bGQKLSAgICAgICBkZXBlbmQgb24gYXNraW5nIHRoaXMgcXVlc3Rpb24gYmVmb3Jl
IHJlc29sdXRpb24uCi0JKi8KLQlpZiAodGhpcy5leHByZXNzaW9uQ29udGV4dCAhPSBBU1NJR05N
RU5UX0NPTlRFWFQgJiYgdGhpcy5leHByZXNzaW9uQ29udGV4dCAhPSBJTlZPQ0FUSU9OX0NPTlRF
WFQpCi0JCXJldHVybiBmYWxzZTsKLQkKLQlpZiAodGhpcy50eXBlQXJndW1lbnRzICE9IG51bGwg
JiYgdGhpcy50eXBlQXJndW1lbnRzLmxlbmd0aCA+IDApCi0JCXJldHVybiBmYWxzZTsKLQkKLQlp
ZiAodGhpcy5jb25zdGFudCAhPSBDb25zdGFudC5Ob3RBQ29uc3RhbnQpCi0JCXRocm93IG5ldyBV
bnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbigiVW5yZXNvbHZlZCBNZXNzYWdlU2VuZCBjYW4n
dCBiZSBxdWVyaWVkIGlmIGl0IGlzIGEgcG9seWV4cHJlc3Npb24iKTsgLy8kTk9OLU5MUy0xJAot
CQotCWlmICh0aGlzLmJpbmRpbmcgIT0gbnVsbCAmJiB0aGlzLmJpbmRpbmcgaW5zdGFuY2VvZiBQ
YXJhbWV0ZXJpemVkR2VuZXJpY01ldGhvZEJpbmRpbmcpIHsKLQkJUGFyYW1ldGVyaXplZEdlbmVy
aWNNZXRob2RCaW5kaW5nIHBnbWIgPSAoUGFyYW1ldGVyaXplZEdlbmVyaWNNZXRob2RCaW5kaW5n
KSB0aGlzLmJpbmRpbmc7Ci0JCXJldHVybiBwZ21iLmluZmVycmVkUmV0dXJuVHlwZTsKLQl9Ci0J
Ci0JcmV0dXJuIGZhbHNlOworCXJldHVybiB0aGlzLmlzUG9seUV4cHJlc3Npb247CiB9CiAKLXB1
YmxpYyBib29sZWFuIHNJc01vcmVTcGVjaWZpYyhUeXBlQmluZGluZyBzLCBUeXBlQmluZGluZyB0
KSB7Ci0JcmV0dXJuIGlzUG9seUV4cHJlc3Npb24oKSA/ICFzLmlzQmFzZVR5cGUoKSAmJiB0Lmlz
QmFzZVR5cGUoKSA6IHN1cGVyLnNJc01vcmVTcGVjaWZpYyhzLCB0KTsKK3B1YmxpYyBib29sZWFu
IHNJc01vcmVTcGVjaWZpYyhUeXBlQmluZGluZyBzLCBUeXBlQmluZGluZyB0LCBTY29wZSBzY29w
ZSkgeworCWlmICghdGhpcy5pc1BvbHlFeHByZXNzaW9uKCkpCisJCXJldHVybiBzdXBlci5zSXNN
b3JlU3BlY2lmaWMocywgdCwgc2NvcGUpOworCVR5cGVCaW5kaW5nIHNDYW5kaWRhdGVUeXBlID0g
KFR5cGVCaW5kaW5nKSB0aGlzLmNhbmRpZGF0ZVR5cGVzLmdldChzKTsKKwlUeXBlQmluZGluZyB0
Q2FuZGlkYXRlVHlwZSA9IChUeXBlQmluZGluZykgdGhpcy5jYW5kaWRhdGVUeXBlcy5nZXQodCk7
CisJcmV0dXJuIHNDYW5kaWRhdGVUeXBlLmlzQ29tcGF0aWJsZVdpdGgodENhbmRpZGF0ZVR5cGUs
IHRoaXMuZW5jbG9zaW5nU2NvcGUpOwogfQogCiBwdWJsaWMgdm9pZCBzZXRGaWVsZEluZGV4KGlu
dCBkZXB0aCkgewogCS8vIGlnbm9yZSBmb3IgaGVyZQogfQogcHVibGljIFR5cGVCaW5kaW5nIGV4
cGVjdGVkVHlwZSgpIHsKLQlyZXR1cm4gdGhpcy5leHBlY3RlZFR5cGU7CisJcmV0dXJuIHRoaXMu
ZXhwZWN0ZWRUeXBlICE9IG51bGwgPyB0aGlzLmV4cGVjdGVkVHlwZSA6IHRoaXMuZXhwcmVzc2lv
bkNvbnRleHQgPT0gSU5WT0NBVElPTl9DT05URVhUID8gbmV3IFBvbHlUeXBlQmluZGluZyhudWxs
KSA6IG51bGw7CiB9CiAKIHB1YmxpYyB2b2lkIHRyYXZlcnNlKEFTVFZpc2l0b3IgdmlzaXRvciwg
QmxvY2tTY29wZSBibG9ja1Njb3BlKSB7CmRpZmYgLS1naXQgYS9vcmcuZWNsaXBzZS5qZHQuY29y
ZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvYXN0L1JlZmVyZW5j
ZUV4cHJlc3Npb24uamF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhwcmVzc2lvbi5qYXZhCmlu
ZGV4IGFjZTZlM2EuLjIwOGIzNjcgMTAwNjQ0Ci0tLSBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2Nv
bXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhw
cmVzc2lvbi5qYXZhCisrKyBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xp
cHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9hc3QvUmVmZXJlbmNlRXhwcmVzc2lvbi5qYXZhCkBA
IC0yMjQsNiArMjI0LDI1IEBACiAJCXJldHVybiBmbG93SW5mbzsKIAl9CiAKKwlwdWJsaWMgVHlw
ZUJpbmRpbmcgcmVzb2x2ZVR5cGVFeHBlY3RpbmcoQmxvY2tTY29wZSBzY29wZSwgVHlwZUJpbmRp
bmcgbGVmdCkgeworCQkvLyAxNS4yOC4yCisJCWZpbmFsIE1ldGhvZEJpbmRpbmcgc2FtID0gbGVm
dC5nZXRTaW5nbGVBYnN0cmFjdE1ldGhvZCh0aGlzLmVuY2xvc2luZ1Njb3BlKTsKKwkJaWYgKHNh
bSA9PSBudWxsIHx8ICFzYW0uaXNWYWxpZEJpbmRpbmcoKSkKKwkJCXJldHVybiBudWxsOworCQlU
eXBlQmluZGluZyB0eXBlID0gbnVsbDsKKwkJc2V0RXhwZWN0ZWRUeXBlKGxlZnQpOworCQlJRXJy
b3JIYW5kbGluZ1BvbGljeSBvbGRQb2xpY3kgPSB0aGlzLmVuY2xvc2luZ1Njb3BlLnByb2JsZW1S
ZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xpY3koc2lsZW50RXJyb3JIYW5kbGluZ1Bv
bGljeSk7CisJCXRyeSB7CisJCQl0aGlzLmJpbmRpbmcgPSBudWxsOworCQkJdHlwZSA9IHJlc29s
dmVUeXBlKHRoaXMuZW5jbG9zaW5nU2NvcGUpOworCQl9IGZpbmFsbHkgeworCQkJdGhpcy5lbmNs
b3NpbmdTY29wZS5wcm9ibGVtUmVwb3J0ZXIoKS5zd2l0Y2hFcnJvckhhbmRsaW5nUG9saWN5KG9s
ZFBvbGljeSk7CisJCQl0aGlzLmJpbmRpbmcgPSBudWxsOworCQkJc2V0RXhwZWN0ZWRUeXBlKG51
bGwpOworCQl9CisJCXJldHVybiB0eXBlOworCX0KKwkKIAlwdWJsaWMgVHlwZUJpbmRpbmcgcmVz
b2x2ZVR5cGUoQmxvY2tTY29wZSBzY29wZSkgewogCQkKIAkJZmluYWwgQ29tcGlsZXJPcHRpb25z
IGNvbXBpbGVyT3B0aW9ucyA9IHNjb3BlLmNvbXBpbGVyT3B0aW9ucygpOwpAQCAtNTgzLDI2ICs2
MDIsMTEgQEAKIAl9CiAKIAlwdWJsaWMgYm9vbGVhbiBpc0NvbXBhdGlibGVXaXRoKFR5cGVCaW5k
aW5nIGxlZnQsIFNjb3BlIHNjb3BlKSB7Ci0JCS8vIDE1LjI4LjIKLQkJZmluYWwgTWV0aG9kQmlu
ZGluZyBzYW0gPSBsZWZ0LmdldFNpbmdsZUFic3RyYWN0TWV0aG9kKHRoaXMuZW5jbG9zaW5nU2Nv
cGUpOwotCQlpZiAoc2FtID09IG51bGwgfHwgIXNhbS5pc1ZhbGlkQmluZGluZygpKQotCQkJcmV0
dXJuIGZhbHNlOwotCQlib29sZWFuIGlzQ29tcGF0aWJsZTsKLQkJc2V0RXhwZWN0ZWRUeXBlKGxl
ZnQpOwotCQlJRXJyb3JIYW5kbGluZ1BvbGljeSBvbGRQb2xpY3kgPSB0aGlzLmVuY2xvc2luZ1Nj
b3BlLnByb2JsZW1SZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xpY3koc2lsZW50RXJy
b3JIYW5kbGluZ1BvbGljeSk7Ci0JCXRyeSB7Ci0JCQl0aGlzLmJpbmRpbmcgPSBudWxsOwotCQkJ
cmVzb2x2ZVR5cGUodGhpcy5lbmNsb3NpbmdTY29wZSk7Ci0JCX0gZmluYWxseSB7Ci0JCQl0aGlz
LmVuY2xvc2luZ1Njb3BlLnByb2JsZW1SZXBvcnRlcigpLnN3aXRjaEVycm9ySGFuZGxpbmdQb2xp
Y3kob2xkUG9saWN5KTsKLQkJCWlzQ29tcGF0aWJsZSA9IHRoaXMuYmluZGluZyAhPSBudWxsICYm
IHRoaXMuYmluZGluZy5pc1ZhbGlkQmluZGluZygpOwotCQkJdGhpcy5iaW5kaW5nID0gbnVsbDsK
LQkJCXNldEV4cGVjdGVkVHlwZShudWxsKTsKLQkJfQotCQlyZXR1cm4gaXNDb21wYXRpYmxlOwor
CQlUeXBlQmluZGluZyB0eXBlID0gcmVzb2x2ZVR5cGVFeHBlY3RpbmcodGhpcy5lbmNsb3NpbmdT
Y29wZSwgbGVmdCk7CisJCXJldHVybiB0eXBlICE9IG51bGwgJiYgdHlwZS5pc1ZhbGlkQmluZGlu
ZygpOwogCX0KLQkKLQlwdWJsaWMgYm9vbGVhbiBzSXNNb3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcg
cywgVHlwZUJpbmRpbmcgdCkgeworCQkKKwlwdWJsaWMgYm9vbGVhbiBzSXNNb3JlU3BlY2lmaWMo
VHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcgdCwgU2NvcGUgc2NvcGUpIHsKIAkJCiAJCWlmIChU
eXBlQmluZGluZy5lcXVhbHNFcXVhbHMocywgdCkpCiAJCQlyZXR1cm4gdHJ1ZTsKZGlmZiAtLWdp
dCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5h
bC9jb21waWxlci9sb29rdXAvTG9va3VwRW52aXJvbm1lbnQuamF2YSBiL29yZy5lY2xpcHNlLmpk
dC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAv
TG9va3VwRW52aXJvbm1lbnQuamF2YQppbmRleCBlN2QyNmNhLi5lNDIzNzNmIDEwMDY0NAotLS0g
YS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwv
Y29tcGlsZXIvbG9va3VwL0xvb2t1cEVudmlyb25tZW50LmphdmEKKysrIGIvb3JnLmVjbGlwc2Uu
amR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1
cC9Mb29rdXBFbnZpcm9ubWVudC5qYXZhCkBAIC00MzEsNiArNDMxLDEwIEBACiAJCQkJY2FzZSBU
eXBlSWRzLlRfSmF2YUxhbmdMb25nIDoKIAkJCQkJcmV0dXJuIFR5cGVCaW5kaW5nLkxPTkc7CiAJ
CQl9CisJCQlicmVhazsKKwkJY2FzZSBCaW5kaW5nLlBPTFlfVFlQRToKKwkJCVBvbHlUeXBlQmlu
ZGluZyBwb2x5ID0gKFBvbHlUeXBlQmluZGluZykgdHlwZTsKKwkJCXJldHVybiBuZXcgUG9seVR5
cGVCaW5kaW5nKHBvbHkuZXhwcmVzc2lvbiwgdHJ1ZSk7CiAJfQogCXJldHVybiB0eXBlOwogfQpk
aWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0
L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9QYXJhbWV0ZXJpemVkR2VuZXJpY01ldGhvZEJpbmRp
bmcuamF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9p
bnRlcm5hbC9jb21waWxlci9sb29rdXAvUGFyYW1ldGVyaXplZEdlbmVyaWNNZXRob2RCaW5kaW5n
LmphdmEKaW5kZXggNmUwMTQxNC4uNzljMWVhMCAxMDA2NDQKLS0tIGEvb3JnLmVjbGlwc2UuamR0
LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9Q
YXJhbWV0ZXJpemVkR2VuZXJpY01ldGhvZEJpbmRpbmcuamF2YQorKysgYi9vcmcuZWNsaXBzZS5q
ZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3Vw
L1BhcmFtZXRlcml6ZWRHZW5lcmljTWV0aG9kQmluZGluZy5qYXZhCkBAIC0xNiw2ICsxNiw3IEBA
CiBwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5sb29rdXA7CiAKIGlt
cG9ydCBvcmcuZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIuYXN0LldpbGRjYXJkOworaW1w
b3J0IG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5jbGFzc2ZtdC5DbGFzc0ZpbGVD
b25zdGFudHM7CiAKIC8qKgogICogQmluZGluZyBkZW5vdGluZyBhIGdlbmVyaWMgbWV0aG9kIGFm
dGVyIHR5cGUgcGFyYW1ldGVyIHN1YnN0aXR1dGlvbnMgZ290IHBlcmZvcm1lZC4KQEAgLTY4LDYg
KzY5LDEyIEBACiAJCQkJfQogCQkJCWlmIChtZXRob2RTdWJzdGl0dXRlLnJldHVyblR5cGUgIT0g
VHlwZUJpbmRpbmcuVk9JRCkgewogCQkJCQlUeXBlQmluZGluZyBleHBlY3RlZFR5cGUgPSBpbnZv
Y2F0aW9uU2l0ZS5leHBlY3RlZFR5cGUoKTsKKwkJCQkJaWYgKGV4cGVjdGVkVHlwZSAhPSBudWxs
ICYmIGV4cGVjdGVkVHlwZS5raW5kKCkgPT0gQmluZGluZy5QT0xZX1RZUEUpIHsKKwkJCQkJCWlm
IChzY29wZS5jb21waWxlck9wdGlvbnMoKS5zb3VyY2VMZXZlbCA+PSBDbGFzc0ZpbGVDb25zdGFu
dHMuSkRLMV84KQorCQkJCQkJCXRocm93IG5ldyBQb2x5VHlwZUV4Y2VwdGlvbigpOworCQkJCQkJ
ZWxzZQorCQkJCQkJCWV4cGVjdGVkVHlwZSA9IG51bGw7CisJCQkJCX0KIAkJCQkJaWYgKGV4cGVj
dGVkVHlwZSAhPSBudWxsKSB7CiAJCQkJCQkvLyByZWNvcmQgaXQgd2FzIGV4cGxpY2l0IGZyb20g
Y29udGV4dCwgYXMgb3Bwb3NlZCB0byBhc3N1bWVkIGJ5IGRlZmF1bHQgKHNlZSBiZWxvdykKIAkJ
CQkJCWluZmVyZW5jZUNvbnRleHQuaGFzRXhwbGljaXRFeHBlY3RlZFR5cGUgPSB0cnVlOwpkaWZm
IC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2lu
dGVybmFsL2NvbXBpbGVyL2xvb2t1cC9Qb2x5VHlwZUJpbmRpbmcuamF2YSBiL29yZy5lY2xpcHNl
LmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29r
dXAvUG9seVR5cGVCaW5kaW5nLmphdmEKaW5kZXggNWI4MTUxMC4uYmY0ZjA2NyAxMDA2NDQKLS0t
IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFs
L2NvbXBpbGVyL2xvb2t1cC9Qb2x5VHlwZUJpbmRpbmcuamF2YQorKysgYi9vcmcuZWNsaXBzZS5q
ZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3Vw
L1BvbHlUeXBlQmluZGluZy5qYXZhCkBAIC0yMCwxMSArMjAsMTcgQEAKIHB1YmxpYyBjbGFzcyBQ
b2x5VHlwZUJpbmRpbmcgZXh0ZW5kcyBUeXBlQmluZGluZyB7CiAKIAlFeHByZXNzaW9uIGV4cHJl
c3Npb247CisJYm9vbGVhbiB2YW5pbGxhQ29tcGF0aWJpbHR5ID0gdHJ1ZTsKIAkKIAlwdWJsaWMg
UG9seVR5cGVCaW5kaW5nKEV4cHJlc3Npb24gZXhwcmVzc2lvbikgewogCQl0aGlzLmV4cHJlc3Np
b24gPSBleHByZXNzaW9uOwogCX0KIAkKKwlwdWJsaWMgUG9seVR5cGVCaW5kaW5nKEV4cHJlc3Np
b24gZXhwcmVzc2lvbiwgYm9vbGVhbiBjaGVja0F1dG9ib3hDb21wYXRpYml0eSkgeworCQl0aGlz
LmV4cHJlc3Npb24gPSBleHByZXNzaW9uOworCQl0aGlzLnZhbmlsbGFDb21wYXRpYmlsdHkgPSAh
Y2hlY2tBdXRvYm94Q29tcGF0aWJpdHk7CisJfQorCiAJcHVibGljIGNoYXJbXSBjb25zdGFudFBv
b2xOYW1lKCkgewogCQl0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oKTsg
IC8vIHNob3VsZCBuZXZlciByZWFjaCBjb2RlIGdlbmVyYXRpb24KIAl9CkBAIC0zNCw3ICs0MCw3
IEBACiAJfQogCiAJcHVibGljIGJvb2xlYW4gaXNDb21wYXRpYmxlV2l0aChUeXBlQmluZGluZyBs
ZWZ0LCBTY29wZSBzY29wZSkgewotCQlyZXR1cm4gdGhpcy5leHByZXNzaW9uLmlzQ29tcGF0aWJs
ZVdpdGgobGVmdCwgc2NvcGUpOworCQlyZXR1cm4gdGhpcy52YW5pbGxhQ29tcGF0aWJpbHR5ID8g
dGhpcy5leHByZXNzaW9uLmlzQ29tcGF0aWJsZVdpdGgobGVmdCwgc2NvcGUpIDogdGhpcy5leHBy
ZXNzaW9uLmlzQm94aW5nQ29tcGF0aWJsZVdpdGgobGVmdCwgc2NvcGUpOwogCX0KIAogCXB1Ymxp
YyBjaGFyW10gcXVhbGlmaWVkU291cmNlTmFtZSgpIHsKQEAgLTQ5LDggKzU1LDggQEAKIAkJcmV0
dXJuIHRoaXMuZXhwcmVzc2lvbi5wcmludEV4cHJlc3Npb24oMCwgIG5ldyBTdHJpbmdCdWZmZXIo
KSkudG9TdHJpbmcoKS50b0NoYXJBcnJheSgpOwogCX0KIAkKLQlwdWJsaWMgYm9vbGVhbiBzSXNN
b3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcgdCkgewotCQlyZXR1cm4gdGhp
cy5leHByZXNzaW9uLnNJc01vcmVTcGVjaWZpYyhzLCB0KTsKKwlwdWJsaWMgYm9vbGVhbiBzSXNN
b3JlU3BlY2lmaWMoVHlwZUJpbmRpbmcgcywgVHlwZUJpbmRpbmcgdCwgU2NvcGUgc2NvcGUpIHsK
KwkJcmV0dXJuIHRoaXMuZXhwcmVzc2lvbi5zSXNNb3JlU3BlY2lmaWMocywgdCwgc2NvcGUpOwog
CX0KIAkKIAlwdWJsaWMgU3RyaW5nIHRvU3RyaW5nKCkgewpkaWZmIC0tZ2l0IGEvb3JnLmVjbGlw
c2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xv
b2t1cC9Qb2x5VHlwZUV4Y2VwdGlvbi5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGls
ZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9Qb2x5VHlwZUV4Y2Vw
dGlvbi5qYXZhCm5ldyBmaWxlIG1vZGUgMTAwNjQ0CmluZGV4IDAwMDAwMDAuLjhjMTdiMzUKLS0t
IC9kZXYvbnVsbAorKysgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBz
ZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1BvbHlUeXBlRXhjZXB0aW9uLmphdmEKQEAg
LTAsMCArMSw1IEBACitwYWNrYWdlIG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5s
b29rdXA7CisKK3B1YmxpYyBjbGFzcyBQb2x5VHlwZUV4Y2VwdGlvbiBleHRlbmRzIFJ1bnRpbWVF
eGNlcHRpb24geworCXByaXZhdGUgc3RhdGljIGZpbmFsIGxvbmcgc2VyaWFsVmVyc2lvblVJRCA9
IC0xNjgxMzE1MzU5Mjg2OTM3NDdMOworfQpkaWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNv
cmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBpbGVyL2xvb2t1cC9TY29w
ZS5qYXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2lu
dGVybmFsL2NvbXBpbGVyL2xvb2t1cC9TY29wZS5qYXZhCmluZGV4IGY2ZWJjMTMuLjI4NjcxNzIg
MTAwNjQ0Ci0tLSBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pk
dC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAvU2NvcGUuamF2YQorKysgYi9vcmcuZWNsaXBzZS5q
ZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBzZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3Vw
L1Njb3BlLmphdmEKQEAgLTMyODcsNyArMzI4Nyw3IEBACiAKIAkJLy8gY2hlY2sgaWYgYXV0b2Jv
eGVkIHR5cGUgaXMgY29tcGF0aWJsZQogCQlUeXBlQmluZGluZyBjb252ZXJ0ZWRUeXBlID0gZW52
aXJvbm1lbnQuY29tcHV0ZUJveGluZ1R5cGUoZXhwcmVzc2lvblR5cGUpOwotCQlyZXR1cm4gVHlw
ZUJpbmRpbmcuZXF1YWxzRXF1YWxzKGNvbnZlcnRlZFR5cGUsIHRhcmdldFR5cGUpIHx8IGNvbnZl
cnRlZFR5cGUuaXNDb21wYXRpYmxlV2l0aCh0YXJnZXRUeXBlKTsKKwkJcmV0dXJuIFR5cGVCaW5k
aW5nLmVxdWFsc0VxdWFscyhjb252ZXJ0ZWRUeXBlLCB0YXJnZXRUeXBlKSB8fCBjb252ZXJ0ZWRU
eXBlLmlzQ29tcGF0aWJsZVdpdGgodGFyZ2V0VHlwZSwgdGhpcyk7CiAJfQogCiAJLyogQW5zd2Vy
IHRydWUgaWYgdGhlIHNjb3BlIGlzIG5lc3RlZCBpbnNpZGUgYSBnaXZlbiBmaWVsZCBkZWNsYXJh
dGlvbi4KQEAgLTQwNjYsNyArNDA2Niw3IEBACiAJCQkJCQlUeXBlQmluZGluZyB0ID0gaSA8IG1i
a1BhcmFtZXRlcnNMZW5ndGggPyBtYmtQYXJhbWV0ZXJzW2ldIDogbWJrUGFyYW1ldGVyc1ttYmtQ
YXJhbWV0ZXJzTGVuZ3RoIC0gMV07CiAJCQkJCQlpZiAoVHlwZUJpbmRpbmcuZXF1YWxzRXF1YWxz
KHMsIHQpKQogCQkJCQkJCWNvbnRpbnVlOwotCQkJCQkJaWYgKCFhcmd1bWVudFR5cGUuc0lzTW9y
ZVNwZWNpZmljKHMsdCkpIHsgCisJCQkJCQlpZiAoIWFyZ3VtZW50VHlwZS5zSXNNb3JlU3BlY2lm
aWMocyx0LCB0aGlzKSkgeyAKIAkJCQkJCQlzSXNNb3JlU3BlY2lmaWMgPSBmYWxzZTsKIAkJCQkJ
CQlicmVhazsKIAkJCQkJCX0KQEAgLTQ0NDUsNyArNDQ0NSw3IEBACiAJCX0KIAkJaWYgKGFyZy5p
c0Jhc2VUeXBlKCkgIT0gcGFyYW0uaXNCYXNlVHlwZSgpKSB7CiAJCQlUeXBlQmluZGluZyBjb252
ZXJ0ZWRUeXBlID0gZW52LmNvbXB1dGVCb3hpbmdUeXBlKGFyZyk7Ci0JCQlpZiAoVHlwZUJpbmRp
bmcuZXF1YWxzRXF1YWxzKGNvbnZlcnRlZFR5cGUsIHBhcmFtKSB8fCBjb252ZXJ0ZWRUeXBlLmlz
Q29tcGF0aWJsZVdpdGgocGFyYW0pKQorCQkJaWYgKFR5cGVCaW5kaW5nLmVxdWFsc0VxdWFscyhj
b252ZXJ0ZWRUeXBlLCBwYXJhbSkgfHwgY29udmVydGVkVHlwZS5pc0NvbXBhdGlibGVXaXRoKHBh
cmFtLCB0aGlzKSkKIAkJCQlyZXR1cm4gQVVUT0JPWF9DT01QQVRJQkxFOwogCQl9CiAJCXJldHVy
biBOT1RfQ09NUEFUSUJMRTsKZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBp
bGVyL29yZy9lY2xpcHNlL2pkdC9pbnRlcm5hbC9jb21waWxlci9sb29rdXAvVHlwZUJpbmRpbmcu
amF2YSBiL29yZy5lY2xpcHNlLmpkdC5jb3JlL2NvbXBpbGVyL29yZy9lY2xpcHNlL2pkdC9pbnRl
cm5hbC9jb21waWxlci9sb29rdXAvVHlwZUJpbmRpbmcuamF2YQppbmRleCA1NTVkMzM1Li45ZDFh
NWU5IDEwMDY0NAotLS0gYS9vcmcuZWNsaXBzZS5qZHQuY29yZS9jb21waWxlci9vcmcvZWNsaXBz
ZS9qZHQvaW50ZXJuYWwvY29tcGlsZXIvbG9va3VwL1R5cGVCaW5kaW5nLmphdmEKKysrIGIvb3Jn
LmVjbGlwc2UuamR0LmNvcmUvY29tcGlsZXIvb3JnL2VjbGlwc2UvamR0L2ludGVybmFsL2NvbXBp
bGVyL2xvb2t1cC9UeXBlQmluZGluZy5qYXZhCkBAIC0xNDQ4LDcgKzE0NDgsNyBAQAogCXJldHVy
biBmYWxzZTsKIH0KIAotcHVibGljIGJvb2xlYW4gc0lzTW9yZVNwZWNpZmljKFR5cGVCaW5kaW5n
IHMsIFR5cGVCaW5kaW5nIHQpIHsKK3B1YmxpYyBib29sZWFuIHNJc01vcmVTcGVjaWZpYyhUeXBl
QmluZGluZyBzLCBUeXBlQmluZGluZyB0LCBTY29wZSBzY29wZSkgewogCXRocm93IG5ldyBVbnN1
cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbigiYWJzdHJhY3QgdmlydHVhbCBtZXRob2QgY2FsbGVk
Iik7IC8vJE5PTi1OTFMtMSQKIH0KIA==
</data>

          </attachment>
      

    </bug>

</bugzilla>