<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>429203</bug_id>
          
          <creation_ts>2014-02-26 21:23:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] NPE in AllocationExpression.binding</short_desc>
          <delta_ts>2014-03-07 07:30:21 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>manpalat</cc>
    
    <cc>shankhba</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2369106</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-26 21:23:40 -0500</bug_when>
    <thetext>I ran into this when I hovered on something in JRE sources: Don&apos;t quite know
what, but it should be easy to make progress without it.

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.binding(AllocationExpression.java:720)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.acceptPendingPolyArguments(InferenceContext18.java:1468)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1412)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1397)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:553)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5101)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:5023)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:581)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:627)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:550)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:490)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:605)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.resolve(ReturnStatement.java:334)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:591)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:829)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:622)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:740)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:692)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:96)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getMethodOverrideTester(SuperTypeHierarchyCache.java:105)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:171)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.computeAdornmentFlags(OverrideIndicatorLabelDecorator.java:136)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.decorate(OverrideIndicatorLabelDecorator.java:273)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorDefinition.decorate(LightweightDecoratorDefinition.java:269)
	at org.eclipse.ui.internal.decorators.LightweightDecoratorManager$LightweightRunnable.run(LightweightDecoratorManager.java:81)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2369107</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-26 21:33:23 -0500</bug_when>
    <thetext>Check the frame:
org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:627)

I had this option on in my IDE. This may be necessary for reproduction.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2370035</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-28 17:58:58 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #0)
&gt; I ran into this when I hovered on something in JRE sources: Don&apos;t quite know
&gt; what, but it should be easy to make progress without it.

The necessity for a null guard for that line is obvious. Since I didn&apos;t succeed to reproduce while toying around in my JRE8 project, I released the tiny fix on its own via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=4ed4929f5a19426d0e76e817c895cfe42549d282

After another close look at the stack trace it indeed gave enough clues to create a reproducing test. With just the null check, we would now report the same error twice (because we cannot set the flag that helps avoid this). Assuming we only get here if s.t. is broken anyway I also suppress the (duplicate) error. Test &amp; fix released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=5b6ed239ab2debdfdceff08624ed7d37a463daed

Thanks for catching this</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372814</commentid>
    <comment_count>3</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-03-07 01:54:50 -0500</bug_when>
    <thetext>import java.util.function.Function;


public class DTest&lt;T&gt; {
 public DTest(Function&lt;T, T&gt; func) { }
 
 public DTest(DTest&lt;Integer&gt; dti) {}
 
 public static void main(String[] args) {
 DTest&lt;String&gt; t1 = new DTest&lt;String&gt;(new DTest&lt;Integer&gt;());
 }
}

Switch on the error:

org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=error



Do see the stack trace without the fix:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.binding(AllocationExpression.java:720)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.acceptPendingPolyArguments(InferenceContext18.java:1468)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1412)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.rebindInnerPolies(InferenceContext18.java:1397)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.inferInvocationType(InferenceContext18.java:553)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.inferInvocationType(Scope.java:5101)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getStaticFactory(Scope.java:5023)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.inferElidedTypes(AllocationExpression.java:581)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.checkTypeArgumentRedundancy(AllocationExpression.java:627)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolvePart3(AllocationExpression.java:550)
	at org.eclipse.jdt.internal.compiler.ast.AllocationExpression.resolveType(AllocationExpression.java:490)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:251)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:623)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:533)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:575)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1208)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:693)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1187)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:813)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:548)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:541)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:484)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372822</commentid>
    <comment_count>4</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-03-07 02:25:43 -0500</bug_when>
    <thetext>The error is resolved with the fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372823</commentid>
    <comment_count>5</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-03-07 02:26:31 -0500</bug_when>
    <thetext>Verified as working for Eclipse + Java 8 RC2 using Kepler SR2 +   
Eclipse Java Development Tools Patch for Java 8 Support (BETA) 
1.0.0.v20140306-1935</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>