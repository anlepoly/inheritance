<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>425897</bug_id>
          
          <creation_ts>2014-01-16 09:20:00 -0500</creation_ts>
          <short_desc>[1.8] unexpected capture incompatibility at method reference</short_desc>
          <delta_ts>2014-02-21 04:12:31 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.3.1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Stephan Herrmann">stephan.herrmann</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>manpalat</cc>
    
    <cc>srikanth_sankaran</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2350605</commentid>
    <comment_count>0</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-16 09:20:50 -0500</bug_when>
    <thetext>The test GTT_1_8.testBug425798() currently witnesses a wrong outcome:

The example should be accepted whereas we report:
The type of annotationType() from the type Annotation is Class&lt;? extends Annotation&gt;, this is incompatible with the descriptor&apos;s return type: Class&lt;capture#3-of ? extends Annotation&gt;

Not marking as inference-related, because the error is reported in the regular part of RE.resolveType().</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2360755</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-10 00:31:21 -0500</bug_when>
    <thetext>The parameterized functional interface interface type gets created here:

ParameterizedTypeBinding.&lt;init&gt;(ReferenceBinding, TypeBinding[], ReferenceBinding, LookupEnvironment) line: 70	
TypeSystem.getParameterizedType(ReferenceBinding, TypeBinding[], ReferenceBinding) line: 166	
LookupEnvironment.createParameterizedType(ReferenceBinding, TypeBinding[], ReferenceBinding) line: 942	
ParameterizedTypeBinding.substituteInferenceVariable(InferenceVariable, TypeBinding) line: 842	
ConstraintExceptionFormula(ConstraintFormula).applySubstitution(BoundSet, InferenceVariable[]) line: 73	
ConstraintExceptionFormula.applySubstitution(BoundSet, InferenceVariable[]) line: 1	
InferenceContext18.inferInvocationType(BoundSet, TypeBinding, InvocationSite, MethodBinding) line: 427	
InferenceContext18.inferInvocationType(Invocation, TypeBinding[], ParameterizedGenericMethodBinding) line: 525	
MethodScope(Scope).inferInvocationType(InvocationSite, MethodBinding, TypeBinding[]) line: 5074	
MethodScope(Scope).findDefaultAbstractMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, ReferenceBinding, ObjectVector, MethodBinding) line: 1268	
MethodScope(Scope).findMethod0(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1854	
MethodScope(Scope).findMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1633	
MethodScope(Scope).getMethod(TypeBinding, char[], TypeBinding[], InvocationSite) line: 2893	


and passed as the final target type here:

ReferenceExpression(FunctionalExpression).checkAgainstFinalTargetType(TypeBinding) line: 184	
ASTNode.resolvePolyExpressionArguments(Invocation, MethodBinding, TypeBinding[]) line: 736	
ASTNode.resolvePolyExpressionArguments(Invocation, MethodBinding) line: 760	
InferenceContext18.rebindInnerPolies(BoundSet, TypeBinding[]) line: 1365	
InferenceContext18.rebindInnerPolies(MethodBinding, InvocationSite) line: 1314	
InferenceContext18.inferInvocationType(Invocation, TypeBinding[], ParameterizedGenericMethodBinding) line: 552	
MethodScope(Scope).inferInvocationType(InvocationSite, MethodBinding, TypeBinding[]) line: 5074	
MethodScope(Scope).findDefaultAbstractMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, ReferenceBinding, ObjectVector, MethodBinding) line: 1268	
MethodScope(Scope).findMethod0(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1854	
MethodScope(Scope).findMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1633	
MethodScope(Scope).getMethod(TypeBinding, char[], TypeBinding[], InvocationSite) line: 2893	


Descriptor types should not contain captures as any wildcard there constitute
only declarations and not usages. I can believe these captures arise during
intermediate steps. But a functional poly expression must be exposed to a
target type devoid of captures. The resulting expression with the functional
interface type plugged in could have captures.

I don&apos;t know of a ready way of going from parameterized types with captures&apos;back to original wildcard. Perhaps TypeBindingVisitor could come in handy here ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2360759</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-10 00:46:02 -0500</bug_when>
    <thetext>Unrelated: we are also missing this piece of code:

      
        if (!this.haveReceiver &amp;&amp; !this.lhs.isSuper())
        	this.receiverType = this.receiverType.capture(scope, this.sourceEnd);
        	
  
just above:

       final boolean isMethodReference = isMethodReference();
        this.depth = 0;
        MethodBinding someMethod = isMethodReference ? scope.getMethod(this.receiverType, this.selector, descriptorParameters, this) :
        											       scope.getConstructor((ReferenceBinding) this.receiverType, descriptorParameters, this);

From 15.28.1:

If the method reference has the form ReferenceType :: NonWildTypeArgumentsopt 
Identifier, the type to search is the result of capture conversion (5.1.10) 
applied to the ReferenceType</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2361443</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-11 05:24:22 -0500</bug_when>
    <thetext>I think this is the same problem as https://bugs.eclipse.org/bugs/show_bug.cgi?id=426984.

I ma prototyping a fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2361455</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-11 05:43:58 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #3)
&gt; I ma prototyping a fix.

Cool!

Feel free to pass back to me if type inference is found to cause grief ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2361503</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-11 07:48:06 -0500</bug_when>
    <thetext>Combined fix and tests for bug 425897 and bug 426984 released here:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=fbb76f52a30ee20f3d4a3f2f5f9a3d507821f378

Basically, it does not make sense for the target type of a poly expression
to contain wildcard captures. Only argument expressions can have captures,
parameter types cannot.

I invented a new IPI: TypeBinding.uncapture(Scope) for this purpose.

While the present fix addresses these two bugs, I actually think we need a
broader fix that addresses all poly expressions and overload resolution scenario.

I believe is is wrong for org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.getParameter(TypeBinding[], int, boolean) to return any captured types.

I will shorly try to construct some test cases where this could interfere
with overload resolution and if that claim proves true, will raise follow
up defects to address the broader issue. However the infrastructure to
solve the more general problem is already a part of this fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2366564</commentid>
    <comment_count>6</comment_count>
    <who name="Manoj Palat Away Until May 11 2015">manpalat</who>
    <bug_when>2014-02-21 04:12:31 -0500</bug_when>
    <thetext>Verified as working for Eclipse + Java 8 RC1 using Kepler SR2(RC4) +   
Eclipse Java Development Tools Patch for Java 8 Support (BETA)   
1.0.0.v20140220-2054

[A minor observation: test is GRT_1.8_testBug45798 and not from GTT]</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>