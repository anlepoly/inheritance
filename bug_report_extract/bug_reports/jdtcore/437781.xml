<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>437781</bug_id>
          
          <creation_ts>2014-06-19 16:18:00 -0400</creation_ts>
          <short_desc>[1.8][compiler] Eclipse accepts code rejected by javac because of ambiguous method reference</short_desc>
          <delta_ts>2014-11-23 12:33:06 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M2</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Tobias Gierke">tobias.gierke</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>manpalat</cc>
    
    <cc>shankhba</cc>
    
    <cc>stephan.herrmann</cc>
    
    <cc>tobias.gierke</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2418625</commentid>
    <comment_count>0</comment_count>
    <who name="Tobias Gierke">tobias.gierke</who>
    <bug_when>2014-06-19 16:18:04 -0400</bug_when>
    <thetext>Code below fails to compile with JDK 1.8u5 and JDK1.8u20 (early access).

CODE:

import java.util.function.Consumer;
import java.util.function.Function;

public class Test {
	
	public void test() {
		visit( System.out::println );
	}

	public boolean visit(Function&lt;Integer, Boolean&gt; func) {
		return true;
	}
	
	public void visit(Consumer&lt;Integer&gt; func) 
	{
	}	
}

JAVAC ERRORS:

Test.java:9: error: reference to visit is ambiguous
                visit( System.out::println );
                ^
  both method visit(Function&lt;Integer,Boolean&gt;) in Test and method visit(Consumer&lt;Integer&gt;) in Test match
Test.java:9: error: incompatible types: bad return type in method reference
                visit( System.out::println );
                       ^
    void cannot be converted to Boolean</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2418626</commentid>
    <comment_count>1</comment_count>
    <who name="Tobias Gierke">tobias.gierke</who>
    <bug_when>2014-06-19 16:18:45 -0400</bug_when>
    <thetext>This is with Eclipse 4.4 I20140606-1215</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2418640</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-06-19 17:11:02 -0400</bug_when>
    <thetext>Hm, is javac saying, both methods &quot;visit&quot; are applicable. And as a second error report, that one of the methods doesn&apos;t match?

Sounds &quot;weird&quot;. Maybe easier to file a bug against Oracle and let them justify their behavior, rather than us reading the tea leaves about this?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2418681</commentid>
    <comment_count>3</comment_count>
    <who name="Tobias Gierke">tobias.gierke</who>
    <bug_when>2014-06-20 02:36:58 -0400</bug_when>
    <thetext>Being mostly clueless about the JLS I might be totally wrong but isn&apos;t this one of the cases that Oracle intentionally decided not to support (http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-August/000340.html) ?

If I rewrite the test() method to

	public void test() {
		visit( value -&gt; { System.out.println(value);} );
	}

both Eclipse and javac complain about ambiguity. According to the discussion on lambda-spec-experts it seems they decided to

&quot;Overload resolution will only check the arity of all implicit lambdas and will ignore overloaded method references.  If the body of a lambda is important for disambiguation, it must have explicit parameter types.&quot;

And in fact, adding explicit parameter types to the lambda expressions like so

	public void test() {
		visit( (Integer value) -&gt; { System.out.println(value);} );
	}

fixes the ambiguity error in both Eclipse and javac.

So I *think* this is a JDT issue and javac is &quot;correct&quot; (although I&apos;d much rather have javac behave like JDT in this case ;)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2435421</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-08-05 01:52:13 -0400</bug_when>
    <thetext>Retargetting to M2, as I don&apos;t expect to finish work on these before this week&apos;s build(s)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2449641</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-10 05:16:39 -0400</bug_when>
    <thetext>Let us consider the overload candidate 
Test.visit(Function&lt;Integer, Boolean&gt; func):

// ---

&quot;15.13.2 Type of a Method Reference

A method reference expression is compatible in an assignment context, 
invocation context, or casting context with a target type T if T is a functional
interface type (9.8) and the expression is congruent with the function type 
of the ground target type derived from T.

The ground target type is derived from T as follows:
 If T is a wildcard-parameterized functional interface type, then the 
ground target type is the non-wildcard parameterization (9.9) of T.
 Otherwise, the ground target type is T.&quot;

// --

Here, the ground target type is simply Function&lt;Integer, Boolean&gt;, since there
is no wildcard parameterization in the picture and the function type is
Boolean Function&lt;Integer, Boolean&gt;.apply(Integer)


// --
&quot;A method reference expression is congruent with a function type if both of the
following are true:

 The function type identifies a single compile-time declaration 
corresponding to the reference.
 One of the following is true:
     The result of the function type is void.
     The result of the function type is R, and the result of applying 
capture conversion (5.1.10) to the return type of the invocation type 
(15.12.2.6) of the chosen compile-time declaration is R&apos; (where R is the 
target type that may be used to infer R&apos;), and neither R nor R&apos; is void, 
and R&apos; is compatible with R in an assignment context.&quot;

// --

The assertion neither R(Boolean) nor R&apos;(void) is void is false 

  =&gt; method reference expression is not congruent with the function type 
  =&gt; method reference expression is not compatible in the given invocation 
     context.

That leaves us with only Test.visit(Consumer&lt;Integer&gt; func) which we find
to be compatible. 

Hence the claim of ambiguity is unwarranted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2449644</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-10 05:22:26 -0400</bug_when>
    <thetext>(In reply to Tobias Gierke from comment #3)

&gt; If I rewrite the test() method to
&gt; 
&gt; 	public void test() {
&gt; 		visit( value -&gt; { System.out.println(value);} );
&gt; 	}
&gt; 
&gt; both Eclipse and javac complain about ambiguity.

This is no longer true. I think the behavior you report is due to https://bugs.eclipse.org/bugs/show_bug.cgi?id=422810 and its javac
equivalent bug https://bugs.openjdk.java.net/browse/JDK-8029718

Both are fixed and 8u20 and Eclipse M2 HEAD compile the above without
any report of ambiguity.

&gt; So I *think* this is a JDT issue and javac is &quot;correct&quot; (although I&apos;d much
&gt; rather have javac behave like JDT in this case ;)

You may want to report this issue against javac.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2449646</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-10 05:28:37 -0400</bug_when>
    <thetext>Regression test released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=1eb6bd6c48dc30d619c844f566bc91d82ea53ea6</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2452464</commentid>
    <comment_count>8</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-09-16 09:22:22 -0400</bug_when>
    <thetext>Verified for Mars 4.5M2 using I20140915-2000 build.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2475790</commentid>
    <comment_count>9</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-11-03 09:55:19 -0500</bug_when>
    <thetext>Hmm. My impending changes to https://bugs.eclipse.org/bugs/show_bug.cgi?id=448954 align us with javac 8u20 behavior - Let us see.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2487650</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-11-23 12:33:06 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #9)
&gt; Hmm. My impending changes to
&gt; https://bugs.eclipse.org/bugs/show_bug.cgi?id=448954 align us with javac
&gt; 8u20 behavior - Let us see.

For posterity: ecj behavior has not changed in this regard.
Luna versions and Mars milestones and HEAD, all accept the program in comment 0.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>