<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>430027</bug_id>
          
          <creation_ts>2014-03-10 12:46:00 -0400</creation_ts>
          <short_desc>[1.8][model] Mitigate issues due to Lambda model element hierarchy lacking support for binary elements.</short_desc>
          <delta_ts>2014-04-22 13:12:26 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Markus Keller">markus_keller</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>srikanth_sankaran</cc>
          
          <votes>0</votes>

      

      

      <flag name="review"
          id="61861"
          type_id="1"
          status="+"
          setter="jarthana"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2373939</commentid>
    <comment_count>0</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2014-03-10 12:46:13 -0400</bug_when>
    <thetext>- select java.util.function.Function#apply(T)
- Search &gt; References &gt; In Hierarchy
-&gt; NPE

AFAICS, the problem happens with the lambda in java.util.function.Function#compose(..). The LambdaExpression extends SourceType, although that lambda is actually for a binary type. Therefore, the implementation in SourceType#getPrimaryElement(boolean) doesn&apos;t make sense.

!ENTRY org.eclipse.core.jobs 4 2 2014-03-10 17:20:42.837
!MESSAGE An internal error occurred during: &quot;Java Search&quot;.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.SourceType.getPrimaryElement(SourceType.java:445)
	at org.eclipse.jdt.internal.core.JavaElement.getPrimaryElement(JavaElement.java:359)
	at org.eclipse.jdt.internal.core.search.HierarchyScope.enclosesType(HierarchyScope.java:391)
	at org.eclipse.jdt.internal.core.search.HierarchyScope.encloses(HierarchyScope.java:356)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.encloses(MatchLocator.java:775)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2230)
	at org.eclipse.jdt.internal.core.search.matching.MemberDeclarationVisitor.visit(MemberDeclarationVisitor.java:216)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.traverse(LambdaExpression.java:636)
	at org.eclipse.jdt.internal.compiler.ast.ReturnStatement.traverse(ReturnStatement.java:376)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:351)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2304)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2858)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.reportMatching(MatchLocator.java:2572)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.process(MatchLocator.java:1755)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1164)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1205)
	at org.eclipse.jdt.internal.core.search.matching.MatchLocator.locateMatches(MatchLocator.java:1337)
	at org.eclipse.jdt.internal.core.search.JavaSearchParticipant.locateMatches(JavaSearchParticipant.java:122)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.findMatches(BasicSearchEngine.java:232)
	at org.eclipse.jdt.internal.core.search.BasicSearchEngine.search(BasicSearchEngine.java:516)
	at org.eclipse.jdt.core.search.SearchEngine.search(SearchEngine.java:584)
	at org.eclipse.jdt.internal.ui.search.JavaSearchQuery.run(JavaSearchQuery.java:144)
	at org.eclipse.search2.internal.ui.InternalSearchUI$InternalSearchJob.run(InternalSearchUI.java:91)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2373943</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-10 12:49:25 -0400</bug_when>
    <thetext>Thanks Markus. I&apos;ll follow up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2373945</commentid>
    <comment_count>2</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2014-03-10 12:55:21 -0400</bug_when>
    <thetext>For binary types, the problem from bug 430026 shows up no matter if the lambda parameter does or doesn&apos;t declare the type.

Example in java.util.function.IntPredicate:

    default IntPredicate and(IntPredicate other) {
        Objects.requireNonNull(other);
        return (value) -&gt; test(value) &amp;&amp; other.test(value);
    }</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2373975</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-10 13:58:30 -0400</bug_when>
    <thetext>(In reply to Markus Keller from comment #2)
&gt; For binary types, the problem from bug 430026 shows up no matter if the
&gt; lambda parameter does or doesn&apos;t declare the type.
&gt; 
&gt; Example in java.util.function.IntPredicate:
&gt; 
&gt;     default IntPredicate and(IntPredicate other) {
&gt;         Objects.requireNonNull(other);
&gt;         return (value) -&gt; test(value) &amp;&amp; other.test(value);
&gt;     }

The piece of code that fabricates and inserts lambdas at the right places
is guarded by 

if (binding.declaringScope.isLambdaSubscope() &amp;&amp; unit instanceof ICompilationUnit) {

where ICompilationUnit is org.eclipse.jdt.core.ICompilationUnit

and BasicCompilationUnit which is what I see in the case of binary files
does not implement this interface. Investigating.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2373982</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-10 14:06:53 -0400</bug_when>
    <thetext>(In reply to Markus Keller from comment #2)
&gt; For binary types, the problem from bug 430026 shows up no matter if the
&gt; lambda parameter does or doesn&apos;t declare the type.
&gt; 

This being a separate issue, I created https://bugs.eclipse.org/bugs/show_bug.cgi?id=430033</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2373991</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-10 14:32:50 -0400</bug_when>
    <thetext>Search in workspace produces:

java.lang.NullPointerException
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyResolver.resolve(HierarchyResolver.java:622)
	at org.eclipse.jdt.internal.core.hierarchy.HierarchyBuilder.buildSupertypes(HierarchyBuilder.java:116)
	at org.eclipse.jdt.internal.core.hierarchy.IndexBasedHierarchyBuilder.build(IndexBasedHierarchyBuilder.java:136)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.compute(TypeHierarchy.java:301)
	at org.eclipse.jdt.internal.core.hierarchy.TypeHierarchy.refresh(TypeHierarchy.java:1268)
	at org.eclipse.jdt.internal.core.CreateTypeHierarchyOperation.executeOperation(CreateTypeHierarchyOperation.java:90)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:729)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:789)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:741)
	at org.eclipse.jdt.internal.core.SourceType.newSupertypeHierarchy(SourceType.java:693)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:144)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getTypeHierarchy(SuperTypeHierarchyCache.java:96)
	at org.eclipse.jdt.internal.corext.util.SuperTypeHierarchyCache.getMethodOverrideTester(SuperTypeHierarchyCache.java:105)
	at org.eclipse.jdt.ui.OverrideIndicatorLabelDecorator.getOverrideIndicators(OverrideIndicatorLabelDecorator.java:171)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2374205</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-11 05:18:29 -0400</bug_when>
    <thetext>(In reply to Markus Keller from comment #0)
&gt; - select java.util.function.Function#apply(T)
&gt; - Search &gt; References &gt; In Hierarchy
&gt; -&gt; NPE
&gt; 
&gt; AFAICS, the problem happens with the lambda in
&gt; java.util.function.Function#compose(..). The LambdaExpression extends
&gt; SourceType, although that lambda is actually for a binary type. Therefore,
&gt; the implementation in SourceType#getPrimaryElement(boolean) doesn&apos;t make
&gt; sense.

Thanks for catching this - The hierarchy needs rewiring either in the form
of (a) a separate BinaryLambdaExpresssion and BinaryLambdaMethod or (b)
yanking these from under Source[Type|Method] and placing them directly
under I[Type|Method]. 

I am raising a separate defect for this topic to be taken up post GA and
use the present one for merely mitigating the ill effects of the present
solution.

It is too late now to undertake hierarchy changes - Given the original request
for model support came in a bit late in the game (https://bugs.eclipse.org/bugs/show_bug.cgi?id=425134, Jan 8th 2014), this
middle course is the safe strategy for now.

I released fixes for 
   
    - NPE reported in comment#0
    - NPE reported in comment#5 plus
    - a fix to obtaining handle from memento

here: 

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=802c7ac625f347675c393d0da79bae0fe10a00fd

I&apos;ll leave this bug open - any other issues found whose root cause
is lambda model elements enclosed by binary elements - let us use
this bug. Thanks for continued testing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2374711</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-12 03:29:29 -0400</bug_when>
    <thetext>Please reopen if additional symptoms are discovered. Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2391097</commentid>
    <comment_count>8</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-04-22 01:43:29 -0400</bug_when>
    <thetext>(In reply to Markus Keller from comment #0)
&gt; AFAICS, the problem happens with the lambda in
&gt; java.util.function.Function#compose(..). The LambdaExpression extends
&gt; SourceType, although that lambda is actually for a binary type. Therefore,
&gt; the implementation in SourceType#getPrimaryElement(boolean) doesn&apos;t make
&gt; sense.

From IJavaElement, I see only getPrimaryElement() and getAttachedJavadoc() to be having special/specific requirement for binary elements. In this case, it&apos;s probably not worth two different hierarchies. I am thinking we could just let the BinaryLambdaExpression simply extend the LambdaExpression to implement those two methods. In fact, at the moment, we can simply inherit the getAttachedJavadoc() from the source type or source method.

There is a similar bug in LambdaMethod - an NPE is thrown when trying to view lambda from ASTView. We need similar bifurcation for lambda method too.

I will post a patch along this line tune shortly.

Note: I don&apos;t yet know what to do with ResolvedLambdaExpression!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2391513</commentid>
    <comment_count>9</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2014-04-22 13:12:26 -0400</bug_when>
    <thetext>(In reply to Jayaprakash Arthanareeswaran from comment #8)
Follow-up on that is bug 430073.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>