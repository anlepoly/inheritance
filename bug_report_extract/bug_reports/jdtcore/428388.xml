<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>428388</bug_id>
          
          <creation_ts>2014-02-17 22:12:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Casting to primitives is over tolerant - probable regression since bug 428274</short_desc>
          <delta_ts>2014-02-24 17:46:30 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>jarthana</cc>
    
    <cc>manju656</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2364629</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-17 22:12:23 -0500</bug_when>
    <thetext>We have started accepting the following:

// --
public class X {
    public static void main(String[] args) {
	int x = (int) &quot;Hello&quot;;
    }
}


probably due to the fix for https://bugs.eclipse.org/bugs/show_bug.cgi?id=428274
being too permissive - certain provably impossible false are not rejected.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2364630</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-17 22:12:51 -0500</bug_when>
    <thetext>I&apos;ll follow up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2364672</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-18 03:51:10 -0500</bug_when>
    <thetext>At first reading I found no restrictions applicable from the list in 5.5 that says &quot;The compile-time legality of a casting conversion is as follows&quot; - assuming we interpret the above as a cast to int.

Perhaps, however, we should handle it as the (int)(Integer)x series which is implied, right? And then String-&gt;Integer cast should be recognized as impossible. Should&apos;ve thought about that, sorry.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2364995</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-18 12:56:49 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #2)

&gt; Perhaps, however, we should handle it as the (int)(Integer)x series which is
&gt; implied, right? And then String-&gt;Integer cast should be recognized as
&gt; impossible.

Right, there must be seen to exist the chain of a narrowing reference conversion
following by a unboxing conversion.

I am mildly worried about the changes I see in the patch here:
https://bugs.eclipse.org/bugs/attachment.cgi?id=200548 released on
behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=353085

regarding direct encoding of jlO.

Can you think of what if anything would cause problems ? 

Fix and tests released here: 
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=8cb3365a924e5869d5c8a5715a80d4cd8189b243</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365127</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-18 15:47:05 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #3)
&gt; (In reply to Stephan Herrmann from comment #2)
&gt; 
&gt; &gt; Perhaps, however, we should handle it as the (int)(Integer)x series which is
&gt; &gt; implied, right? And then String-&gt;Integer cast should be recognized as
&gt; &gt; impossible.
&gt; 
&gt; Right, there must be seen to exist the chain of a narrowing reference
&gt; conversion
&gt; following by a unboxing conversion.
&gt; 
&gt; I am mildly worried about the changes I see in the patch here:
&gt; https://bugs.eclipse.org/bugs/attachment.cgi?id=200548 released on
&gt; behalf of https://bugs.eclipse.org/bugs/show_bug.cgi?id=353085
&gt; 
&gt; regarding direct encoding of jlO.

Well, part of that has been removed via the previous bug :)

I assume you mean the part about the special conversions in CodeStream &amp; TypeIds for jlO-&gt;primitive?

 
&gt; Can you think of what if anything would cause problems ? 

First off, I&apos;m surprised to see that the conversion for (double)n is not handled by the CastExpression but on behalf of the SNR, ah well.

But then I see that in Expression.computeConversion any type above T_LastWellknownTypeId is mapped to T_JavaLangObject, so in the sequel and &quot;special conversions for jlO&quot; are actually conversions for any user type, right?

BUT, what happens for types below T_LastWellknownTypeId? The primitive wrappers have special treatment, but any attempt to cast any other wellknown type to int might give unexpected results??   

And here&apos;s indeed how to produce illegal byte code:

//---
import java.io.Serializable;

public class CastTest implements Serializable {
	static int test(Serializable v) {
		return (int)v;
	}
	public static void main(String[] args) {
		int i = test(new CastTest());
		System.out.println(i);
	}
}
//---

answers:
Exception in thread &quot;main&quot; java.lang.VerifyError: Bad type on operand stack
Exception Details:
  Location:
    CastTest.test(Ljava/io/Serializable;)I @1: invokevirtual
  Reason:
    Type &apos;java/io/Serializable&apos; (current frame, stack[0]) is not assignable to &apos;java/lang/Boolean&apos;
  Current Frame:
    bci: @1
    flags: { }
    locals: { &apos;java/io/Serializable&apos; }
    stack: { &apos;java/io/Serializable&apos; }
  Bytecode:
    0000000: 2ab6 0012 c000 18ac                    

:(

The bytes in test look like this:
    0: aload_0       
    1: invokevirtual #18      // Method java/lang/Boolean.booleanValue:()Z
    4: checkcast     #24      // class I
    7: ireturn       

I have no idea, how Boolean enters the stage...

Maybe the old impl. was consistent in itself by knowing that only jlO can be observed in this situation. By admitting more types I&apos;ve asked for trouble. Trouble has been delivered on request.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365229</commentid>
    <comment_count>5</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-18 19:50:30 -0500</bug_when>
    <thetext>(In reply to comment #4)
&gt; I have no idea, how Boolean enters the stage...

Fallthrough or default fallback for unboxing conversion?

What I find even more interesting is, how could this program print &apos;1&apos;:

public class CastTest implements Serializable {
  static &lt;S extends Boolean &amp; Serializable&gt;int test(S b) {
    return (int) b;
  }

  public static void main(String[] args) {
    int i = test(Boolean.TRUE);
    System.out.println(i);
  }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365414</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 07:05:25 -0500</bug_when>
    <thetext>*** Bug 428522 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365418</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 07:08:27 -0500</bug_when>
    <thetext>From comment#0:

public class X {
    public static void main(String args[]) {
    	long l = (long) ((Object) 100L);
    }
}

results in a verify error, when &quot;Preserve unused local variables&quot; option is
turned off.

There is also a suspect warning about unneeded cast.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365519</commentid>
    <comment_count>8</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-19 10:12:54 -0500</bug_when>
    <thetext>(In reply to comment #5)
&gt; What I find even more interesting is, how could this program print &apos;1&apos;:

Also this one

public class CastTest implements Serializable {
  static int test(Serializable b) {
    return (int) (Boolean &amp; Serializable) b;
  }

  public static void main(String[] args) {
    int i = test(Boolean.TRUE);
    System.out.println(i);
  }
}

It doesn&apos;t show any warnings or errors in editor, but when run prints

Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Boolean cannot be cast to java.lang.Integer
	at casting.CastTest.test(CastTest.java:7)
	at casting.CastTest.main(CastTest.java:11)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365689</commentid>
    <comment_count>9</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 15:09:08 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #4)

&gt; And here&apos;s indeed how to produce illegal byte code:

Thanks. Fix is trivial: Simply pretend the compile time type is jlO
under the right circumstances. 

&gt; The bytes in test look like this:
&gt;     0: aload_0       
&gt;     1: invokevirtual #18      // Method java/lang/Boolean.booleanValue:()Z
&gt;     4: checkcast     #24      // class I
&gt;     7: ireturn       
&gt; 
&gt; I have no idea, how Boolean enters the stage...

The conversions tables are defined for specific id encodings. Pass it
something unexpected, folding, rounding, chopping, truncating etc can
happen.

&gt; Maybe the old impl. was consistent in itself by knowing that only jlO can be
&gt; observed in this situation. By admitting more types I&apos;ve asked for trouble.

All other types admitted now can simply be treated as Object since the rules
are the same. 

(In reply to Timo Kinnunen from comment #5)

&gt; What I find even more interesting is, how could this program print &apos;1&apos;:

Perhaps your fork was stale at the time you tested ? I don&apos;t see this problem
on HEAD. In any case I have captured this into a test.

(In reply to Timo Kinnunen from comment #8)
&gt; (In reply to comment #5)
&gt; &gt; What I find even more interesting is, how could this program print &apos;1&apos;:
&gt; 
&gt; Also this one

&gt; It doesn&apos;t show any warnings or errors in editor, but when run prints

Thanks, this was due to an oversight in not overloading a method or
equivalently in coalescing the types intersecting where it can be trivially
done.

Fix and tests will follow shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365729</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 16:30:23 -0500</bug_when>
    <thetext>Released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=97fd5cbd4b6c9f4969ee36268bca7114f34c711d</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365756</commentid>
    <comment_count>11</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-19 17:18:58 -0500</bug_when>
    <thetext>(In reply to comment #9)

&gt; Perhaps your fork was stale at the time you tested ? I don&apos;t see this problem
&gt; on HEAD. In any case I have captured this into a test.

Ah, you missed out :) This was the bytecode that was generated:

//  static int test(java.lang.Boolean b);
//    0  aload_0 [b]
//    1  invokevirtual java.lang.Boolean.booleanValue() : boolean [20]
//    4  ireturn

Which leads to the question, would that be valid bytecode for the method

static int test2(Boolean b) { return b ? 1 : 0; } 

JVMS seems to allow that: &quot; The Java Virtual Machine encodes boolean array components using 1 to represent true and 0 to represent false. Where Java programming language boolean values are mapped by compilers to values of Java Virtual Machine type int, the compilers must use the same encoding. &quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367413</commentid>
    <comment_count>12</comment_count>
    <who name="Manju Mathew">manju656</who>
    <bug_when>2014-02-24 02:59:47 -0500</bug_when>
    <thetext>Tested using  Kepler SR2 + Java 8 RC1 + Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140223-2022

Encountered 2 issues with the below code when compiled against Java 1.8 b129.
package p1;

import java.io.Serializable;

public class CastTest implements Serializable {
	static int test(Serializable v) {
		return (int) v; // Expected compiler error here
	}
	public static void main(String[] args) {
		Number n = new Double(0);
		System.out.println(Math.round((double) n)); // Expected compiler error
													// here
		System.out.println(test(new CastTest()));
	}

}

1. It doesn&apos;t show any compiler error, ideally it should have shown 2 compiler errors.
2. Debug the code and evaluate &quot;(double) n&quot;, the evaluation throws CCE, this probably could be since the compiler did not issue the error as expected:
java.lang.ClassCastException: org.eclipse.jdt.internal.debug.core.model.JDIType cannot be cast to org.eclipse.jdt.debug.core.IJavaReferenceType
	at org.eclipse.jdt.internal.debug.eval.ast.engine.AbstractRuntimeContext.classForName(AbstractRuntimeContext.java:127)
	at org.eclipse.jdt.internal.debug.eval.ast.engine.AbstractRuntimeContext.classForName(AbstractRuntimeContext.java:171)
	at org.eclipse.jdt.internal.debug.eval.ast.instructions.Instruction.getType(Instruction.java:203)
	at org.eclipse.jdt.internal.debug.eval.ast.instructions.Cast.execute(Cast.java:93)
	at org.eclipse.jdt.internal.debug.eval.ast.engine.Interpreter.execute(Interpreter.java:66)
	at org.eclipse.jdt.internal.debug.eval.ast.engine.ASTEvaluationEngine$EvalRunnable$1EvaluationRunnable.run(ASTEvaluationEngine.java:663)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367424</commentid>
    <comment_count>13</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-24 03:15:30 -0500</bug_when>
    <thetext>(In reply to Manju Mathew from comment #12)
&gt; Tested using  Kepler SR2 + Java 8 RC1 + Eclipse Java Development Tools Patch
&gt; for Java 8 Support (BETA) 1.0.0.v20140223-2022
&gt; 
&gt; Encountered 2 issues with the below code when compiled against Java 1.8 b129.
&gt; package p1;

Manju,did you compare the behavior with javac ? 8b129 compiles this code
and when run the program throws a CCE - this is the correct behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367442</commentid>
    <comment_count>14</comment_count>
    <who name="Manju Mathew">manju656</who>
    <bug_when>2014-02-24 03:44:03 -0500</bug_when>
    <thetext>Checked using javac and it compiles fine using 8b129. Executed the code and it threw CCE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367443</commentid>
    <comment_count>15</comment_count>
    <who name="Manju Mathew">manju656</who>
    <bug_when>2014-02-24 03:44:52 -0500</bug_when>
    <thetext>Verified using Kepler SR2 + Java 8 RC1 + Eclipse Java Development Tools Patch for Java 8 Support (BETA) 1.0.0.v20140223-2022</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367722</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-24 11:28:21 -0500</bug_when>
    <thetext>The debugger exception looks suspicious to me.

Is the debbuger trying to report a CCE-to-double, but expects that the cast type in a CCE is a reference type? If so (I haven&apos;t looked at this) then we should report this against JDT/Debug, no?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367906</commentid>
    <comment_count>17</comment_count>
    <who name="Manju Mathew">manju656</who>
    <bug_when>2014-02-24 17:46:30 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #16)
&gt; The debugger exception looks suspicious to me.
&gt; 
&gt; Is the debbuger trying to report a CCE-to-double, but expects that the cast
&gt; type in a CCE is a reference type? If so (I haven&apos;t looked at this) then we
&gt; should report this against JDT/Debug, no?

I had raised bug 428885 against JDT/Debug to report this.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>