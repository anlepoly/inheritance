<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>415274</bug_id>
          
          <creation_ts>2013-08-17 00:32:00 -0400</creation_ts>
          <short_desc>Annotation processing throws a NPE in getElementsAnnotatedWith()</short_desc>
          <delta_ts>2015-03-18 10:16:52 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>APT</component>
          <version>4.4</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>https://git.eclipse.org/r/40296</see_also>
    
    <see_also>https://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=a6fddb558f09852d0df8b3655125e6a25d3ce37b</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>4.5 M6</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Wendell Beckwith">wbeckwith</reporter>
          <assigned_to name="Harry Terkelsen">het</assigned_to>
          <cc>eclipse.sprigogin</cc>
    
    <cc>eclipse</cc>
    
    <cc>het</cc>
    
    <cc>jarthana</cc>
    
    <cc>shankhba</cc>
    
    <cc>wbeckwith</cc>
          
          <votes>0</votes>

      

      

      <flag name="review"
          id="64171"
          type_id="1"
          status="+"
          setter="jarthana"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2295896</commentid>
    <comment_count>0</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2013-08-17 00:32:16 -0400</bug_when>
    <thetext>We annotate some of our classes with the org.mangosdk.spi.ProviderFor annotation.  We have a setup where one of the projects in the workspace creates an annotation jar (foo-anno.jar) that is used by other dependent projects in the workspace.  When eclipse is 1st started up then all is well and annotation proceeds without error.  However if our own foo-anno.jar gets rebuilt while eclipse is up then more often than not annotation processing will start throwing the following stacktrace in the Error log.


java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.getElementsAnnotatedWith(RoundEnvImpl.java:127)
	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundEnvImpl.getElementsAnnotatedWith(RoundEnvImpl.java:195)
	at org.mangosdk.spi.processor.SpiProcessor.handleAnnotations(SpiProcessor.java:138)
	at org.mangosdk.spi.processor.SpiProcessor.process(SpiProcessor.java:105)
	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.handleProcessor(RoundDispatcher.java:139)
	at org.eclipse.jdt.internal.compiler.apt.dispatch.RoundDispatcher.round(RoundDispatcher.java:110)
	at org.eclipse.jdt.internal.compiler.apt.dispatch.BaseAnnotationProcessorManager.processAnnotations(BaseAnnotationProcessorManager.java:159)
	at org.eclipse.jdt.internal.apt.pluggable.core.dispatch.IdeAnnotationProcessorManager.processAnnotations(IdeAnnotationProcessorManager.java:134)
	at org.eclipse.jdt.internal.compiler.Compiler.processAnnotations(Compiler.java:846)
	at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:434)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:366)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.compile(BatchImageBuilder.java:178)
	at org.eclipse.jdt.internal.core.builder.AbstractImageBuilder.compile(AbstractImageBuilder.java:303)
	at org.eclipse.jdt.internal.core.builder.BatchImageBuilder.build(BatchImageBuilder.java:60)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.buildAll(JavaBuilder.java:254)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:173)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:726)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:199)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:239)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:292)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:295)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:351)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:374)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:143)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:241)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)

The NPE is because line 195 in RoundEnvImpl.java passes a null argument to the getElementsAnnotatedWith() method on line 127.  That method doesn&apos;t check for null and tries to use the parameter.  The solution is to add the following to the start of the getElementsAnnotatedWith() method at line 127.

	if (a == null) {
		return Collections.emptySet();
	}

This bug affects 4.3 as well as 4.4M1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2295904</commentid>
    <comment_count>1</comment_count>
    <who name="Walter Harley">eclipse</who>
    <bug_when>2013-08-17 02:54:47 -0400</bug_when>
    <thetext>Does your annotation processor directly reference types in foo-anno.jar?  

Keep in mind that the annotation processor is loaded into the compiler&apos;s process; it is not like ordinary code, it is actually a plug-in to the compiler itself.  If the processor loads classes from foo-anno.jar, and you rebuild foo-anno.jar on the fly, this is not really any different than if you rebuilt one of the Eclipse jars on the fly while Eclipse was still loaded.  It is unfortunately not possible, given the constraints of the JVM and classloader, to reliably unload annotation processor classes while the Eclipse process is still running.  If your annotation processor code imports annotation types, the same issue applies.

On the other hand, if the annotation processor does NOT include any types contained in foo-anno.jar, then this sounds like a bug.  (Either way, of course, we should fix the NPE; but it sounds like just fixing the NPE would not really solve the underlying issue, because the processing would still in that case be incorrect.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2295990</commentid>
    <comment_count>2</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2013-08-18 10:42:06 -0400</bug_when>
    <thetext>Our annotation processors are in foo-anno.jar.  Hmm, we have the additional complication where the some team members use intellij and others eclipse.  If I understand correctly, intellij just launches a process when it needs to do a build while your explanation says eclipse loads the AP into the running eclipse process.      It looks like I can then split the annotations out from the annotation jar and make our projects depend on that.  However if the APs are ever updating then we need to restart eclipse correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2296062</commentid>
    <comment_count>3</comment_count>
    <who name="Walter Harley">eclipse</who>
    <bug_when>2013-08-19 03:01:48 -0400</bug_when>
    <thetext>Correct.  IntelliJ doesn&apos;t have its own compiler; it spawns a process and runs javac.  So, it doesn&apos;t do incremental compilation.  Eclipse is quite different: it contains its own, completely independent, Java compiler, and it maintains a compiled typesystem in memory, updating it as you change individual files.  There are strengths to each approach.  The APT interfaces are not well suited to incremental compilation, perhaps because Sun doesn&apos;t have an incremental compiler.

You are right that you can split out the annotations from the processors.  If the processors change it is safest to restart Eclipse.  There is some discussion of this on the presentations linked from the Eclipse JDT/APT web page, which is very old but still has some valid tips.  For doing annotation processor development, you can launch a target Eclipse instance from within your development Eclipse instance, just as if you were working on developing any other Eclipse plugin.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298514</commentid>
    <comment_count>4</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2013-08-23 13:22:37 -0400</bug_when>
    <thetext>Is there any chance of getting this bug fixed in 4.3.1?  I mean from a simple review of the code the fix as described is incredibly simple.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298599</commentid>
    <comment_count>5</comment_count>
    <who name="Walter Harley">eclipse</who>
    <bug_when>2013-08-23 20:17:20 -0400</bug_when>
    <thetext>My understanding from your comments was that the proposed fix would remove the NPE, but would still not result in correct annotation processing - i.e., it would just be failing silently instead of noisily.  Did I misunderstand?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298645</commentid>
    <comment_count>6</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2013-08-24 11:54:43 -0400</bug_when>
    <thetext>Yes, that was a misunderstanding.  The fix is needed because it causing annotation processing to stop when it shouldn&apos;t.  The additional problem was/is related to how we currently have things setup.  Now that I know better how eclipse handles anno. processing we can make changes in our setup as well as advice users that if they rebuild the annotation processing project then they will need to restart the IDE since the previous AP&apos;s were loaded into the IDE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2345823</commentid>
    <comment_count>7</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-01-04 01:22:32 -0500</bug_when>
    <thetext>This bug is still open and affecting users.  The solution is really just a null check.  What&apos;s needed to get this into M5?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2345824</commentid>
    <comment_count>8</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-01-04 01:39:18 -0500</bug_when>
    <thetext>I haven&apos;t understood the issue completely, but will take a look at this in one or two weeks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2345847</commentid>
    <comment_count>9</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-01-04 06:10:43 -0500</bug_when>
    <thetext>There were 2 issues.  One was in understanding that Eclipse loads the annotations processors into the current process and thus they can&apos;t be recompiled and a new jar generated that replaces the jar eclipse is currently loading from.  There&apos;s nothing that needs to be done there ATM.

The 2nd issue and really more important issue is that the RoundEnvImpl.getElementsAnnotatedWith() method at line 127 causes an NPE because it doesn&apos;t do a null check.  To resolve this bug, just perform a null check and if null return an empty set and everything is golden.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2357517</commentid>
    <comment_count>10</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-02-01 10:55:17 -0500</bug_when>
    <thetext>OK, it&apos;s been several weeks, can we please now add a null check to prevent an NPE that causes annotation processing to abort.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2358307</commentid>
    <comment_count>11</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-02-04 00:34:57 -0500</bug_when>
    <thetext>(In reply to Bin Yan from comment #9)
&gt; The 2nd issue and really more important issue is that the
&gt; RoundEnvImpl.getElementsAnnotatedWith() method at line 127 causes an NPE
&gt; because it doesn&apos;t do a null check.  To resolve this bug, just perform a
&gt; null check and if null return an empty set and everything is golden.

Are you saying that null type elements should silently be ignored? I tend to think that we should throw an IllegalArgumentException because the Javadoc of TypeElement#getElementsAnnotatedWith() says we should do so &quot;if the argument does not represent an annotation type&quot;? Would that solve the issue you are facing?

Oh, by the way, Javac fails with an NPE too.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2377453</commentid>
    <comment_count>12</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-03-19 04:57:21 -0400</bug_when>
    <thetext>(In reply to Jayaprakash Arthanareeswaran from comment #11)
&gt; (In reply to Bin Yan from comment #9)
&gt; &gt; The 2nd issue and really more important issue is that the
&gt; &gt; RoundEnvImpl.getElementsAnnotatedWith() method at line 127 causes an NPE
&gt; &gt; because it doesn&apos;t do a null check.  To resolve this bug, just perform a
&gt; &gt; null check and if null return an empty set and everything is golden.
&gt; 
&gt; Are you saying that null type elements should silently be ignored? I tend to
&gt; think that we should throw an IllegalArgumentException because the Javadoc
&gt; of TypeElement#getElementsAnnotatedWith() says we should do so &quot;if the
&gt; argument does not represent an annotation type&quot;? Would that solve the issue
&gt; you are facing?
&gt; 
&gt; Oh, by the way, Javac fails with an NPE too.

I think you&apos;re right and the code shouldn&apos;t silently ignore null, mainly because from looking at the code the RoundEnv.getElementsAnnotatedWith(TypeElement) method should never be called with null in this case.

The SpiProcessor.handleAnnotations(SpiProcessor.java:138) method is the following:

private void handleAnnotations(RoundEnvironment roundEnv) {
	Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(ProviderFor.class);
	for (Element e : elements) {
		handleElement(e);
	}
}

It passes a valid class to the RoundEnv.getElementsAnnotatedWith(Class&lt;? extends Annotation&gt;) method.  The code for the RoundEnv.getElementsAnnotatedWith(Class&lt;? extends Annotation&gt;) method is:

@Override
public Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a)
{
	String canonicalName = a.getCanonicalName();
	if (canonicalName == null) {
		// null for anonymous and local classes or an array of those
		throw new IllegalArgumentException(&quot;Argument must represent an annotation type&quot;); //$NON-NLS-1$
	}
	TypeElement annoType = _processingEnv.getElementUtils().getTypeElement(canonicalName);
	return getElementsAnnotatedWith(annoType);
}

From the code we can clearly see that annoType local variable can be null and this code blindly passes it to the RoundEnv.getElementsAnnotatedWith(TypeElement) method.  I think the return statement for this method should be &quot;return (annoType != null ? getElementsAnnotatedWith(annoType) : Collections.emptySet());&quot;

From the javadocs, the RoundEnv.getElementsAnnotatedWith(Class&lt;? extends Annotation&gt;) method should either A.) return the elements annotated with the given annotation type, or an empty set if there are none or B.) throw an IllegalArgumentException if the parameter is not an annotation type.  Since a valid annotation type is being passed in then the method must return a potentially empty set.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2378950</commentid>
    <comment_count>13</comment_count>
    <who name="Walter Harley">eclipse</who>
    <bug_when>2014-03-24 01:01:44 -0400</bug_when>
    <thetext>I&apos;m not quite following that logic.  If ProviderFor is a valid annotation class, then why would getTypeElement() of its canonical name return a null?

That doesn&apos;t seem like the sort of error that should be ignored.  I can see throwing an IAE instead of an NPE, but that wouldn&apos;t particularly help you.

I am *not* comfortable adding a null check and returning an empty set, and throwing away the error, without a better understanding of exactly why this error (and all other errors that could cause the same null value) are truly innocuous.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2379246</commentid>
    <comment_count>14</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-03-24 10:24:31 -0400</bug_when>
    <thetext>It is a valid annotation type as here is the complete code for it:

package org.mangosdk.spi;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.SOURCE)
public @interface ProviderFor {
	Class&lt;?&gt;[] value();
}

Now according to the api docs, eclipse should only throw an IAE if the parameter is not an annotation type which it clearly is.  So the option to throw an IAE should be off the table.  Now as to why it may be happening, I going to guess and say it may be similar to another issue (bug 407841) I opened related to annotation processors not being given all the classes to process if the annotation processors are called in multiple rounds.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2379384</commentid>
    <comment_count>15</comment_count>
    <who name="Walter Harley">eclipse</who>
    <bug_when>2014-03-24 12:44:10 -0400</bug_when>
    <thetext>Okay, then the focus should be on fixing that bug, not hiding it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2379505</commentid>
    <comment_count>16</comment_count>
    <who name="Wendell Beckwith">wbeckwith</who>
    <bug_when>2014-03-24 16:31:59 -0400</bug_when>
    <thetext>(In reply to Walter Harley from comment #15)
&gt; Okay, then the focus should be on fixing that bug, not hiding it.

I&apos;m not saying that this is an instance of the other bug.  I haven&apos;t looked into the internals of what the &apos;processingEnv.getElementUtils().getTypeElement(canonicalName);&apos; does but nonetheless, the method in question is not API compliant with respect to what the java docs say it should do.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509797</commentid>
    <comment_count>17</comment_count>
    <who name="Harry Terkelsen">het</who>
    <bug_when>2015-01-23 21:49:38 -0500</bug_when>
    <thetext>Someone please review my patch here:
https://git.eclipse.org/r/#/c/40296/

We have run into this bug as well. The reason is that the class being referred to in the getElementsAnnotatedWith is on the processor path, but not on the classpath. Therefore, when Eclipse looks up the fully-qualified class name, it returns null and an NPE is thrown. This is also why it is safe to just return the empty set in this case: we aren&apos;t hiding any errors, we are just taking advantage of the fact that Eclipse does not know about this type, so therefore no elements can possibly be annotated with it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2509801</commentid>
    <comment_count>18</comment_count>
    <who name="Sergey Prigogin">eclipse.sprigogin</who>
    <bug_when>2015-01-23 22:40:58 -0500</bug_when>
    <thetext>(In reply to Harry Terkelsen from comment #17)

I&apos;d like to clarify that if the code does contain an annotation referring to a class not found on the classpath, the annotation will be marked as error regardless of this patch.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2515469</commentid>
    <comment_count>19</comment_count>
    <who name="Sergey Prigogin">eclipse.sprigogin</who>
    <bug_when>2015-02-06 19:38:07 -0500</bug_when>
    <thetext>This is a pretty serious issue. Jay, could you please review the proposed fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2515672</commentid>
    <comment_count>20</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-02-09 01:01:11 -0500</bug_when>
    <thetext>Thanks for the reminder. I have merged the code in master:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=a6fddb558f09852d0df8b3655125e6a25d3ce37b</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2515934</commentid>
    <comment_count>21</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-02-09 08:41:57 -0500</bug_when>
    <thetext>Gerrit change https://git.eclipse.org/r/40296 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=a6fddb558f09852d0df8b3655125e6a25d3ce37b</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2533654</commentid>
    <comment_count>22</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2015-03-18 10:16:52 -0400</bug_when>
    <thetext>Verified for 4.5 M6 with build I20150316-2000.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>