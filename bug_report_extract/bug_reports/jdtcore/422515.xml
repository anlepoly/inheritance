<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>422515</bug_id>
          
          <creation_ts>2013-11-25 14:53:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] &quot;Missing code implementation in the compiler&quot; when lambda body accesses array variable</short_desc>
          <delta_ts>2013-11-28 11:26:21 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Markus Keller">markus_keller</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2334205</commentid>
    <comment_count>0</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-11-25 14:53:47 -0500</bug_when>
    <thetext>&quot;Missing code implementation in the compiler&quot; compile error when a lambda body accesses an array-typed variable:

package jsr335;

public class LambdaAccessArray {
    public static void main(String[] args) throws InterruptedException {
        final int[] result= { 0 };
        Thread t = new Thread(() -&gt; {
            result[0]= 42;
        });
        t.start();
        t.join();
        System.out.println(result[0]);
    }
}

The error doesn&apos;t occur when the lambda body is just an expression like this:

        Thread t = new Thread(() -&gt; result[0]= 42);

The problem is reported here: 

org.eclipse.jdt.internal.compiler.problem.ProblemReporter.needImplementation(ProblemReporter.java:6178)
	at org.eclipse.jdt.internal.compiler.codegen.CodeStream.generateOuterAccess(CodeStream.java:2286)
	at org.eclipse.jdt.internal.compiler.codegen.StackMapFrameCodeStream.generateOuterAccess(StackMapFrameCodeStream.java:364)
	at org.eclipse.jdt.internal.compiler.ast.SingleNameReference.generateCode(SingleNameReference.java:487)
	at org.eclipse.jdt.internal.compiler.ast.ArrayReference.generatePostIncrement(ArrayReference.java:166)
	at org.eclipse.jdt.internal.compiler.ast.PostfixExpression.generateCode(PostfixExpression.java:40)
	at org.eclipse.jdt.internal.compiler.ast.Expression.generateCode(Expression.java:695)
	at org.eclipse.jdt.internal.compiler.ast.Block.generateCode(Block.java:75)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:751)
	at org.eclipse.jdt.internal.compiler.ast.LambdaExpression.generateCode(LambdaExpression.java:702)
	at org.eclipse.jdt.internal.compiler.ClassFile.addSpecialMethods(ClassFile.java:923)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:573)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.generateCode(TypeDeclaration.java:638)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.generateCode(CompilationUnitDeclaration.java:369)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:781)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:137)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334575</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-26 10:31:11 -0500</bug_when>
    <thetext>This is the side effect of running control/data flow analysis on the
lambda body without it first being run on the enclosing method(s). We create
a parallel universe as far as AST and FlowContext and FlowInfo abstractions
go, but for scopes and bindings - we reuse. This is bad. Basically, during
lambda&apos;s flow analysis, we find outer local array &quot;result&quot; as being
uninitialized and set a bit on the binding. This is because this bit is
required during code generation and flow info has evaporated at that point.

I&apos;ll investigate.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334646</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-26 12:27:25 -0500</bug_when>
    <thetext>(In reply to Markus Keller from comment #0)
&gt; &quot;Missing code implementation in the compiler&quot; compile error when a lambda
&gt; body accesses an array-typed variable:

[...]

&gt; The error doesn&apos;t occur when the lambda body is just an expression like this:
&gt; 
&gt;         Thread t = new Thread(() -&gt; result[0]= 42);

For an expression bodied lambda we don&apos;t have to do control flow analysis.
We know its value compatible if the expression is not of void type and it
is void compatible if the expression can be standalone statement - so things
are simple there.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334676</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-26 13:36:20 -0500</bug_when>
    <thetext>Fix and tests released here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=9cd17ece7cc1ac607f4f1302fc1a6d286dff9da1

We basically start the (overload resolution trial) flow analysis for lambda
bodies against a perfect world: all outer locals are definitely assigned. It
is not pertinent if they are otherwise - the eventual analysis will catch
the errors.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2335485</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-28 08:07:17 -0500</bug_when>
    <thetext>I see that flow analysis is performed with null annotation analysis disabled. For my education: what results of flow analysis are actually needed in this context?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2335495</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-28 08:31:06 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #4)

&gt; I see that flow analysis is performed with null annotation analysis
&gt; disabled. For my education: what results of flow analysis are actually
&gt; needed in this context?

This is the trial evaluation on a clone and not the original lambda. Since
the null analysis switch is restored properly in the finally block, the 
eventual resolution would carry out null analysis if requested.

Basically, during resolve stage, we need information on whether a lambda 
expression is value compatible or value compatible or both or none. This 
cannot be determined by say an ASTVisitor that looks for return statements.

e.g: 

interface I {
	void foo (int x);
}
public class X {
	static void foo(I i) {}
	public static void main(String[] args) {
		boolean constantequalstotrue;
		constantequalstotrue = true;
		I i = (x) -&gt; { if (x &gt; 0) return x; };  // neither
		i =   (x) -&gt; { throw new RuntimeException(); }; // both
		i =   (x) -&gt; { while (constantequalstotrue); }; // both
		i =   (x) -&gt; { System.out.println(x); }; // void
		i =   (x) -&gt; { return x; };  // value
	}
} 

LE.isCompatibleWith is implementing 15.12.2.1 and actually a bit more than
that, we don&apos;t distinguish between potential compatibility and applicability
and merge them together into compatibility.

---

A lambda expression (15.27) is potentially compatible with a functional 
interface type (9.8) if all of the following are true:
The arity of the targeted type&apos;s function type is the same as the arity of the 
lambda expression.
If the targeted type&apos;s function type has a void return, then the lambda body is either a statement expression (14.8) or a void-compatible block (15.27.2).
If the targeted type&apos;s function type has a (non-void) return type, then the 
lambda body is either an expression or a valuecompatible block (15.27.2).

--

For part F, it used to be that the lambda had to be resolved + analyzed against
every target type candidate. draft 0.7 has done away with this requirement.
So we need at most two resolves + analyze irrespective of the number of
candidate methods: one to discover the shape and one ultimate resolve. 

My cursory reading of part G, tells me we need to resolve + analyze n+1 times
for inference - not sure, but we have the machinery in place.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2335612</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-11-28 11:26:21 -0500</bug_when>
    <thetext>Thanks for explaining.
So, applicability check needs to know about UNREACHABLE, right? Makes sense.
Good we separated UNREACHABLE_OR_DEAD from UNREACHABLE_BY_NULLANALYSIS :)</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>