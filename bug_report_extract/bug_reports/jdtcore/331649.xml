<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>331649</bug_id>
          
          <creation_ts>2010-12-02 06:24:00 -0500</creation_ts>
          <short_desc>[compiler][null] consider null annotations for fields</short_desc>
          <delta_ts>2013-04-10 09:18:10 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>3.7</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>4.3 M5</target_milestone>
          <dependson>186342</dependson>
          <blocked>382789</blocked>
    
    <blocked>398995</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Stephan Herrmann">stephan.herrmann</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>amj87.iitr</cc>
    
    <cc>andrew</cc>
    
    <cc>arno</cc>
    
    <cc>chris</cc>
    
    <cc>daniel_megert</cc>
    
    <cc>h.klene</cc>
    
    <cc>jarthana</cc>
    
    <cc>jawr</cc>
    
    <cc>lieven.lemiengre</cc>
    
    <cc>loskutov</cc>
    
    <cc>markus_keller</cc>
    
    <cc>mernst</cc>
    
    <cc>natros</cc>
    
    <cc>reprogrammer</cc>
    
    <cc>ReubenGarrett</cc>
    
    <cc>satyam.kandula</cc>
    
    <cc>Sebastian.Zarnekow</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>trask.stalnaker</cc>
    
    <cc>volker.berlin</cc>
          
          <votes>1</votes>

      

      

      <flag name="review"
          id="48270"
          type_id="1"
          status="?"
          setter="srikanth_sankaran"
          requestee="srikanth_sankaran"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>1851218</commentid>
    <comment_count>0</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2010-12-02 06:24:17 -0500</bug_when>
    <thetext>Once bug 186342 is fixed we might want to think of supporting those
annotations also for fields.

Without bending the semantics of Java this would imply that for any
@NonNull field:
- any exit from a constructor must establish that the field is 
  definitely non-null
- any assignment in a method must assign a definitely non-null value.

More sophisticated and more flexible models may exist, e.g.:
- allowing fields to be still null after the constructor but designating
  init methods to do the job, forcing clients to call init immediately 
  after the constructor
- allowing intermediate states with nulls given the invariant is restored
  at each exit of a method.

Here costs and benefits must be weighed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>1873864</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2011-01-27 04:30:34 -0500</bug_when>
    <thetext>From some early statistics documented in bug 186342 comment 89 my
gut feeling tells me we should also address fields pretty soon, in
order to reduce the number of warnings produced.

After some recent reading I see two main alternative proposals:

(A) rawness as supported by the Checker Framework (Mike Ernst)

(B) monotonic non-null as proposed by Chalin, James, Rioux


Both approaches seem well capable of reducing the number of warnings.
Also, both soundly address the issues of initialization and concurrency.

(A) introduces new annotations for capturing references to not-fully
initialized objects. This approach may require more specification up-front
(methods called from constructors need to be marked @Raw, the same for any
this-leaks from constructors), but then gives stronger guarantees for the 
usage of a non-null field.

Following (B) only one annotation at the field (@EventuallyNonNull) is 
required but then guarantees for that field are weaker (field read may *not*
assume non-null, but after one successful check for non-null the field is 
known to remain non-null, i.e., fields behave similar to locals with unknown
initial nullness).

I would like not to select one and reject the other because both approaches
seem to reflect different styles of programming: (A) would probably work
best for green-field development, where a strict discipline can be enforced
in order to achieve strong guarantees. By contrast, (B) seems superior for
capturing lazy initialization of fields, i.e., reasoning about fields that
are not (definitely) initialized by the constructor.

I&apos;d like to hear comments on the following points:
- Are there significantly other proposals for specifying nullness of fields?
- Is it correct that neither approach subsumes the other?
- Are there any reasons why both approaches might be incompatible, i.e.,
  anything preventing a combination of both?

Indeed, given that both approaches have different requirements and 
implications, and given that we are not a standardization body, I&apos;m leaning
to eventually supporting both as separate options, if possible.


Technically (B) seems closer to the analysis we already have in the compiler,
while (A) would open a new category of analysis. So, implementationwise (B)
probably requires less efforts.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2054039</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-01-21 14:54:40 -0500</bug_when>
    <thetext>I just pushed a new feature branch: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/log/?h=sherrmann/NullAnnotationsForFields

This shows my current implementation for this bug on top of bug 247564.

In order to analyse annotated fields in all positions, more syntactic 
constructs (most subtypes of Reference) had to be included in the analysis. 
While I was at it I included also those constructs that don&apos;t refer to fields
but have a constant nonnull property (like, e.g., &apos;this&apos;).

You may wonder, how often you&apos;d find &quot;if (this != null) ...&quot;, but ... 
if you set the following IProblems to error: 
  RedundantNullCheckOnNonNullExpression 
  NonNullExpressionComparisonYieldsFalse, 
(e.g., by deleting these from ProblemReporter#getIrritant()), just run all
JDT/Core tests and be surprised about the &apos;nonsense&apos; we have in our tests :)

Field *initialization* is the main conceptual problem in this area. My 
current implementation only does the minimal checking: see if all fields are 
definitely assigned at the end of each constructor (using the same logic
as it is used for final fields). Since assigning a pot.null or even unknown
value to such a field is illegal anyway, def.assigned implies def.nonnull.
Doing similar checks for static fields is a TODO.

However, I made no attempts whatsoever to protect uninitialized @NonNull 
fields from being dereferenced. 
* If we want to protect an unassigned @NonNull variable against access from
  another method (indirectly) called from the constructor, we definitely need
  at least one more annotation, so I&apos;m deferring this as of now.
* OTOH, within the constructor it should be easily possible (though not yet
  done in the implementation) to detect when a @NonNull field is accessed
  before being definitely assigned.


Implementation notes:

The most tricky part is continuing the work from bug 247564 wrt 
resetNullInfoForFields etc. Some details:

- new field ClassScope.fieldResetNullInfo: 
  Here I collect the constantFieldsMask plus the default null status for
  these kinds of fields:
  - regular fields: default is 1001 (unknown)
  - @Nullable fields: default is 0100 (pot.null)
  other fields (constants and @NonNull) are not reset

- both pieces of information (constantFieldsMask and default status) are
  collected into fieldResetNullInfo during FieldDeclaration.analyseCode()

- TypeDeclaration only coordinates handling of fieldResetNullInfo

- whenever UFI#resetNullInfoForFields is called the fieldResetNullInfo is
  passed in so that we can set status of all fields to the desired default
  by only performing bit operations, merging info from this and
  fieldResetNullInfo.


Def.assignment check: previously only blankFinal() fields would record
their assignment status -&gt; extend this to @NonNull, too.


BinaryTypeBinding now restores null annotations for fields, too.



Some oddities: method NameReference.fieldBinding() turned out to be useless
in one situation, because (to my surprise) for a QNR it returns the *first*
field binding of a chain. Existing clients look safe as expecting only
one-field references. -&gt; Hence the new method lastFieldBinding().

Next, QNR#checkNPE was confusingly overloaded. -&gt; I renamed one version to
document that here we are checking whether the QNR *itself* can cause NPE,
whereas the other checkNPE() checks if the expression can be null and hence
cause NPE when being dereferenced by its parent AST node.
I&apos;m not even sure if protecting checkInternalNPE() with if (needValue)
isn&apos;t a (old) bug. -&gt; TODO

Impl still contains some TODOs/FIXMEs, but their number is rapidly decreasing :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2060451</commentid>
    <comment_count>3</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-03 03:38:07 -0500</bug_when>
    <thetext>I started the review by playing around with the branch a bit. Haven&apos;t dived into the code yet but a few very early questions:
(0) Is the discussion in comment 1 still relevant, given that we neither use @Raw nor @EventuallyNonNull?
(1) According to JavaCore, the effect of the COMPILER_PB_NULL_SPECIFICATION_VIOLATION is extended to fields too, but this has not been done for other null annotation specific options. Is this just a missing piece of doc, or is also missing in the implementation? (Ok I tested this a bit after writing the comment and it seems to work. So maybe its just the doc)
(3) I see a few tests with changed error messages in NullAnnotationTest. Did anything change in the existing implementation for local variables too?
(4) The &quot;..may not have been initialized&quot; warnings are mandated by the JLS and there are set rules on where they should be emitted. Should we re-word the &quot;The @NonNull field .. may not have been initialized&quot; warning to differentiate it from the compiler errors? viz. &quot;The @NonNull field .. may not have been initialized to a definite non null value&quot;
(5) I switched off the &quot;include fields in null analysis&quot; option and yet I could see annotation-related warnings on fields. Shouldn&apos;t the &quot;include fields&quot; switch control this?
(6) For the following example
public class X  {
    @Nullable Object o = new Object(); 
    public void main(String[] args, @Nullable X x1) {
    	if (o != null) {
    		o.toString();  // no warning
    	}
    	if (x1.o != null) {
    		x1.o.toString();  // pot. NPE
    	}
    }
}
The story looks a bit inconsistent. I know why this happens - null analysis for this.o is done using the flowinfo while for x1.o only the annotation is read. But this difference may be hard to explain.
(7) This gives a weaker warning:
public class X  {
	static final Object a = null;
	@NonNull Object o = a; // unknown nullness?
}

Shouldn&apos;t it be stronger since we know the definite nullness of a?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2060475</commentid>
    <comment_count>4</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-03 04:32:50 -0500</bug_when>
    <thetext>(8) Are the two new messages
	/** @since 3.8 */
	int NonNullExpressionComparisonYieldsFalse = Internal + 685;
	/** @since 3.8 */
	int RedundantNullCheckOnNonNullExpression = Internal + 686;
related to the fix for this bug? May be we can spawn off a new bug for these?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061052</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-04 12:49:04 -0500</bug_when>
    <thetext>(In reply to comment #3)
&gt; I started the review by playing around with the branch a bit.

Great, thanks!

&gt; Haven&apos;t dived into the code yet but a few very early questions:
&gt; (0) Is the discussion in comment 1 still relevant, given that we neither use
&gt; @Raw nor @EventuallyNonNull?

I&apos;d say that discussion is deferred, i.e., won&apos;t be covered by this bug.

&gt; (1) According to JavaCore, the effect of the
&gt; COMPILER_PB_NULL_SPECIFICATION_VIOLATION is extended to fields too, but this
&gt; has not been done for other null annotation specific options. Is this just a
&gt; missing piece of doc, or is also missing in the implementation? (Ok I tested
&gt; this a bit after writing the comment and it seems to work. So maybe its just
&gt; the doc)

IIRC one check is still missing in the impl: contradictory annotations on fields. Other than that, yes, it&apos;s a doc bug.

&gt; (2)
Oops, s.o. stole item (2) :)

&gt; (3) I see a few tests with changed error messages in NullAnnotationTest. Did
&gt; anything change in the existing implementation for local variables too?

* Regarding test_nonnull_return_008():
  The method ProblemReporter#messageSendRedundantCheckOnNonNull() has been
  integrated into a much smarter method expressionNonNullComparison() which
  distinguishes a few more IProblems. 
  In particular the NonNullMessageSendComparisonYieldsFalse variety wasn&apos;t
  present previously. This slightly changes the wording and also causes
  the subsequent dead code message.

* the other one is _test_nonnull_return_009b()
  Here I only adjusted the result to the reality of the implementation
  and then enabled this previously disabled test.
  I felt that actually one warning is sufficient and only documented what
  would need to happen to create a warning for the other side, too.

&gt; (4) The &quot;..may not have been initialized&quot; warnings are mandated by the JLS and
&gt; there are set rules on where they should be emitted. Should we re-word the &quot;The
&gt; @NonNull field .. may not have been initialized&quot; warning to differentiate it
&gt; from the compiler errors? viz. &quot;The @NonNull field .. may not have been
&gt; initialized to a definite non null value&quot;

The similarity is intentional, and I figured the change should be sufficient:
  The blank final field {0} may not have been initialized
  The local variable {0} may not have been initialized
  The @NonNull field {1} may not have been initialized

All three messages mention why we expect the variable to be initialized. Clearly, the third reason does not refer to the JLS. You think the difference is not enough?

OK, I don&apos;t want to start a legal case :)

&gt; (5) I switched off the &quot;include fields in null analysis&quot; option and yet I could
&gt; see annotation-related warnings on fields. Shouldn&apos;t the &quot;include fields&quot;
&gt; switch control this?

I think I was suggesting to let &quot;enable annotation based null analysis&quot; imply &quot;include fields&quot;. I don&apos;t think it makes sense to enable the former and disable the latter.

At a closer look we may eventually want a switch for restricting the analysis of fields to the strict part (i.e., worst case assumption regarding concurrency) to get the most out of field annotations.

&gt; (6) For the following example
&gt; public class X  {
&gt;     @Nullable Object o = new Object(); 
&gt;     public void main(String[] args, @Nullable X x1) {
&gt;         if (o != null) {
&gt;             o.toString();  // no warning
&gt;         }
&gt;         if (x1.o != null) {
&gt;             x1.o.toString();  // pot. NPE
&gt;         }
&gt;     }
&gt; }
&gt; The story looks a bit inconsistent. I know why this happens - null analysis for
&gt; this.o is done using the flowinfo while for x1.o only the annotation is read.
&gt; But this difference may be hard to explain.

The latter part of the example is inevitable. It&apos;s the former part that is debatable. I&apos;m avoiding the message here as a courtesy for the user (using bug 247564 for sure). Eventually, in the optional strict mode mentioned above we should also give a (mild) warning here.

OTOH, it&apos;s that latter warning that explicitly mentions the reason for reporting, right? So we don&apos;t leave the user completely uninformed :)

&gt; (7) This gives a weaker warning:
&gt; public class X  {
&gt;     static final Object a = null;
&gt;     @NonNull Object o = a; // unknown nullness?
&gt; }
&gt; 
&gt; Shouldn&apos;t it be stronger since we know the definite nullness of a?

Oops, a bug!

(In reply to comment #4)
&gt; (8) Are the two new messages
&gt;     /** @since 3.8 */
&gt;     int NonNullExpressionComparisonYieldsFalse = Internal + 685;
&gt;     /** @since 3.8 */
&gt;     int RedundantNullCheckOnNonNullExpression = Internal + 686;
&gt; related to the fix for this bug? May be we can spawn off a new bug for these?

Conceptually, they qualify for a separate bug for sure. Technically they&apos;re closely related and I wouldn&apos;t want to create separate patches like I motivated in this comment:

from comment #2:
&gt; In order to analyse annotated fields in all positions, more syntactic 
&gt; constructs (most subtypes of Reference) had to be included in the analysis. 
&gt; While I was at it I included also those constructs that don&apos;t refer to fields
&gt; but have a constant nonnull property (like, e.g., &apos;this&apos;).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061092</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-04 19:54:39 -0500</bug_when>
    <thetext>I merged the feature branch with the latest from master and added:
- test &amp; fix for item (7)
- application of nullness defaults to fields
- detection of redundant/contradictory annotations on fields
Current head in the branch is http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NullAnnotationsForFields&amp;id=874e2c41609c64af417834df9af2e898d8dcf37a

AFAICS this makes it feature complete and resolves the FIXMEs I still had in the code.

JavaDoc still needs updating as mentioned above.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061385</commentid>
    <comment_count>7</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-06 07:53:51 -0500</bug_when>
    <thetext>(In reply to comment #5)
&gt; All three messages mention why we expect the variable to be initialized.
&gt; Clearly, the third reason does not refer to the JLS. You think the difference
&gt; is not enough?
&gt; 
&gt; OK, I don&apos;t want to start a legal case :)
Yeah, while I don&apos;t say the wording is wrong, it just surprised me when I started playing around and got this error. Being used to the &quot;..may not have been initialized&quot; warning, I was confused on seeing one for a non-constant field.
Srikanth, any comments on this?

&gt; I think I was suggesting to let &quot;enable annotation based null analysis&quot; imply
&gt; &quot;include fields&quot;. I don&apos;t think it makes sense to enable the former and disable
&gt; the latter.
Oh. But in that case the UI will have to auto-check &quot;include fields..&quot; option when a user checks &quot;enable annotation...&quot; and then it;ll have to be greyed out too? The only sense in decoupling would be to give the user some flexibility. I know it wont be a usual case when a user wants to enable annotations and not have them diagnose fields, but it may happen.


&gt; &gt; The story looks a bit inconsistent.
&gt; The latter part of the example is inevitable. It&apos;s the former part that is
&gt; debatable. I&apos;m avoiding the message here as a courtesy for the user (using bug
&gt; 247564 for sure). Eventually, in the optional strict mode mentioned above we
&gt; should also give a (mild) warning here.
&gt; 
&gt; OTOH, it&apos;s that latter warning that explicitly mentions the reason for
&gt; reporting, right? So we don&apos;t leave the user completely uninformed :)
Umm, I couldn&apos;t quite understand this point. The latter warning is good, that&apos;s beyond doubt. But in the former case can we do better than plain null analysis now that we have the annotation, and raise a suitable warning? (Assuming that there&apos;s only one mode for 3.8)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061687</commentid>
    <comment_count>8</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-06 14:46:18 -0500</bug_when>
    <thetext>Is there a case when lines 5182-5186 in org.eclipse.jdt.internal.compiler.problem.ProblemReporter.expressionNonNullComparison(Expression, boolean)
get triggered?

Also, whats the needImplementation method for. Is it to handle cases such as 
if (null == null),
if ( (o = b ? new Object(): new Object())== null)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061878</commentid>
    <comment_count>9</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-07 03:27:57 -0500</bug_when>
    <thetext>(8) A scenario which gives contradictory warnings
public class XXX {
    static final @Nullable Object o = null;
    static void goo() {
        if (XXX.o == null) {   // oops
            System.out.println(XXX.o);
        }
    }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061885</commentid>
    <comment_count>10</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-07 03:46:56 -0500</bug_when>
    <thetext>(In reply to comment #9)
&gt; (8) A scenario which gives contradictory warnings
&gt; public class XXX {
&gt;     static final @Nullable Object o = null;
&gt;     static void goo() {
&gt;         if (XXX.o == null) {   // oops
&gt;             System.out.println(XXX.o);
&gt;         }
&gt;     }
&gt; }

Not contradictory. I mean an incorrect &quot;null dereference&quot; warning.
This happens because of a wrong assumption in org.eclipse.jdt.internal.compiler.ast.QualifiedNameReference.checkInternalNPE(BlockScope, FlowContext, FlowInfo, boolean). The current binding being a field binding does not mean it is actually dereferenced.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061938</commentid>
    <comment_count>11</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-07 05:13:15 -0500</bug_when>
    <thetext>(In reply to comment #10)
&gt; (In reply to comment #9)
&gt; &gt; (8) A scenario which gives contradictory warnings
Fixed this and a related source range problem with commit 0b82fa47eb78f9f59638ad9671b3e2a9d9c28ff6</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061942</commentid>
    <comment_count>12</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-02-07 05:16:38 -0500</bug_when>
    <thetext>(In reply to comment #2)
&gt; Next, QNR#checkNPE was confusingly overloaded. -&gt; I renamed one version to
I don&apos;t understand this completely. checkNPE was being called from various places earlier. Now that part of the behavior is captured in checkInternalNPE(..), yet the other places continue to call checkNPE which now is a completely new method. Is this intended?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061948</commentid>
    <comment_count>13</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-07 05:31:36 -0500</bug_when>
    <thetext>(In reply to comment #6)

[...]

&gt; AFAICS this makes it feature complete and resolves the FIXMEs I still had in
&gt; the code.

I worry that the light at the end of the tunnel we spot could actually
be the headlamp of a fast approaching train :-(

https://bugs.eclipse.org/bugs/show_bug.cgi?id=369487#c18 offers 
the current feature as the remedy, but at least at a first glance
things appear to be getting murkier and messier with this fix.

Admittedly, I haven&apos;t studied the implementation fully and starting 
this thread after some minimal experimentation and could be wrong
(hope to be :)) - Apologies in advance if I have misunderstood some
thing. 

Borrowing Ayush&apos;s example from comment#3 (reproduced below)

// -----------------
public class X  {
    @Nullable Object o = new Object(); 
    public void main(String[] args, @Nullable X x1) {
        if (o != null) {
            o.toString();  // no warning
        }
        if (x1.o != null) {
            x1.o.toString();  // pot. NPE
        }
    }
}
// -------------------

Obviously this triggers https://bugs.eclipse.org/bugs/show_bug.cgi?id=370185
and results in the inconsistency Ayush has called out.

More direly, this warning should not be dismissed as &quot;inevitable&quot; 
because it appears that there is NOTHING that a user could do to 
act on this warning.

-- A null check guard in the form of &quot;if (x1.o != null)&quot; (already
   present) would not eliminate the warning.

-- An assignment of the form &quot;x1.o = new Object();&quot; just ahead of 
   the x1.o.toString(); wouldn&apos;t eliminate the warning.

-- An assignment of the form x1.o = someNonNullAnnotatedObject;
   ahead of the x1.o.toString(); wouldn&apos;t eliminate the warning.

In fact there is no code change that a programmer can do to address 
this  situation to eliminate this warning. These warnings are 
essentially non-actionable.

To understand how serious this situation is, let us agree on
some terminology.

(1) Let us call data accesses and method invocations of the form 
&quot;this.field.&quot; (with the terminal &apos;.&apos; included) as &quot;self field 
dereferences&quot;

and 

(2) Data accesses and method invocations of of the form &quot;that.field.&quot;
(with the terminal &apos;.&apos; included) where `that` is of the same type as 
`this` as &quot;alien field dereferences&quot;

and finally

(3) Data accesses and method invocations of of the form &quot;other.field.&quot;
(with the terminal &apos;.&apos; included) where `other` is NOT of the same 
type as `this` as &quot;alien ***type*** field dereferences&quot;

then for EVERY @Nullable annotated field f, EVERY alien field dereference
and EVERY alien type field dereference would produce a potential NPE
warning that is not addressable by a corresponding code change.

Where does that leave the user ?

Presented with such a situation, I fear that users turn off all 
potential null warnings (which would be very bad because most of
the fields related null warnings are potential warnings at the
moment, the stronger warnings we issue under limited situations
may also eventually have to be  downgraded to potential warnings
(see bug# 370787)). 

Or they would simply stop using this feature.

Chatting with a bunch of JDT coders in the hallway, this viewpoint
was heard that alien type object dereferences should really not
be an issue because fields should really be private and should
not be accessed outside the class. This is the same point already
heard in https://bugs.eclipse.org/bugs/show_bug.cgi?id=369487#c21
and as pointed out in that bug this standpoint ignores 
(a) currency/prevalence of the practice (b) Collaborating classes
within the same package allowing default access to each other&apos;s
data. Even if we were to accord *some* validity to that viewpoint,
the fact that we would emit a warning for every alien field 
dereference makes it unacceptable IMHO.

One further crucial difference:
https://bugs.eclipse.org/bugs/show_bug.cgi?id=369487#c21 was about a warning
that doesn&apos;t show up. The current
discussion is about a warning that shows up and won&apos;t go away.

There appears to be an ordering issue here: it is not clear to me
that until and unless we have a coherent story for
https://bugs.eclipse.org/bugs/show_bug.cgi?id=370185, we can solve the
current situation satisfactorily. That bug has a set of complexities
around aliases and concurrency, but we should be able to spell out a
set of stipulations that &quot;reasonable programmers would hold as being
reasonable&quot; and solve it within that framework and then consider this
one.

In short, IMHO the fix for bug 247564 was incomplete, self limiting, but
was internally consistent and not incorrect.

OTOH, the current story looks incorrect and incoherent to me. It has been
heard before that https://bugs.eclipse.org/bugs/show_bug.cgi?id=370185
is not solvable in the current release schedule. If that is so, we
should hold on the current work, till 3.9, notwithstanding the investment 
(emotion and/or industry-wise)

Let me know if I have misunderstood something here.

You may want to check what other frameworks do presented with this 
example.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061974</commentid>
    <comment_count>14</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-07 06:35:32 -0500</bug_when>
    <thetext>Srikanth,

Before I start answering you long post with an equally long answer,
let me quickly check the premise:

(In reply to comment #13)
&gt; In fact there is no code change that a programmer can do to address 
&gt; this  situation to eliminate this warning. These warnings are 
&gt; essentially non-actionable.

Quoting from bug 247564 comment 122:

&gt; Let me first try and correct all my typos from goo():
&gt;       @Nullable Object g;
&gt;       void goo() {
&gt;          g.toString(); // (d) warning
&gt;          if (g != null) g.toString(); // (e) weaker warning
&gt;          Object l;
&gt;          if ((l=this.g) != null) l.toString(); // (f) OK
&gt;       }
&gt; better?
&gt; 
&gt; Now, (e) is very well actionable: transform it into (f)!
&gt; Still we want to distinguish warning (e) from other warnings, because for
&gt; single thread apps this *is* a solution, so those folks should be able
&gt; to ignore just (e), while others should go all the way to (f).

Has this been included in your premise that the warning is non-actionable?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2061995</commentid>
    <comment_count>15</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-07 07:15:40 -0500</bug_when>
    <thetext>(In reply to comment #14)
&gt; Srikanth,
&gt; 
&gt; Before I start answering you long post with an equally long answer,
&gt; let me quickly check the premise:
&gt; 
&gt; (In reply to comment #13)
&gt; &gt; In fact there is no code change that a programmer can do to address 
&gt; &gt; this  situation to eliminate this warning. These warnings are 
&gt; &gt; essentially non-actionable.
&gt; 
&gt; Quoting from bug 247564 comment 122:

You are always ready with chapter and verse citation, aren&apos;t you ? :)
My memory is no match unfortunately. I did have a sense of dj vu,
but nothing more.

&gt; &gt;          if (g != null) g.toString(); // (e) weaker warning
&gt; &gt;          Object l;
&gt; &gt;          if ((l=this.g) != null) l.toString(); // (f) OK

&gt; Has this been included in your premise that the warning is non-actionable?

Obviously it hadn&apos;t been, otherwise I wouldn&apos;t have said there is 
&quot;no code change&quot;.

That being said, this proposed code transformation would not be
acceptable to many users I fear, and all concerns raised in previous
comment still bother me.

I do not see programmer&apos;s changing their code from:

    if (g != null) g.toString();

to

     Object l;
     if ((l=this.g) != null) l.toString();

:-(</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062096</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-07 10:08:23 -0500</bug_when>
    <thetext>(In reply to comment #11)
&gt; (In reply to comment #10)
&gt; &gt; (In reply to comment #9)
&gt; &gt; &gt; (8) A scenario which gives contradictory warnings
&gt; Fixed this and a related source range problem with commit
&gt; 0b82fa47eb78f9f59638ad9671b3e2a9d9c28ff6

The main fix is good, thanks. However, I don&apos;t see the source range problem.
To the contrary, with your change the following gives a strange result

   return other.other.o.toString()

----------
1. ERROR in X.java (at line 6)
	return other.other.o.toString();
	       ^^^^^
Potential null pointer access: The field other is declared as @Nullable
----------
2. ERROR in X.java (at line 6)
	return other.other.o.toString();
	       ^^^^^
Potential null pointer access: The field other is declared as @Nullable
----------

Without your change this was:

----------
1. ERROR in X.java (at line 6)
	return other.other.o.toString();
	       ^^^^^
Potential null pointer access: The field other is declared as @Nullable
----------
2. ERROR in X.java (at line 6)
	return other.other.o.toString();
	             ^^^^^
Potential null pointer access: The field other is declared as @Nullable
----------

Do you mind if I revert the source range part?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062178</commentid>
    <comment_count>17</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-07 11:21:13 -0500</bug_when>
    <thetext>(In reply to comment #8)
&gt; Is there a case when lines 5182-5186 in
&gt; org.eclipse.jdt.internal.compiler.problem.ProblemReporter.expressionNonNullComparison(Expression, boolean)
&gt; get triggered?

Hoping we are on the same line I see a breakpoint triggered by, e.g.,: testBug247564b() regarding &quot;if ((o == null))&quot;, where &apos;o&apos; is a static final field that has already been dereferenced in the same method.
More generally: all situations where we have definite null status for a field that has no @NonNull annotation.
Do you see anything fishy here?
 
&gt; Also, whats the needImplementation method for.

I have three calls to needImplementation(). Two of them are just defensive programming:
(a) a null literal was reported with null status NonNull!
(b) an unexpected expression type slipped into this method

Regarding the other one you just caught me on a TODO item that had escaped my attention.

&gt; Is it to handle cases such as [..]
&gt; if ( (o = b ? new Object(): new Object())== null)

Yes, that kind of thing. A slightly more realistic testcase and the
missing implementation are in commit d06dca3193608aaecf6a0ecc6e783a566d9a941e</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062190</commentid>
    <comment_count>18</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-07 11:32:49 -0500</bug_when>
    <thetext>(In reply to comment #11)
&gt; (In reply to comment #10)
&gt; &gt; (In reply to comment #9)
&gt; &gt; &gt; (8) A scenario which gives contradictory warnings
&gt; Fixed this and a related source range problem with commit
&gt; 0b82fa47eb78f9f59638ad9671b3e2a9d9c28ff6

While the main part of this fix is great, I reverted the source range part and added a test demonstrating why we should indeed respect the index into otherBinding for raising the problem at the correct location. 
This revert has been isolated into 1e74708f239861b45ea9c03fb332142e9b5b54a5 in case we need to re-revert :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062195</commentid>
    <comment_count>19</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-07 11:43:05 -0500</bug_when>
    <thetext>(In reply to comment #12)
&gt; (In reply to comment #2)
&gt; &gt; Next, QNR#checkNPE was confusingly overloaded. -&gt; I renamed one version to
&gt; I don&apos;t understand this completely. checkNPE was being called from various
&gt; places earlier. 

I tell you, beware of dangerous overloading!  :)
You probably mean this (introduced in Expression):
  checkNPE(BlockScope,FlowContext,FlowInfo)
while I&apos;m talking about this one (in QNR):
  checkNPE(BlockScope,FlowContext,FlowInfo,boolean)
(Should we add a compiler warning for overloading? :} )

In master the latter is called from exactly these two locations:
- QualifiedNameReference#analyseAssignment()
- QualifiedNameReference#analyseCode()

&gt; Now that part of the behavior is captured in
&gt; checkInternalNPE(..), yet the other places continue to call checkNPE which now
&gt; is a completely new method. Is this intended?

No change in behavior, pure renaming to avoid exactly this kind of confusion from now on :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062565</commentid>
    <comment_count>20</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-08 03:41:09 -0500</bug_when>
    <thetext>(In reply to comment #15)

&gt; &gt; &gt;          if (g != null) g.toString(); // (e) weaker warning
&gt; &gt; &gt;          Object l;
&gt; &gt; &gt;          if ((l=this.g) != null) l.toString(); // (f) OK
&gt; 
&gt; &gt; Has this been included in your premise that the warning is non-actionable?
&gt; 
&gt; Obviously it hadn&apos;t been, otherwise I wouldn&apos;t have said there is 
&gt; &quot;no code change&quot;.

&gt; That being said, this proposed code transformation would not be
&gt; acceptable to many users I fear, and all concerns raised in previous
&gt; comment still bother me.

A clarification: I am not opposed to extraction of field reference 
expression into local variable per se. So I amend my earlier comment
that these warnings are not actionable.

What I am saying users will reject is having to transform perfectly
valid code of the form:

        if (x1.o != null) {
            x1.o.toString();  // WRONG pot. NPE
        }     

        to

       Object l;
       if ((l=x1.o) != null) 
           l.toString();

just to eliminate a compiler warning their claim being their original 
code is perfect as it is and it is the compiler that is broken.

So eliminating this distraction around actionable/non-actionable 
warnings for the moment, I think in the following program, users
will declare the compiler broken in all 5 messages issued:

//----------------
import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;

class X {
    @Nullable Object o;
    public @NonNull Object foo(X x) {
    	// Puzzling message: Potential type mismatch: required &apos;@NonNull Object&apos; but nullness of the provided value is unknown
		return  x.o != null ? x.o : new Object();
	}
    public void goo(X x) {
    	if (x.o != null) {
    	    // Puzzling message : Potential null pointer access: The field o is declared as @Nullable
    		x.o.toString();
    	}
    }
    public void boo(X x) {
    	if (x.o instanceof String) {
    		// Puzzling message: Potential null pointer access: The field o is declared as @Nullable
    		x.o.toString();
    	}
    }
    public void zoo(X x) {
    	x.o = new Object();
    	// Puzzling message: Potential null pointer access: The field o is declared as @Nullable
    	System.out.println(&quot;hashCode of new Object = &quot; + x.o.hashCode());
    }
    public void doo(X x) {
    	x.o = foo(x); // foo is guaranteed to return @NonNull Object.
    	// Puzzling message: Potential null pointer access: The field o is declared as @Nullable
    	System.out.println(&quot;hashCode of new Object = &quot; + x.o.hashCode());
    }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062634</commentid>
    <comment_count>21</comment_count>
    <who name="Dani Megert">daniel_megert</who>
    <bug_when>2012-02-08 06:06:30 -0500</bug_when>
    <thetext>(In reply to comment #20)

I entirely agree. All those warnings are bad and make the compiler look dumb. If we can&apos;t be smarter, then no warnings must be issued for those cases.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2062782</commentid>
    <comment_count>22</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-08 10:50:10 -0500</bug_when>
    <thetext>Before we decide what exactly the compiler should answer to a given piece of code, I suggest we first think about the exact question we are asking the compiler.

IMHO, regarding null-safety for fields ways of looking at things differ too much. One-size-fits-all will at best give mediocre answers for everybody. If we allow users to ask different questions then they will get excellent answers. Initially I thought we might add tunability later, but I now think that would be a mistake.

For details I started a little write-up at http://wiki.eclipse.org/JDT_Core/Null_Analysis/Options - as always: comments appreciated.

Short version: for a sound analysis that respects concurrency (and side effects and aliasing) we must emit very strict warnings, that may look unnecessary at first (I just confirmed this with some academic contacts of mine). For projects with less bold expectations (expected to be the majority) pragmatic solutions must be found that soften (and reduce) the complaints raised by the compiler, but I&apos;d hate a lock in to this kind of compromise.

In the current implementation I first wanted to make sure that the analysis is precise enough to support all use cases. From here I don&apos;t see technical problems to offer also less pedantic modes (the opposite would be much more difficult).

The main open questions I see rank around how we communicate to users, what different levels of strictness mean. In this regard the wiki page only contains initial brainstorming. I will make a more specific proposal once I find the time.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063035</commentid>
    <comment_count>23</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-08 16:53:56 -0500</bug_when>
    <thetext>(In reply to comment #22)

The resolution of https://bugs.eclipse.org/bugs/show_bug.cgi?id=186342
has brought some very powerful and welcome analysis capabilities to JDT.
It is exciting to consider where/how this could be taken further along. 

However we seem to have hit a serious roadblock here.

(To paraphrase Markus Keller&apos;s assertion from bug# 186342 comment# 68:)
Eclipse/JDT (in its official avatar) is not an experimentation
field or a research sandbox in the lines of say, the SUIF compiler
suite. Work of exploratory nature ought to be carried out in a branch
and once the open questions are understood and problems are resolved
satisfactorily, we should evaluate the solution&apos;s readiness and
suitability for an industrial/production compiler that JDT is.

At the moment, the implementation as it stands triggers this circuit
breaker :-(

A few observations:

(1) While debating the design issues in bug 369487, I somehow did not
get the sense that you were philosophically opposed to foreign
fields analysis or to integrating flow analysis outcome with field
annotations, but the wiki write up seems to convey that impression.
If so, the analysis out of bug 247564 will not dovetail into the
current work and inconsistencies will persist (unless users are
willing to significantly change their coding style and current code
base to conform to a set of guidelines)

(2) While your point about one-size-fits-all approach is valid, the
current implementation cannot be absolved of that very charge ? It
seems to careen towards the pedantic end. I grant you that, this is
not the envisioned end state and you are considering addressing the
needs of more pragmatic use case scenarios.

But only after the contours of such a solution become available for
inspection, can we then assess release readiness.

&gt;  I will make a more specific proposal once I find the
&gt; time.

Thanks for that offer. This is indeed a complex problem with many
open questions most certainly worthy of tackling.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063055</commentid>
    <comment_count>24</comment_count>
    <who name="Reuben Garrett">ReubenGarrett</who>
    <bug_when>2012-02-08 17:19:18 -0500</bug_when>
    <thetext>Although I&apos;m not yet skilled enough to contribute directly to this feature&apos;s implementation, I see enormous potential in null contract analysis and want to express my support.  Even if we must fork a strategic retreat to a new branch, it would be worthwhile towards the attainment of stricter pre- and post-condition enforcement than the language itself provides.  

At the risk of betraying my navet - is it not possible (with eclipse being rooted in OSGI) to contribute this and other supplemental analyses as separate plugins, obviating the need to integrate directly into the JDT core?  If not already possible, it would be neat to be able to derive new compilers at run-time by attaching decorative analysis plugins.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063112</commentid>
    <comment_count>25</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-08 19:51:39 -0500</bug_when>
    <thetext>Dear Reuben,

Many thanks for your offer! 

I do see a field where help is welcome. Actually this doesn&apos;t necessarily include coding.

In my private own view we have three essential ingredients already in place:

- An understanding of an optimistic model, where fields are analysed just like locals, which will give only expected warnings, but will miss to report many errors that are caused by aliasing, side effects and concurrency.

- An understanding of a pessimistic model, that reflects that every dereference of a @Nullable field is in fact unsafe under certain conditions, but this model produces more warnings than most people would like to see.

- An implementation that can be parameterized to conform to either the optimistic, or the pessimistic model, and probably also to a good number of compromises between both extremes.

The thing that most urgently needs being worked out, IMHO, is a definition, *where* between the two extremes people would like to see the analysis.

Technically, most of this can be explained using this example:

Given a nullable field:

  @Nullable Object o;

How would you like the compiler to respond in the following cases:

  (a):
  o.toString();

  (b):
  if (o != null) o.toString();

  (c):
  double v = 0.3, w = 1.2;
  if (o != null) {
      for (int i = 0; i &lt; Integer.MAX_VALUE; i++) v = v/w+w/v;
      o.toString();
  }
  System.out.println(v);

  (d):
  if (o != null) {
      otherObject.foo();
      o.toString();
  }

  (e):
  Object l = o;
  if (l != null) l.toString();
 
  (f):
  if (o != null) {
       otherObject.o = null;
       o.toString();
  }

The extreme positions are:
- only (a) is problematic, compiler should warn (only) here
- only (e) is safe, compiler should report all others

We could now give technical explanations describing exactly what risks remain if certain examples other than (e) are silently accepted. Also this level is clear.  But perhaps we can give more help to users if we define 2 or 3 &quot;profiles&quot; / &quot;safety levels&quot; that can be explained with few words. The difficulty lies in aligning a useful level of warnings with the users&apos; expectations.

You might also have a look at http://wiki.eclipse.org/JDT_Core/Null_Analysis/Options
for some background on the individual risks involved in these examples (you may skip the section on incompleteness, though).

The question is: which warnings would you be interested in? And how would you describe your safety requirements?

Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063117</commentid>
    <comment_count>26</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-08 20:08:52 -0500</bug_when>
    <thetext>(In reply to comment #24)
&gt; Although I&apos;m not yet skilled enough to contribute directly to this feature&apos;s
&gt; implementation, I see enormous potential in null contract analysis and want to
&gt; express my support.  Even if we must fork a strategic retreat to a new branch,
&gt; it would be worthwhile towards the attainment of stricter pre- and
&gt; post-condition enforcement than the language itself provides.

Thanks for the feedback. Ideally, we would like to and hoping to be able to
deliver this right in the standard Eclipse SDK, so the analysis becomes 
available right out of the box. We re figuring out what course corrections 
are required to achieve that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063119</commentid>
    <comment_count>27</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-02-08 20:14:58 -0500</bug_when>
    <thetext>On a different road there might be an easy way out of the currently perceived dilemma: when discussing this with Markus at EclipseCon Europe, we decided to ignore all proposals of specific annotations for fields, because the need wasn&apos;t clear.

Judging from today&apos;s perspective, fields do pose more of a problem than what we touched in that discussion.

OTOH, all research in this field seems to converge in one observation: a large number of problematic fields can be efficiently tamed by specifying monotonic semantics: such a field may start with a null value but once assigned nonnull it can never be reset to null again. Analysis of this kind of fields is actually easy. From a user perspective: one null check per field and enclosing method suffices:
   void foo() {
      if (this.o != null) {
          // arbitrary code here
          this.o.toString();
      }
   }
With such monotonic semantics this code is 100% safe (in a program fully checked against its specification).

Some annotation names used by different research groups are:
   @MonoNonNull
   @EventuallyNonNull
   @LazyNonNull

In one study covering 700 MLOC of code it was found that this annotation would solve the problem of about half of the nullable fields (given that nonnull fields pose no problem anyway).

While also other models have been discussed in the literature, there&apos;s a broad consensus on the semantics and also usefulness of this model of monotonicity.

I&apos;m open to pursuing either road (or both): one that tries to match user expectations by one or more suitable compromises between the two extremes mentioned previously - or - one that leverages one more annotation for making fields amenable to flow analysis with neither flooding the user with uninteresting warnings nor sweeping potential bugs under the rug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2063150</commentid>
    <comment_count>28</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-08 22:58:38 -0500</bug_when>
    <thetext>(In reply to comment #25)

&gt; clear.  But perhaps we can give more help to users if we define 2 or 3
&gt; &quot;profiles&quot; / &quot;safety levels&quot; that can be explained with few words.

The notion that there is a continuum of user personas with differing needs
appears sound and so we need to think of configurability/tuning options
to accommodate those disparate needs.

The set of examples cases you have constructed make for a great starting 
point in understanding this. Support for well crafted profiles would ground
this effort solidly in practical applicability and ameliorate the concerns
I had articulated earlier (some times in dramatic/melodramatic terms if only,
to  convey a sense of urgency).

Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2066723</commentid>
    <comment_count>29</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-02-16 08:49:06 -0500</bug_when>
    <thetext>Since the JDT team members are not conveniently co-located,
we held &quot;virtual design meetings&quot; to discuss and debate
the various issues involved in developing this capability.

At the moment, it is clear that a solution that is general enough
to accommodate the various view points is not feasible in the 3.8
time frame and eliminating delivery pressures would be a good step
to the eventual solution of this problem.

I&apos;ll summarize the key points discussed internally and post it
here shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2076318</commentid>
    <comment_count>30</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-03-06 23:22:53 -0500</bug_when>
    <thetext>We discussed the design issues in detail and concluded that we need to
support both an &quot;optimistic model&quot; and a &quot;pessimistic model&quot; with these
characteristics:

Optimistic model:

This model operates under the following stipulations:

(a) The analysis is unaware of any modifications that happen via
    aliases.
(b) The analysis is unaware of any modifications that happen in
    other concurrently executing threads.
(c) Since the flow analysis is intra-procedural in nature, the
    compiler is unaware of what modifications could be made in
    a method call. So the compiler adopts a conservative approach
    and this may result in potential warnings that a human could
    readily ascertain to be false positives via code inspection.
(d) Absence of a warning does not imply absence of NPE.

A pessimistic model: 

(a) nullable fields could be completely excluded from any flow analysis.
(b) Every dereference of such a nullable field will be flagged as dangerous
(c) For all examples in comment 25 except (e) (transfer to a local
  variable before access) a context can be constructed that actually
  triggers NPE on the field, even after the null check
(d) this model will raise many warnings that many people will perceive
  as unjustified.
(e) BUT this model is strong enough to give positive guarantees about absence
    of NPE.

We are exploring what it would take to support both models so users
can pick &amp; choose the level of safety they desire in their code base.
Both models could turn out to be too extreme in practice, so we may 
have to introduce more annotations like the one from comment 27.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125182</commentid>
    <comment_count>31</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-16 10:42:02 -0400</bug_when>
    <thetext>Removing dependency on bug 247564 because I&apos;m currently cooking a patch
that handles null-annotated fields without any flow analysis for fields.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125195</commentid>
    <comment_count>32</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-16 12:52:22 -0400</bug_when>
    <thetext>I have pushed a new topic branch sherrmann/NullAnnotationsForFields2 [1] 
for take 2 regarding this RFE.

The topic branch currently has two commits:

1: a slice from the former sherrmann/NullAnnotationsForFields without any
   flow analysis for fields (which means the entire infra structure for 
   squeezing field IDs into the null analysis is not needed).
   This slice purely implements the pessimistic model.

2: a fix for Bug 382789 (which previously was a &quot;hidden&quot; part of the patch.

Plus some small improvements of the patch here and there. I&apos;m happy to report
that this patch is much less complex than the previous combined approach.

All JDT/Core tests are green.



This is basically what I&apos;m planning to put into the experimental patch feature
for public consumption.


I might want to add to this (time permitting):

+ Special case detection of &quot;if (f != null) f.op();&quot;, i.e., null-check
  *immediately* followed be a dereference. This is the easiest compromise
  I can think of for avoiding almost-irrelevant warnings regarding fields
  that are not @NonNull. This detection would be off by default but exposed
  as a preference. (I already made an experiment in this direction, just
  have to find the patch :) ).

+ Maybe I&apos;ll even add a quick fix for extracting to a new local variable
  plus a null check. Not sure to what extent I could re-use the 
  &quot;extract to local&quot; refactoring here. Any hints appreciated.


A few questions when moving towards deployment:

- Am I required to add disclaimers to the source code or is it sufficient
  to mark the download accordingly?

- Since we don&apos;t have a central build ready for this branch, is it OK
  to simply export from the IDE?

- When preparing a patch feature for deployment, should this project be
  pushed to git, too? Anything to observe in order not to confuse the SDK
  build etc?

- Who should I talk to regarding the final upload?

[1] http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/log/?h=sherrmann/NullAnnotationsForFields2</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125209</commentid>
    <comment_count>33</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-16 21:14:11 -0400</bug_when>
    <thetext>(In reply to comment #32)
&gt; + Maybe I&apos;ll even add a quick fix for extracting to a new local variable
&gt;   plus a null check.

I&apos;ve attached a patch with a new quickfix in bug 337977 comment 18.
I guess that&apos;s about it for now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125310</commentid>
    <comment_count>34</comment_count>
    <who name="Dani Megert">daniel_megert</who>
    <bug_when>2012-06-18 03:04:30 -0400</bug_when>
    <thetext>(In reply to comment #32)
&gt; A few questions when moving towards deployment:
&gt; 
&gt; - Am I required to add disclaimers to the source code or is it sufficient
&gt;   to mark the download accordingly?
Marking it on the download page should be enough, though we are not speaking about the &quot;official&quot; download page here.

&gt; - Since we don&apos;t have a central build ready for this branch, is it OK
&gt;   to simply export from the IDE?
You would have to create a feature patch.

&gt; - When preparing a patch feature for deployment, should this project be
&gt;   pushed to git, too?
No, I would not add the feature patch to the repo a this point.


&gt; Anything to observe in order not to confuse the SDK build etc?
As along as all your work stays in your branch there&apos;s nothing to worry. Or did you have something special in mind?


&gt; - Who should I talk to regarding the final upload?
I assume this will be added to this Wiki page: http://wiki.eclipse.org/JDT_Core/Null_Analysis/Options
I don&apos;t expect this to appear on any official download page at this point.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125470</commentid>
    <comment_count>35</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-18 09:48:31 -0400</bug_when>
    <thetext>I test drove the patch and everything seems to be ok. I guess you chose to omit the null analysis for fields because of the inconsistency between fields of &apos;this&apos; and alien references. However, this solution also has its own inconsistencies.
&gt; + Special case detection of &quot;if (f != null) f.op();&quot;, i.e., null-check
&gt;   *immediately* followed be a dereference. This is the easiest compromise
&gt;   I can think of for avoiding almost-irrelevant warnings regarding fields
&gt;   that are not @NonNull. This detection would be off by default but exposed
&gt;   as a preference. (I already made an experiment in this direction, just
&gt;   have to find the patch :) ).
So, the patch works well for @NonNull annotated fields but for @Nullable the analysis will be weak right? OIOW, even if i initialize a field to a non-null value, I will still see potential NPE warnings on each dereference?

Also in cases such as these:
	@Nullable Object foo = new Object();
	
	void goo(@org.eclipse.jdt.annotation.NonNull Object o, @org.eclipse.jdt.annotation.Nullable Object o2) {
		this.foo = new Object();
		o2 = new Object();
		o = o2;  // no warning here
		o = this.foo;  // warning here
	}

The story for fields and locals is becoming a bit inconsistent. Can&apos;t we just use the patch that we earlier reverted?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125500</commentid>
    <comment_count>36</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-18 10:38:42 -0400</bug_when>
    <thetext>(In reply to comment #35)
&gt; I test drove the patch and everything seems to be ok.

Thanks!

&gt; I guess you chose to omit
&gt; the null analysis for fields because of the inconsistency between fields of
&gt; &apos;this&apos; and alien references. However, this solution also has its own
&gt; inconsistencies.
&gt; &gt; + Special case detection of &quot;if (f != null) f.op();&quot;, i.e., null-check
&gt; &gt;   *immediately* followed be a dereference. This is the easiest compromise
&gt; &gt;   I can think of for avoiding almost-irrelevant warnings regarding fields
&gt; &gt;   that are not @NonNull. This detection would be off by default but exposed
&gt; &gt;   as a preference. (I already made an experiment in this direction, just
&gt; &gt;   have to find the patch :) ).
&gt; So, the patch works well for @NonNull annotated fields but for @Nullable the
&gt; analysis will be weak right? OIOW, even if i initialize a field to a non-null
&gt; value, I will still see potential NPE warnings on each dereference?

Exactly. You call it weak, I call the model pessimistic and emphasized that
I&apos;m not doing *any* flow analysis for fields, in the hope to be very clear.
(Should I omit the above mentioned special case in order not to blur the
picture?)

&gt; Also in cases such as these:
&gt;     @Nullable Object foo = new Object();

This initializer doesn&apos;t help any, right?
 
&gt;     void goo(@org.eclipse.jdt.annotation.NonNull Object o,
&gt; @org.eclipse.jdt.annotation.Nullable Object o2) {
&gt;         this.foo = new Object();
&gt;         o2 = new Object();
&gt;         o = o2;  // no warning here
&gt;         o = this.foo;  // warning here
&gt;     }

We *have* to make a difference, because for non-trivial examples we have 
no idea if foo still holds a valid reference when dereferenced.
And currently we don&apos;t have the means to distinguish trivial from
non-trivial situations in this regard.

However, this reminds me that I was thinking of including final fields
with an immediate non-null initializer. We could classify those as
&quot;effectively non-null&quot; and spare the user the need to declare so.
What do you think? My experience says this would significantly alleviate
the effort, and it should be really simple to add - and communicate.

&gt; The story for fields and locals is becoming a bit inconsistent.

IMO, it only reflects: locals are different from fields in general
(the former are solely controlled by the current method, the latter are not).
Since we currenlty can&apos;t go all the way to perfect analysis of all 
variable references, we do have to draw a line somewhere. Could there be
a clearer line than saying: &quot;We never perform flow analysis for fields&quot;?
Where do you suggest to draw the line?

&gt; Can&apos;t we just use the patch that we earlier reverted?

Sure can, but I personally prefer not do so. Aside from all the open issues
regarding that patch I think publishing the minimalistic / pessimistic
analysis now can give us valuable feedback to a very clear-cut question:

  &quot;Do we need flow analysis for fields or is assignment to local a tolerable
  and effective means to avoid the entire battle?&quot;


If we&apos;d go to the other patch with flow analysis, what would be the
research question? I mean this work is classified as experimental, so
let&apos;s just do the experiment with the most interesting hypothesis, OK?


My today&apos;s feeling says: flow analysis for fields may be most useful in
scenarios *without* null annotations.

*With* those annotations I&apos;m really curious how far we get with a 
black-and-white model:

@NonNull fields are good! We can check both relevant risks: missing initialization and assignment from null. No warning means: you&apos;re safe!

@Nullable fields are dangerous! If you want to do real work with such a
field *always* fetch a copy into a local variable and from there on
our flow analysis is safe.

After deploying this solution, if users convince us that this is not a good
model, we&apos;ll have gained very valuable information towards the next release.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125505</commentid>
    <comment_count>37</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-18 10:50:39 -0400</bug_when>
    <thetext>(In reply to comment #34)
&gt; (In reply to comment #32)
&gt; &gt; A few questions when moving towards deployment:
&gt; &gt; 
&gt; &gt; - Am I required to add disclaimers to the source code or is it sufficient
&gt; &gt;   to mark the download accordingly?
&gt; Marking it on the download page should be enough, though we are not speaking
&gt; about the &quot;official&quot; download page here.

Good, thanks.

&gt; &gt; - Since we don&apos;t have a central build ready for this branch, is it OK
&gt; &gt;   to simply export from the IDE?
&gt; You would have to create a feature patch.

Sure. I&apos;ll assume this is a &quot;yes&quot; to &quot;export from the IDE?&quot; :)
 
&gt; &gt; - When preparing a patch feature for deployment, should this project be
&gt; &gt;   pushed to git, too?
&gt; No, I would not add the feature patch to the repo a this point.

OK, I&apos;ll post the patch feature to this bug for review, then.
 
&gt; &gt; Anything to observe in order not to confuse the SDK build etc?
&gt; As along as all your work stays in your branch there&apos;s nothing to worry. Or did
&gt; you have something special in mind?

I was asking just for the case when I would push the patch feature to git.
The question is obsolte now.
 
&gt; &gt; - Who should I talk to regarding the final upload?
&gt; I assume this will be added to this Wiki page:
&gt; http://wiki.eclipse.org/JDT_Core/Null_Analysis/Options
&gt; I don&apos;t expect this to appear on any official download page at this point.

Alright, and comparing to the Java7 patch feature this all may boild down
to the request to get write access to some directory below 
/shared/eclipse on build.eclipse.org if that&apos;s OK?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125513</commentid>
    <comment_count>38</comment_count>
    <who name="Dani Megert">daniel_megert</who>
    <bug_when>2012-06-18 11:04:51 -0400</bug_when>
    <thetext>(In reply to comment #37)
&gt; Alright, and comparing to the Java7 patch feature this all may boild down
&gt; to the request to get write access to some directory below 
&gt; /shared/eclipse on build.eclipse.org if that&apos;s OK?

I don&apos;t like to see people doing stuff on the server (aka shell access). We can put the bits into the JDT Core web site like we did with patches:

CVS root: eclipse.org 
path: www/jdt/core/&lt;someFolder&gt;

This will end up at:
http://www.eclipse.org/jdt/core/&lt;someFolder&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2125562</commentid>
    <comment_count>39</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-18 12:53:31 -0400</bug_when>
    <thetext>(In reply to comment #36)
&gt; [..]
&gt; Exactly. You call it weak, I call the model pessimistic and emphasized that
&gt; I&apos;m not doing *any* flow analysis for fields, in the hope to be very clear.
&gt; (Should I omit the above mentioned special case in order not to blur the
&gt; picture?)
Is this special case already in the branch? I assumed its not in yet. I think its ok to have this for now because its annoying for a user to get a warning immediately after he puts a null check.

&gt; &gt; Also in cases such as these:
&gt; &gt;     @Nullable Object foo = new Object();
&gt; 
&gt; This initializer doesn&apos;t help any, right?
&gt; 
&gt; &gt;     void goo(@org.eclipse.jdt.annotation.NonNull Object o,
&gt; &gt; @org.eclipse.jdt.annotation.Nullable Object o2) {
&gt; &gt;         this.foo = new Object();
&gt; &gt;         o2 = new Object();
&gt; &gt;         o = o2;  // no warning here
&gt; &gt;         o = this.foo;  // warning here
&gt; &gt;     }
&gt; 
&gt; We *have* to make a difference, because for non-trivial examples we have 
&gt; no idea if foo still holds a valid reference when dereferenced.
&gt; And currently we don&apos;t have the means to distinguish trivial from
&gt; non-trivial situations in this regard.
&gt; 
&gt; However, this reminds me that I was thinking of including final fields
&gt; with an immediate non-null initializer. We could classify those as
&gt; &quot;effectively non-null&quot; and spare the user the need to declare so.
&gt; What do you think? My experience says this would significantly alleviate
&gt; the effort, and it should be really simple to add - and communicate.
Yeah, that will certainly be valuable!
 
&gt; &gt; The story for fields and locals is becoming a bit inconsistent.
&gt; 
&gt; IMO, it only reflects: locals are different from fields in general
&gt; (the former are solely controlled by the current method, the latter are not).
&gt; Since we currenlty can&apos;t go all the way to perfect analysis of all 
&gt; variable references, we do have to draw a line somewhere. Could there be
&gt; a clearer line than saying: &quot;We never perform flow analysis for fields&quot;?
&gt; Where do you suggest to draw the line?
I&apos;m ok as long as the messaging is correct. We don&apos;t want the users to be expecting &quot;analysis&quot; for fields but only diagnostics that result out of manually inserted annotations. And nothing changes these annotations for fields, which is unlike local variables where even a Nullable variable can be made not null by assignment. So, even null annotations for fields and variables behave a bit differently and we clearly need to spell out it.

&gt; &gt; Can&apos;t we just use the patch that we earlier reverted?
&gt; 
&gt; Sure can, but I personally prefer not do so. Aside from all the open issues
&gt; regarding that patch I think publishing the minimalistic / pessimistic
&gt; analysis now can give us valuable feedback to a very clear-cut question:
&gt; 
&gt;   &quot;Do we need flow analysis for fields or is assignment to local a tolerable
&gt;   and effective means to avoid the entire battle?&quot;
&gt; 
&gt; 
&gt; If we&apos;d go to the other patch with flow analysis, what would be the
&gt; research question? I mean this work is classified as experimental, so
&gt; let&apos;s just do the experiment with the most interesting hypothesis, OK?
&gt; 
&gt; 
&gt; My today&apos;s feeling says: flow analysis for fields may be most useful in
&gt; scenarios *without* null annotations.
&gt; 
&gt; *With* those annotations I&apos;m really curious how far we get with a 
&gt; black-and-white model:
&gt; 
&gt; @NonNull fields are good! We can check both relevant risks: missing
&gt; initialization and assignment from null. No warning means: you&apos;re safe!
&gt; 
&gt; @Nullable fields are dangerous! If you want to do real work with such a
&gt; field *always* fetch a copy into a local variable and from there on
&gt; our flow analysis is safe.
Yup, I guess we&apos;ve already discussed these things at length so thats fine by me. I just mentioned the reverted patch because I think it adds to the analysis and as we saw earlier, gives helpful warnings in a lot of cases. So even when a user has not moved to null annotations, null analysis for fields can be switched on to clean up the code.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128340</commentid>
    <comment_count>40</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-23 11:06:05 -0400</bug_when>
    <thetext>(In reply to comment #32)
&gt; I might want to add to this (time permitting):
&gt; 
&gt; + Special case detection of &quot;if (f != null) f.op();&quot;, i.e., null-check
&gt;   *immediately* followed be a dereference. This is the easiest compromise
&gt;   I can think of for avoiding almost-irrelevant warnings regarding fields
&gt;   that are not @NonNull. This detection would be off by default but exposed
&gt;   as a preference. (I already made an experiment in this direction, just
&gt;   have to find the patch :) ).

I&apos;ve filed Bug 383368 for this part. A patch (tests &amp; impl) has been pushed 
to the topic branch. The patch actually covers quite a range of patterns.

I&apos;m quite happy about separating these issues as &quot;syntactic analysis&quot;
from the proper flow analysis. It keeps the impl simpler (I believe)
and allows us to communicate to users: &quot;flow analysis is always exact,
but you may tell the compiler to filter errors/warnings by recognizing some
syntactic patterns that are less dangerous than other null errors/warnings&quot;.
This does not imply any guarantee that recognition of syntactic patterns will
be complete in any sense. Extract to local variable is still preferable.

Ayush, do you have some minutes for reviewing this for inclusion in the
patch feature?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128351</commentid>
    <comment_count>41</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-23 16:25:59 -0400</bug_when>
    <thetext>(In reply to comment #39)
&gt; (In reply to comment #36)
&gt; &gt; However, this reminds me that I was thinking of including final fields
&gt; &gt; with an immediate non-null initializer. We could classify those as
&gt; &gt; &quot;effectively non-null&quot; and spare the user the need to declare so.
&gt; &gt; What do you think? My experience says this would significantly alleviate
&gt; &gt; the effort, and it should be really simple to add - and communicate.
&gt; Yeah, that will certainly be valuable!

That&apos;s commit 5f4383ced9e2f64f3e8c52f26352af8d9ae159b9 in the topic branch.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128355</commentid>
    <comment_count>42</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-23 18:11:47 -0400</bug_when>
    <thetext>I have a release candidate available at this update-site:
  http://build.eclipse.org/tools/objectteams/beta-null-annotations-for-fields

Feature version is 0.7.0.201206232329

It supports everything listed on 
  http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta

Plugins are branched off the Juno release with these additions:
For the JDT/Core side everything can be seen in the topic branch.
For the JDT/UI part it contains these patches:
  bug 337977 comment 20 (update existing quick fixes)
  bug 337977 comment 18 (new quickfix: extract to null-checked local)
  bug 383368 comment 3 (preferences UI)
  

If no serious issues are found I&apos;d like to publish this on Juno-day.
Or do we need a couple more days for reviews?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128441</commentid>
    <comment_count>43</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-25 01:55:27 -0400</bug_when>
    <thetext>Marking as null beta to indicate availability on the feature patch and not on master</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128456</commentid>
    <comment_count>44</comment_count>
    <who name="Dani Megert">daniel_megert</who>
    <bug_when>2012-06-25 02:30:07 -0400</bug_when>
    <thetext>(In reply to comment #42)
&gt; I have a release candidate available at this update-site:
&gt;   http://build.eclipse.org/tools/objectteams/beta-null-annotations-for-fields

I know you posted that URL in our e-mail conversation, where it said &quot;preview&quot; and I didn&apos;t jump on it. But when I now look at it, it looks wrong to me to have a pure JDT Core/UI prototype served via http://build.eclipse.org/tools/objectteams. This is misleading for users, given this is a JDT prototype that will hopefully be included in JDT in the future. If possible it should be at a JDT Core location (e.g. in /cvsroot/org.eclipse /www/jdt/code/...).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128457</commentid>
    <comment_count>45</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-25 02:39:02 -0400</bug_when>
    <thetext>(In reply to comment #44)
&gt; (In reply to comment #42)
&gt; &gt; I have a release candidate available at this update-site:
&gt; &gt;   http://build.eclipse.org/tools/objectteams/beta-null-annotations-for-fields
&gt; 
&gt; I know you posted that URL in our e-mail conversation, where it said &quot;preview&quot;
&gt; and I didn&apos;t jump on it. But when I now look at it, it looks wrong to me to
&gt; have a pure JDT Core/UI prototype served via
&gt; http://build.eclipse.org/tools/objectteams. This is misleading for users, given
&gt; this is a JDT prototype that will hopefully be included in JDT in the future.
&gt; If possible it should be at a JDT Core location (e.g. in /cvsroot/org.eclipse
&gt; /www/jdt/code/...).

Yes, we will publish a link &lt;http://www.eclipse.org/jdt/core/to_be_determined&gt; as mentioned in http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2128702</commentid>
    <comment_count>46</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-25 11:15:46 -0400</bug_when>
    <thetext>(In reply to comment #45)
&gt; (In reply to comment #44)
&gt; &gt; (In reply to comment #42)
&gt; &gt; &gt; I have a release candidate available at this update-site:
&gt; &gt; &gt;   http://build.eclipse.org/tools/objectteams/beta-null-annotations-for-fields
&gt; &gt; 
&gt; &gt; I know you posted that URL in our e-mail conversation, where it said &quot;preview&quot;
&gt; &gt; and I didn&apos;t jump on it. But when I now look at it, it looks wrong to me to
&gt; &gt; have a pure JDT Core/UI prototype served via
&gt; &gt; http://build.eclipse.org/tools/objectteams. This is misleading for users, given
&gt; &gt; this is a JDT prototype that will hopefully be included in JDT in the future.
&gt; &gt; If possible it should be at a JDT Core location (e.g. in /cvsroot/org.eclipse
&gt; &gt; /www/jdt/code/...).
&gt; 
&gt; Yes, we will publish a link &lt;http://www.eclipse.org/jdt/core/to_be_determined&gt;
&gt; as mentioned in http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta

My intention exactly! :)

Would it be a release *candidate* if I published it at the final location?
Also, I don&apos;t want to spam the CVS with unnecessary versions of binary files.
I will remove the preview/release candidate as soon as the final beta
will be published (using the objectteams location now only for convenience
because that&apos;s where I have direct write access).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129693</commentid>
    <comment_count>47</comment_count>
      <attachid>217931</attachid>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-27 09:33:33 -0400</bug_when>
    <thetext>Created attachment 217931
project to show minor problems in null annotation beta support

(In reply to comment #42)
&gt; I have a release candidate available at this update-site:
&gt;   http://build.eclipse.org/tools/objectteams/beta-null-annotations-for-fields
&gt; [..]
&gt; If no serious issues are found I&apos;d like to publish this on Juno-day.
&gt; Or do we need a couple more days for reviews?

I tested this on a fresh RC4 installation and seems to work fine. Only a few minor issues as pointed out by comments in Test.java in attached project. They should be easy to fix but even if they aren&apos;t, it should be ok to wait a couple of days to fix these before we publish the link. Is the exception thrown on the quick fix because UI changes haven&apos;t gone in?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129734</commentid>
    <comment_count>48</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 10:12:53 -0400</bug_when>
    <thetext>(In reply to comment #47)
&gt; I tested this on a fresh RC4 installation and seems to work fine. Only a few
&gt; minor issues as pointed out by comments in Test.java in attached project. They
&gt; should be easy to fix but even if they aren&apos;t, it should be ok to wait a couple
&gt; of days to fix these before we publish the link. Is the exception thrown on the
&gt; quick fix because UI changes haven&apos;t gone in?

Thanks for testing!

Three of the issues you recorded relate to
   if (f == null) ...
According to http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta#Syntactic_analysis
this syntactic analysis only recognizes &quot;!= null&quot; not &quot;== null&quot;.
The former is important to allow dereferencing any nullable field.
Do you see a strong reason why also recognizing &quot;== null&quot; would be important?
We get an error anyway, right? Isn&apos;t that enough?

IOW, I intend syntactic analysis only for avoiding essentially uninteresting
errors/warnings - to become less pessimistic, not for reporting stronger
errors. Any objections?

Regarding this snippet:
	if (this.abc2 == o2) {
		return this.abc2;		// isn&apos;t this the same as this.abc2 == null? We shouldn&apos;t get an error here, no?
	}
is there some typo involved? o2 is declared @NonNull.
I guess you mean it should be equivalent to &quot;this.abc2 != null&quot;, right ?


The other issues I will have to investigate on my other machine later today.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129852</commentid>
    <comment_count>49</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-27 13:19:13 -0400</bug_when>
    <thetext>(In reply to comment #48)
&gt; [..]
&gt; 
&gt; Thanks for testing!
&gt; 
&gt; Three of the issues you recorded relate to
&gt;    if (f == null) ...
&gt; According to
&gt; http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta#Syntactic_analysis
&gt; this syntactic analysis only recognizes &quot;!= null&quot; not &quot;== null&quot;.
&gt; The former is important to allow dereferencing any nullable field.
&gt; Do you see a strong reason why also recognizing &quot;== null&quot; would be important?
&gt; We get an error anyway, right? Isn&apos;t that enough?
I see your point. I thought you must&apos;ve added some code for EqualExpression to support this special case so was surprised that it did not work for != . So, i&apos;m ok with what is currently supported, since nobody dereferences a variable that they just compared to null in the previous line anyway. :)
 
&gt; Regarding this snippet:
&gt;     if (this.abc2 == o2) {
&gt;         return this.abc2;        // isn&apos;t this the same as this.abc2 == null?
&gt; We shouldn&apos;t get an error here, no?
&gt;     }
&gt; is there some typo involved? o2 is declared @NonNull.
&gt; I guess you mean it should be equivalent to &quot;this.abc2 != null&quot;, right ?
Yeah, that&apos;s what I meant. :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129883</commentid>
    <comment_count>50</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 14:38:03 -0400</bug_when>
    <thetext>The test class has this line:

	@NonNull public Object abc;		// when this is static the error comes at this location instead of on the class declaration. Should always be reported on the same location, no?


I had to recheck, but this is indeed the same behavior as for final fields:
uninitialized static final is reported against the class, non-static 
against the field. Perhaps we should align locations in all cases?
For now, which consistency is more important:
- treat @NonNull like final
- treat @NonNull static like @NonNull non-static?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129894</commentid>
    <comment_count>51</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-27 14:56:40 -0400</bug_when>
    <thetext>(In reply to comment #50)
&gt; against the field. Perhaps we should align locations in all cases?
&gt; For now, which consistency is more important:
&gt; - treat @NonNull like final
&gt; - treat @NonNull static like @NonNull non-static?
Can&apos;t all of them be reported against either the class or the individual field? My concern is not so much about the warning being at 2 different places for 2 different cases but about the precarious situation that arises when the 2 are mixed (eg. one field static other non-static). For one field, we complain on the class and for another we complain on the field. This is a bit weird.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129896</commentid>
    <comment_count>52</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 15:01:10 -0400</bug_when>
    <thetext>(In reply to comment #51)
&gt; (In reply to comment #50)
&gt; &gt; against the field. Perhaps we should align locations in all cases?
&gt; &gt; For now, which consistency is more important:
&gt; &gt; - treat @NonNull like final
&gt; &gt; - treat @NonNull static like @NonNull non-static?
&gt; Can&apos;t all of them be reported against either the class or the individual field?

They can, that&apos;s what I meant by:
&gt; &gt; Perhaps we should align locations in all cases?
But should I really change the implementation for final fields on behalf of 
this current bug and for the patch feature?

&gt; My concern is not so much about the warning being at 2 different places for 2
&gt; different cases but about the precarious situation that arises when the 2 are
&gt; mixed (eg. one field static other non-static). For one field, we complain on
&gt; the class and for another we complain on the field. This is a bit weird.

agree. 
The same holds for mixing uninitialized final fields (static &amp; non-static).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129926</commentid>
    <comment_count>53</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 15:38:57 -0400</bug_when>
    <thetext>&gt; 		this.abc = o;	// incorrect quick fix, throws exception

Thanks for the test case!
This is a simple demonstration of why we need tests for those quick fixes.
The existing logic just didn&apos;t properly distinguish all possible cases.
I&apos;m working on some tests to make sure when I change this case it won&apos;t
break 10 others.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129934</commentid>
    <comment_count>54</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-27 15:54:03 -0400</bug_when>
    <thetext>(In reply to comment #52)
&gt; [..]
&gt; They can, that&apos;s what I meant by:
&gt; &gt; &gt; Perhaps we should align locations in all cases?
&gt; But should I really change the implementation for final fields on behalf of 
&gt; this current bug and for the patch feature?
No, we can let that be as it is since its existing behaviour. Just for the new warnings we can be consistent if the fix is trivial. If thats complicated, then even that can be left as such with a note on the wiki page.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2129940</commentid>
    <comment_count>55</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 16:03:56 -0400</bug_when>
    <thetext>(In reply to comment #54)
&gt; (In reply to comment #52)
&gt; &gt; [..]
&gt; &gt; They can, that&apos;s what I meant by:
&gt; &gt; &gt; &gt; Perhaps we should align locations in all cases?
&gt; &gt; But should I really change the implementation for final fields on behalf of 
&gt; &gt; this current bug and for the patch feature?
&gt; No, we can let that be as it is since its existing behaviour. Just for the new
&gt; warnings we can be consistent if the fix is trivial.

Not difficult.

So I&apos;ll count your vote like this:

(In reply to comment #50)
&gt; - treat @NonNull like final
 NO

&gt; - treat @NonNull static like @NonNull non-static?
 YES

I&apos;ll update this in the topic branch (always report against the field).

The case of final fields is now in Bug 383690.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2130045</commentid>
    <comment_count>56</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 18:09:05 -0400</bug_when>
    <thetext>This snippet from comment 47 (abc is @NonNull, abc2 is @Nullable):

  if (t.abc2 == null)
	this.abc = t.abc2;  // should say &quot;provided value is null

produced an error saying &quot;is inferred as @Nullable&quot;, which is wrong.
I&apos;ve pushed a simple fix to the topic branch, which corrects this to
saying &quot;is specified as @Nullable&quot; (commit contains a test):
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NullAnnotationsForFields2&amp;id=1b2babf22d9054679a4b8f35db671abd674f38ba

One location in ProblemReporter wasn&apos;t yet updated for handling fields, too.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2130049</commentid>
    <comment_count>57</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 18:39:04 -0400</bug_when>
    <thetext>This snipped from comment 47 
(abc is @NonNull, t2f is @NonNull by package default):

    this.abc = t2.t2f;   // why type safety? t2f is already @NonNull (goes away if t2f has @NonNull explicit)

produced a bogus warning regarding unchecked conversion.
Test &amp; fix is in the topic branch at http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NullAnnotationsForFields2&amp;id=4e788ed0d52a1656beee9be3ee408fb2867ef1b0

The issue here was, that a nullness default was not propagated into binary fields (since the implementation in this bug pre-dated bug 366063 which changed the game).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2130052</commentid>
    <comment_count>58</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-27 19:15:13 -0400</bug_when>
    <thetext>This snippet from comment 47
(abc2 is @Nullable, o2 is @NonNull, return is @NonNull, typo in comment fixed)

	if (this.abc2 == o2) {
		return this.abc2;		// isn&apos;t this the same as this.abc2 != null? We shouldn&apos;t get an error here, no?
	}

produced an avoidable type mismatch error (specified @Nullable vs. @NonNull).
At a closer look it was simple to fix so that &quot;== nonnull&quot; is handled
the same way as &quot;!= null&quot; (not sure if this is relevant in real life :) ).

Test&amp;fix are in http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=sherrmann/NullAnnotationsForFields2&amp;id=9ad82e71b09cf3e79f0cf9c5fe7c414251c32119

This concludes the work on the examples from comment 47.
Thanks again, those examples were very helpful.

I&apos;m re-running JDT/Core and /UI test suites to see if we&apos;re good to go now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2130138</commentid>
    <comment_count>59</comment_count>
    <who name="Ayushman Jain">amj87.iitr</who>
    <bug_when>2012-06-28 02:21:13 -0400</bug_when>
    <thetext>Thanks for taking care of these issues Stephan! :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2130738</commentid>
    <comment_count>60</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-06-28 18:50:18 -0400</bug_when>
    <thetext>(In reply to comment #58)
&gt; I&apos;m re-running JDT/Core and /UI test suites to see if we&apos;re good to go now.

After all tests signaled green, I uploaded the patch feature to
http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields
and updated the wiki page accordingly.

Apart from the wiki there isn&apos;t really a public announcement, yet,
but I submitted an article on EclipseZone, waiting for moderation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2139859</commentid>
    <comment_count>61</comment_count>
    <who name="Trask Stalnaker">trask.stalnaker</who>
    <bug_when>2012-07-21 04:44:11 -0400</bug_when>
    <thetext>I tried the beta feature, but I&apos;m getting internal compiler errors.  I narrowed down to very small repro:

package-info.java:

  @org.eclipse.jdt.annotation.NonNullByDefault
  package test;

Test.java:

  package test;
  class Test {
    enum A { B }
  }

I tested on a clean install of eclipse classic 4.2 (windows 64-bit) with no plugins other than this feature (installed from the update site http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields). &apos;Enable annotation-based null analysis&apos; needs to be checked to see the repro. Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2139862</commentid>
    <comment_count>62</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-07-21 05:22:02 -0400</bug_when>
    <thetext>(In reply to comment #61)
&gt; I tried the beta feature, but I&apos;m getting internal compiler errors.  I narrowed
&gt; down to very small repro:

Thanks for the concise test case. I can reproduce. 

BTW this is a sad little demonstration that this tool isn&apos;t self-applied because we can&apos;t use annotations in the compiler implementation:
We&apos;re dereferencing a field which clearly should be marked @Nullable ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2139866</commentid>
    <comment_count>63</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-07-21 06:51:07 -0400</bug_when>
    <thetext>The real solution is to fix bug 380896.

Test &amp; fix for both issues have been pushed to the branch via commit d7159ad7486a45852823b45141eb68a3dc975ba3.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2139911</commentid>
    <comment_count>64</comment_count>
    <who name="Holger Klene">h.klene</who>
    <bug_when>2012-07-22 09:39:51 -0400</bug_when>
    <thetext>(In reply to comment #55)
&gt; (In reply to comment #50)
&gt; &gt; - treat @NonNull like final
&gt;  NO
&gt; 
&gt; &gt; - treat @NonNull static like @NonNull non-static?
&gt;  YES
&gt; 
&gt; I&apos;ll update this in the topic branch (always report against the field).

To clarify: If multiple constructors assign to @NonNull non-static, but some don&apos;t I want a warning for each constructor, not one warning on the field. I don&apos;t want to search the failing constructors myself. So &quot;always&quot; refers to &quot;always in absence of explicit constructors&quot;!

CONTRA CHANGE: keep old final handling
If no explicit constructor was written, reporting warnings against the class reminds me of automatically getting an implicit constructor. This could be a little extra hint for noobies to learn the difference between static and non-static.

PRO CHANGE: never report against class
Reporting those warnings against the field directly will point me to the most likely position, I want to fix the bug by adding an initial assignment or removing the final keyword / the annotation.

OK, I&apos;d give it a try, meager 51% for the change, as I don&apos;t consider myself a nooby anymore *g*</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2143751</commentid>
    <comment_count>65</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-07-31 17:14:00 -0400</bug_when>
    <thetext>(In reply to comment #64)
&gt; (In reply to comment #55)
&gt; &gt; (In reply to comment #50)
&gt; &gt; &gt; - treat @NonNull like final
&gt; &gt;  NO
&gt; &gt; 
&gt; &gt; &gt; - treat @NonNull static like @NonNull non-static?
&gt; &gt;  YES
&gt; &gt; 
&gt; &gt; I&apos;ll update this in the topic branch (always report against the field).
&gt; 
&gt; To clarify: ...

I&apos;ve released a fix for bug 383690 regarding this issue. Beyond that I see no reasson for further changes. Feel free to check the test cases in that bug if anything is amiss (or try a nightly build &gt; N20120730-2000 with examples of your own).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2170725</commentid>
    <comment_count>66</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-11 15:24:13 -0400</bug_when>
    <thetext>I&apos;ve released updated versions of the patch feature to these locations:

Juno SR1:
- http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/R4.2.1

Kepler M2:
- http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/4.3milestones

Apart from the fixes for bug 380896 and bug 388630 these updates contain nothing new from my side, but integrate the beta feature into the respective milestone / release of JDT.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2170794</commentid>
    <comment_count>67</comment_count>
    <who name="Holger Klene">h.klene</who>
    <bug_when>2012-10-11 17:02:49 -0400</bug_when>
    <thetext>(In reply to comment #66)
&gt; http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/R4.2.1
&gt; http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/4.3milestones

404 - File not found ... these links were not supposed to be clicked in an ordinary web-browser, were they?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2170833</commentid>
    <comment_count>68</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-11 18:13:20 -0400</bug_when>
    <thetext>(In reply to comment #67)
&gt; (In reply to comment #66)
&gt; &gt; http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/R4.2.1
&gt; &gt; http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/4.3milestones
&gt; 
&gt; 404 - File not found ... these links were not supposed to be clicked in an
&gt; ordinary web-browser, were they?

No, those are update sites as usual.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2183084</commentid>
    <comment_count>69</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-11-13 14:06:52 -0500</bug_when>
    <thetext>A new version of the patch feature matching Kepler M3 is on the server.

If p2 is slow detecting the update at
  http://www.eclipse.org/jdt/core/beta-null-annotations-for-fields/4.3milestones
feel free to point directly to the current actual location:
  http://archive.eclipse.org/jdt/core/beta-null-annotations-for-fields/4.3milestones

The first address is still recommended, but since that&apos;s just a redirecting composite repo ATM, p2 seems to be dense in understanding that s.t. has changed behind the fassade.

Again not much has changed regarding this bug (except a correction regarding quick fixes applied in multi mode). The major part is the rebase on top of jdt 4.3M3 (which contains, e.g., the better part of bug 388281).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2195005</commentid>
    <comment_count>70</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-12-16 12:32:36 -0500</bug_when>
    <thetext>As I&apos;m currently testing the re-base of this feature on top of SDK 4.3 M4 I&apos;d like to know:
- does anyone need previous milestone versions, or is it OK if I simply replace the beta download with the latest version?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2205836</commentid>
    <comment_count>71</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-22 04:52:47 -0500</bug_when>
    <thetext>I&apos;m right now merging this feature back into master (for Kepler).
The patch will include fixes for bug 382789, bug 380896, bug 383368, bug 388630.

To be perfectly clear, the solution will take the approach that started in comment 32 whereby no flow analysis is applied to fields; see bug 383368 for &quot;syntactic analysis&quot; which instead of flow analysis covers the most obvious cases of checked access to @Nullable fields.
This is the solution described also in http://wiki.eclipse.org/JDT_Core/Null_Analysis/Beta</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2205841</commentid>
    <comment_count>72</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-22 04:57:33 -0500</bug_when>
    <thetext>(In reply to comment #71)
&gt; The patch will include fixes for [...] bug 388630.

Correction: that particular fix is already in master.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206082</commentid>
    <comment_count>73</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-22 11:38:29 -0500</bug_when>
    <thetext>While reviewing my changes here&apos;re a few notes on the implementation:

Checks for missing initialization of @NonNull fields are in Clinit and ConstructorDeclaration. These checks are in exact analogy to definite assignment checks for final fields. FieldDeclaration.analyseCode helps by marking @NonNull fields as assigned.

FieldDeclaration.analyseCode performs more checks to detect:
- @NonNull field wrongly initialized with a nullable value
- final fields initialized to nonnull -&gt; mark as effectively @NonNull

A simple new method Expression.nullAnnotatedVariableBinding() detects whether the lhs in an assignment is constrained to @NonNull (local or field).

Method EqualExpression.checkNullComparison() has been considerably re-worked.
That method was known to be incomplete, marked with:
  // TODO: handle all kinds of expressions (cf. also https://bugs.eclipse.org/364326
I have added detailed code comments to the new implementation.

Another comprehensive case analysis is in ProblemReporter.expressionNonNullComparison(), which is where also much of bug 382789 happens.

Changes in BinaryTypeBinding, SourceTypeBinding and FieldBinding relate to retrieving null annotations for fields
- from byte code
- from defaults from an enclosing scope


Everything else is small, pretty straight forward and should cause no headache.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206088</commentid>
    <comment_count>74</comment_count>
    <who name="Reuben Garrett">ReubenGarrett</who>
    <bug_when>2013-01-22 11:45:52 -0500</bug_when>
    <thetext>(In reply to comment #73)
&gt; Everything else is small, pretty straight forward and should cause no headache.  

and will certainly relieve many headaches as well!  thank you, Stephan, for all your work on Null Analysis in Eclipse.  i would love to see this develop into a standard one day!  

~ RNPG</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206106</commentid>
    <comment_count>75</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-22 12:19:34 -0500</bug_when>
    <thetext>Here&apos;s one little feature I am currently withdrawing from the patch:

I thought it neat to treat final fields with a non-null initializer as effectively @NonNull (comment 41).

On closer investigation I don&apos;t see how this could possibly be supported for binary types, since the byte code doesn&apos;t have the info about non-null initialization.

If we&apos;d support this convenience feature, the compiler would give different results when read a class from source vs. binary, which is not acceptable.

If anybody has an idea how this can be solved feel free to open a new bug, but I believe we just have to ask the user to make nonnull explicit using an annotation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206210</commentid>
    <comment_count>76</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-22 14:40:15 -0500</bug_when>
    <thetext>After more reviewing, cleanup and testing against suites from jdt.core and jdt.ui plus field test I&apos;m confident that all is well.

Release for 4.3 M5 via commit a846071c58f9098177eef02be0134294158f9c4f</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206442</commentid>
    <comment_count>77</comment_count>
    <who name="Dani Megert">daniel_megert</who>
    <bug_when>2013-01-23 06:43:49 -0500</bug_when>
    <thetext>(In reply to comment #76)
&gt; After more reviewing, cleanup and testing against suites from jdt.core and
&gt; jdt.ui plus field test I&apos;m confident that all is well.
&gt; 
&gt; Release for 4.3 M5 via commit a846071c58f9098177eef02be0134294158f9c4f

I noticed that you added the option for the syntactic analysis:
COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
If this is in good shape, then please raise a bug against JDT UI, so we can add it for M5.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2206538</commentid>
    <comment_count>78</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-23 10:12:58 -0500</bug_when>
    <thetext>(In reply to comment #77)
&gt; (In reply to comment #76)
&gt; &gt; After more reviewing, cleanup and testing against suites from jdt.core and
&gt; &gt; jdt.ui plus field test I&apos;m confident that all is well.
&gt; &gt; 
&gt; &gt; Release for 4.3 M5 via commit a846071c58f9098177eef02be0134294158f9c4f
&gt; 
&gt; I noticed that you added the option for the syntactic analysis:
&gt; COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
&gt; If this is in good shape, then please raise a bug against JDT UI, so we can
&gt; add it for M5.

Sure, I was going to raise a bug for the option and propose improvements for the quick fixes. I have some code for both of these from the beta feature (on a different machine than I&apos;m on right now). I&apos;ll clean-up and post everything tomorrow. Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2207209</commentid>
    <comment_count>79</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-01-24 13:15:19 -0500</bug_when>
    <thetext>(In reply to comment #78)
&gt; (In reply to comment #77)
&gt; &gt; (In reply to comment #76)
&gt; &gt; &gt; After more reviewing, cleanup and testing against suites from jdt.core and
&gt; &gt; &gt; jdt.ui plus field test I&apos;m confident that all is well.
&gt; &gt; &gt;
&gt; &gt; &gt; Release for 4.3 M5 via commit a846071c58f9098177eef02be0134294158f9c4f
&gt; &gt;
&gt; &gt; I noticed that you added the option for the syntactic analysis:
&gt; &gt; COMPILER_PB_SYNTACTIC_NULL_ANALYSIS_FOR_FIELDS
&gt; &gt; If this is in good shape, then please raise a bug against JDT UI, so we can
&gt; &gt; add it for M5.
&gt; 
&gt; Sure, I was going to raise a bug for the option and propose improvements for the
&gt; quick fixes. I have some code for both of these from the beta feature (on a
&gt; different machine than I&apos;m on right now). I&apos;ll clean-up and post everything
&gt; tomorrow. Thanks

X-ref to new bugs (patch available in both):
- Bug 398965: [preferences] UI option for syntactic analysis for fields
- Bug 398995: [quick fix] Extract field access to checked local variable

Status of Bug 337977 is not perfectly clear and it may still have more pending action items, but I&apos;ll collect information from various comments and bugs on some later day - to present an overview of where we stand, and propose fixes if I can.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2230649</commentid>
    <comment_count>80</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2013-03-13 12:26:11 -0400</bug_when>
    <thetext>*** Bug 403192 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2230652</commentid>
    <comment_count>81</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2013-03-13 12:27:49 -0400</bug_when>
    <thetext>Verified for 4.3 M6 with build I20130310-2000.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>217931</attachid>
            <date>2012-06-27 09:33:00 -0400</date>
            <delta_ts>2012-06-27 09:33:33 -0400</delta_ts>
            <desc>project to show minor problems in null annotation beta support</desc>
            <filename>nullAnnotTesting.zip</filename>
            <type>application/octet-stream</type>
            <size>11176</size>
            <attacher name="Ayushman Jain">amj87.iitr</attacher>
            
              <data encoding="base64">UEsDBBQACAAIAOiQ20AAAAAAAAAAAAAAAAAUAAAAVGVzdEFubm90Ly5jbGFzc3BhdGh9UMtKA0EQ
PCv4D8vc0/sQgsKuQWQFA0ZIVq+hd6bZTBx7lnkE8/eOj6AICXXpaqqri6pn728m25Hz2nIjSihE
Riyt0jw04rm7n1yJ2c3FeS0Nej9i2CRy9suIg9tnr5pVI7yTIvtcfo/5caW0fFBaNwBJo0dPsFUB
DEaWm/Qd5st2ffe06G4fFu0y/6/THMgxGlDUxwGi/rkkB6uArNCpl8duP1I+xx2u2kkJ01ORjO6P
RUJmGzCkgtapn4SqKKtiWl0mXMMW3SlfG8MYw8G61/wlrvO/fX4AUEsHCP17N4vZAAAAhQEAAFBL
AwQUAAgACADJkNtAAAAAAAAAAAAAAAAAEgAAAFRlc3RBbm5vdC8ucHJvamVjdHWQSw7CIBRFx5q4
h4a5oDMHtMZo3IB1AUhfGpryCdDG5QuU2tTE2Tv3fe4Fen7LvhjBOqFViY74gApQXDdCtSV61vf9
CZ2r3ZYaqzvg/gaOW2F8mA7qhiomoarB+YtS2lOSODa4lhKUryiZq6jmKy4BWdFrEH3zMMAjZbyG
VaaapGQvbVsMvBfGAe4aj7m2oWAjSwtglwhhg9l2iN4uM1kLlPy6ZGWOESz9YCFPT/A/wdSPAdJc
Orcc+D53/YUfUEsHCDvgk+C/AAAAgQEAAFBLAwQUAAgACAAykdtAAAAAAAAAAAAAAAAALgAAAFRl
c3RBbm5vdC8uc2V0dGluZ3Mvb3JnLmVjbGlwc2UuamR0LmNvcmUucHJlZnOtWE1zIjkMvW/V/hWq
5rI3DkDIDlszkBqyk7Ox1Y0nbrvXHyS9v36ldtMQZitBZi4pINaTZD3JzwZpdBtg0nqowIOVECYH
8EE7O/30+2/O1xMYlvxQcSKdB/zTtNqAnwhrXRQR104aHYK29drZdTJm3t1BJZKJs3HFVNcWjRmQ
1lmLWNNLg7Mlgzs+6K5TOcAr0MdkOG7QTuwMvAs/rOHCWmG6oMMULFmrj8ylU1CDnWhrtIW/gp93
EehHLkAUvob4YESsnG+mnyZ/XGuZbAqgvjgpzBSJFsAfPsyaPhgtkJDXeFKwS/WEElynZgd+im7B
i/ihm8GQQvsuvO5rxrMNLnkJ95ph2HqHfpqzym5TC35lI/hKYMYvwlvspqtxAm5pXCmwUVcaswfv
nb/aOkW3c6/o78oePRrSD7hnts6eqbrMwBUItSAqsu2QRjLPlXLTlb0bvkCOQulwVUf8D9bTHuwG
B6fXCoM54X6FuHeKj6yDRF6JGtS342DmZgpNG7st8gsaLA+ztmBTU0ooeMXOlTqabmEcNv4MCdZ/
6ruLF0cljIl771K9X4jAt47CbFoqkDBLyoFdCUzfqM99VbnONTp9EF40gH09d8kqbgl7CNPNcT49
r11c0EyE2J+zvqH/sAGd32mFdT2xilXafW+8EFHu+6C4/rWVJimgo29lK3fvXTPrh1dgFwahaP5E
jd/W1Mx78Bo7bpyiQ+vxI8y7DEtsge2LxlT5GEpj/0dqPi1nEkVVYJLnzYlURL+mT/9Jx/3C2RB9
ktH5NZKRm80g7QYRVNCFI8BxKLJV4QUSVYbiuIPQYsmHyNgMGtA+i7Cn8T/wpSiiYfTDrZn9jHPv
/AWjV0RPGunZz5Uq7sLRFpsFCTYo/TJGbDsrcTRb/S+ozakBi/bRumVVYcvgNEDD/sBiBmUdbQyd
O9tIogRZfyhLD+8Iy1fccpy9lFqG+4KpeVQ4zLRw0J1qiSMvD12MrcJQI2/4Eljh3CbTbQvyu3Zm
oA3X/G8sNshnkkqlG+tGgfQg5DOKm6FzyyZ1ezxazzjDq07r0BI/4YTWpHWEmTtnQNgbECNpJmHW
5bUaMUyHe94rqFL15MXLY9dCsYT0oFC1CBvXb3h8E8yCWFSMQCRGSZpF96ai7Ga+TlQq7hF7wqTL
lx4vX1yU1vmBwQth5/BwKl8+/28FLEIJtE9n8jNLiHsSs+xzMpzJmG8gQWMbcwsYUks3//BGjPNF
3xHmKXu/+hFktO+wyyVmkwmdX1LwiO03pghtD+PeLJtkSs7+iCS+KBR3e5MVB6cVRf8nPUJoSZ3x
kP/LzisdRz2BbFp60yjo+vTT8GIDKCf71ga1pMtsvnLwNjfZvbAKkx8o8+ieoSAVC1Rh4bulYevf
M2va0DwAuRD/JFQjeBlVPVWL7hT5Ge4OFwqcfY8o3V5Q6EhoCzj7Ltbyld4exq8zmxf0HGBT8R0/
q3ybvHMSb8bEk7MT9xe6efu2w55ZGRvFKY51PvH6l1OxA/bb2vmja5HpZveDBLmhq2gxQ8a5dpv1
r670CEy1HS9UuEWzHV6V8YQorPIb3BNnUDJLjz+Xonp9wHvzV+iftouKecv0O2BSvg5HnbUGnOki
XM3l/ECeX/H/A1BLBwj48z9RxAQAAG8aAABQSwMEFAAIAAgAAJfbQAAAAAAAAAAAAAAAABoAAABU
ZXN0QW5ub3QvYmluL3AvVGVzdC5jbGFzc31SXWsTQRQ9k91mk3Tz0Vg/0g9bbaNpmnYhFBFbRBFE
IYliSsSXwiTd1o3pbt1M+pN8rtBasOCr4O/xVfHMJpbQiht27tw7Z+4592x+/P76DUAV6xZiAvFD
Z9vtKwumQK4rj6TTk/6+86rddTtKwJDtjkC+dvlkU2D2zcBX3oH70j/y+l675z71/UBJ5QV+X2C5
FoT7jtvpeYd91+nuKkdeHDuNwG8Mej02Mdm/KlD8L5pQyf6Ex7c831OPqau00uLtZ8Gum4KBrI1J
2EkITNlIIi6QrXm+2xgctN1wW1/WQwQd2WvJ0NP5qGiq9x7VJmpDG0hh7AWBwMPS1ZGvVlb+5cvy
ZV9ey1AeuMoNxwxKUWrWwqyA9TFirqYwg6ye4LaNCcT1VIs27uAu1amgqULP3xeYLo1zDqubSV5d
tlHUcxuquicgOEIsoLGC3zCmuEnWRjxUmG4q2flQl4cjE1LNYBB23OeeTpIata45SM5+/K/EGCmJ
q8VMxwSj0EaP1VIjJD8E1zSzrSgHUuUzZMriFLnPESbPNRN1TsAkMsl4jZk9RGMa16GfG7hJ1Djn
Lb7p2IhsWNJEP9l0gnHnHOLdGQqNc8wwzj0yy6unmC+fIPcdkzp8wcLbtVGq48VpQodjvVQ+/U0K
5gmWiDiHwW6ZYzIYkfgHEWuO/FP85Sl0GvMUXaTACgrYwCw2MYcnWMALLKKOJbR4qofcGCq9GHIH
96Lx9O4+dzF2baHEU4O961hBmSatRpaZv1C0ICzMZCa1WZXIzrU/UEsHCOWelW1IAgAA0wMAAFBL
AwQUAAgACAA1l9tAAAAAAAAAAAAAAAAAGwAAAFRlc3RBbm5vdC9iaW4vcS9UZXN0Mi5jbGFzc11Q
y0rDQBQ908TGxNjU+lq4ciFoFw5kqwgqCEKooKXgcpKOdUI60WTS/3IhgoIf4EeJd2Jx4WbOfcw5
59779f3+CSDGrocOg/fMx7I2sQeXoZ+LheCF0DN+k+YyMwyOiR8YBsn/zgmDS62YYe+20UbN5bVe
qFqlhTzXujTCqFLXDAdJWc24zAr1VEueTw0Xf20+aopCEIPEuqdKK3NGhodHE9K+LKcygINeiABr
Pmi4ECvoMkSJ0nLUzFNZjS3ZTldmopiIStl8WXTNoyJ/P1kuSB7BXdlUmbxSth+01WO7F/ZJ3qGj
dAjJgyI6DCHDKsUW/bbG7Cz0hpRdEIMR9odvWB9+wLknfEX00ups0NtrNbtwSSsiHFAW/nKwia1W
cbv9vfMDUEsHCAN6Za4lAQAAlQEAAFBLAwQUAAgACADyldtAAAAAAAAAAAAAAAAAIgAAAFRlc3RB
bm5vdC9iaW4vcS9wYWNrYWdlLWluZm8uY2xhc3NNi0EOwUAYhd8ULRbCxsYZahJbKyISiVTCCabj
bzM1ZqqdNnE1CwdwKFEk4i2+t/jeezxvdwAz9AJ4DIMLz4U8iZRCZRIboM0wzEQtuBYm5bs4I+kY
+gdbFZLWShPD6P8xfY8ZJvvKOHWmjalVqWJNC2OsE05ZUzKEW1uknKRWeUk8OzoufppH1kSV1svr
ihJRaTcfAwwtfOOh86GPoGm/MV3gBVBLBwjr/T6XpAAAAMUAAABQSwMEFAAIAAgA6JDbQAAAAAAA
AAAAAAAAADsAAABUZXN0QW5ub3Qvb3JnLmVjbGlwc2UuamR0LmFubm90YXRpb25fMS4wLjAuMjAx
MjA2MjMyMzI5Lmphcp1ZB1TT2dNFwEjvIKCh9yZVOtJbDL1J7zVAgABK7xGkFwWkS0eaNKkSFOm9
RkCqiHQEBSnygbt7Fvzvurtfct45Ocm5N7+Z92bmzjw1EBo6CQoGBgbK88YJSZQLL5KzBZbTkuJU
UpG/BZZSUZKX09TiAstHxfRhtXEThGwFtshwUd149zBIGKv5Ian6NlWCds6GE1hTPfP9gczY015H
648G+aMrHoNhMLQW95CIj3QgPRe7TjisqE99S8rls/eVfFcw9oJp8OBDEtjD0BCwaDWpLIr+5wh8
SlUbG8QtGK7Jp2vUjFWG1hbCkal7gm68Da51zDo7GyPrr69xtpls4jf4qK6YdErom6xxavc3dftH
6iGK3KggLldGxONRB/qJxwOkdlIMr9txyWOCyBvR1EDXMEr38HcaziwTuYKCova3tmNetB0N5Rx4
/jXq7z//PZDgbHGZQe1MLK3cLFztoDA7Z6ek6Eo8VFoCWe+WIMitDjNz/vpFkVeSDjIBhtwVILz+
g29OVpD0IusIQT7OrfgP7E6chP3cbLi8OQWx0PR5v0aqfhoDT3JDpkg+GoR5+1KRVv8kY0ObgGNJ
hETBuxyvsLKbdO4TFIemTFMrQysJwi9ubYvatmJ1pdq/nwjhDfW3QzulaIE/P/hhRBlyigJ+9oij
l4zgdiu/ZATW2TIzd3aHcdnCHCFRWkaaU9wEPmX+7WP4J8kIwsBsNMYdHFwzZbg0QPoOFekRUUkS
I30Xz7d98S68wHiPThDdmpOzs+ciYm2kZGjvoyVOKDvjXac7RmkxNCrkRy13zNdhXlh3JFRfGUu+
qsMW7H/Yy3O7JZI+S9VQSNfX8rldqnHV7Ig1In9i/T39F1+Hfb7K7PInjWIqz6TIYSbKVnADlEMF
BQVHk0K5jBHd8OjgcvB2GVmPmdhwd7ZrF0zbDOeeN+VbvC3gbnNHLOm0Huz17tOSpe3tOZZPHZGx
aVCikYSUspmAGrhtawMPX3q5pGsN+dvFnqWvTNyTDiVm+hjYM4arkyD6hwDtwzwdjGuiFXWNR2at
xXukNesF1+lkrOJWv450PgFjh7gwyVkR9sNKXTdDdNQ+z9oG3qqP9WEifJm45ijJAvWzZlyTk4Z7
Om/ab0SLYm3M++LP6ShVk1WzD/IHbdNnu8a5wIV71Vat4VAoGCiWMwSKG6kZqRgWIADyZ3dms4bH
dIs/MrwfHSK27zmU+j03QylOqo7OR8bihE2CBti+s2QusxWSVax9DRX2gQJyO/pl8JUUB+h3BrxJ
FeyU2Jdz8WaMCVb+dRPWi+15aG9HjGH5uFo1RdVyRw978KplmeVv4dyaQuMPgrDElXS0fWlqRPTs
PlDjvC7MstFqGmYeXnrPIclNKibdEDG98iL9a++JTYssH4m9VED9tn/KPSCHYRw1wrDwpUtJTefE
UzZHkfpgt/rkgaH7naVOj31Id4rp7EuPAPbmcvFQOa4+P0JHtoHKvllr3wD1QOTW9nrXeh2Z5ZOr
urFPcQvAVHTjGLrHoTKHrLi1/RFw+SZmsUbiFwPhrVW0Bq4t4sunSlCMTPf309euHA8/lu2ETg3H
dWDKUk/EBvHHVbsasqR+D0I/ZS+nTTOqSPY/CakjzLt98iPad5+Whrw8i9qUq78674Rny9zdyRJi
xQV1dYZaucLsrNxK1aXsX0viNB2Ropro22687JDEz8atzguR3L2C1GkKMtp40VjbtVUyOSg5MOT4
RpGPMumDUQnLfB8ctISwvL9CNW81wr+dwEpOcpBFDozQUp66h43NKZUr65LTEpQwj057SJuDlkj1
gra1bJcry1APAE1m5X2Xy84dv2BMQfyifZwocljTMD9xmehgF/Vr+odYjGgLh/pg501FEhVwzZB4
1Xz/cRc3Y7o6tXjBzXogn/cD/WnbXabQewrgfjODiV0x3Wp7LQm8mrwrjmCEhGpfPi8SaR4lPx4l
kV+64HAyAMgIDK3KwGhc/Mi2FsSoEL9jn/dyq6NbejdDz0I069nEyUZEzhg/J+dG+T7xuuyxPS0C
qTD56HCzEP668NU05jvQgtYx6rmLC3ErkhnOkqkG6kUXr3OMXnIx+tlyc7X4ZS79GYPxO8bZ1eY/
4Qgu4KwsIHZQN6v/hCf5C7y9Jew/cVD/DYeZk5MzzOy8KvwnOvZ/plNxdlJxh0C47M08zEp1jFRv
iBL4thyxLxMWw64f6tElkmiQsjrWB2yuJS2mrzfc32iuFbQLOdjan2SirSYhLWIPvN3vk0YxIJyw
2pfpi+UlY1M7KzRWHYi3RNssKiJB1X66tSICncWSyZysVyGXaRu1lOnpfzLkUizAqKAaLd5IOsE4
U92tuQVZlH1y01RVWnnqSxsk0a6QODCd6F0HeRsPnn3y85Bh8+wUgGYVyKliTQxpdcidoP8l45Or
ni2jXRnDDR9D4BMFnsEG7RczjBrr8+gMNZ8RRe0EiQLPQq7BY+plH7Y4YpwcFeuXTzB+5MhzB+fV
EzYsGL8yAlInOa7wR7p13MWzT/enxl/Y1ax7H8/LlqWWamy8NGpUXm9BLBtS5d50sE1BaORsJBI2
a25rW9Titj6Y6Vucc/2zDv9dFqjuep1IoiSErywhB0VtDfXbfZpPNw617c1SxZ+5PmavR+4Z+jUl
9w2oGq8JnHrdTj89GthbNT80k/CuOfqI7CsoLx/wEm5ObXP3+KK3XCXxUQdvKHwt4fpGmVArW81G
XS8XZ77n7oudKCguPCEogk1zb0vKtkYrq31YhIhEDTMf2xkIHx9f0raQJTds0k2zZ+fxYL+S2s5a
7jJEp6pLOXFjkDUH84YIFEcQzUB8+6FXMi1DIyEg1l38kHaU9r41ogE9izTFMrxDdI9BCvU1e4Bj
ewSxpyaMEmSwW0RRTaX7iXSPXhBFsUNJ7e2JXdi16Pw5B9Bw0IdTXAiDTVlUqYqORanKAHKHyF9e
3gwzxoo24DqIJFeZS8FyXebzLUU/O9Kysb4W0Cb9HGfywyll4Ze+eotYdrWf8lfuY0x/CQzKC0XN
a+fT/mBvtkMSm1UIxtonpCe2bGtoPhiTMaJ2JLszwNIMYIvhtWektBBnmqZPpH6Z386UIv4GtmQg
uiKCSZXKwzK74N2BkdsW67T88Xu7B/lX0ai+Tgt6suNWluwvADSSPD2Kt5JinMXLVlrCYUNt0vV2
nyAKzxceS46mi0Rf86Xka+HGpe/dLANOMR+i9Mu0CSzkxHgSl/Zyyu3ZtTBP1R3xJ9cXLbLlT79q
MarhBa8Rrx/nvr0K4jHtdai5u0jKQpcbSixfq8f5tDOq2bnyOwDo8828wWRJEdu9jkcYlKT6SD0l
aWyyOPyLHcLRgHiqtqMeUka78fLQxtre0Moa3IQaw1LeW5wsFmHIg2QdReDra2f0FUxMwNsZeoYR
QMZmanWdOcINBndZVYH0TfxHEuVrSgvTGjRH1x3MHVbKDkqKK45nOFdnR2JgXaaQjhnUOwIRRwv+
5yni+81BlW40FJSvGBdTxK2fihj/v04R0g9krazN3CGw33MF2HlKiEBc4ZV5QPNkKCejNySoNdoC
EuwIpN/JmaQHRzHk8yvFJjY7xZ62yGi8SK9dcQrA4oao7+4s9/UmPPJ89bV7DthbjTRQF6QC+GC8
yjQxbH2mMMJ9lXrwHa4mVjKb1BGgtCe4R0v5IRceh0i1AYebnkBbYGVDLYQY2ElF/tHLIvkdtvbr
sAfVQUrXzbkfwdTiux5jdo0TZWszvluR97hxrSFC0I0r1AWjx4PzKjwm6FnO1IacHxXqBiXiqQxd
YHQahhJrWp35jFf2GMtC9msLruVg58XmByYkjTNcHYmME7VcDON3yWyX7nu7ZAj60XcJueRpqDnO
HEEJyrYmKYPV2jSzuY3e543eoHcJ7q5CKfBsavwmS1g6dJsqYbahNJvo1NR0ZcJYzpr8tM0enW1b
bV3zk5v0c+KyHg76rHde0PmA18Q7SaD8VeJnPhls9zZwl6uO2hdX58uRq9/nP5e2ZC6X4O/XOXsY
qNj4q5wmv0I6f9l39ePYhi/XpdYhqHp6Mt+JZzGXKE6e8hrYp06dDETp9o6v3OLrjKh+7JIeDWi1
axvnr3urGFhtSEkO4wQGFmApVEjN2uprYRuyp35/PJI2zDGsZMiBSwsNT1KrNsfdbbWN6xrnE2Gl
zfpiFsjmujaOpQW6zSyEoa0VlJ4FTEQPuC0a4h7lZEVBE7YURKQhuzz3gC70EBW7lIx2OPdohyh0
qThx4tOUyUDyAkuwSkVAXM2wCSksI+PJhKC3rZGXT7t7+IRv4dMTR2eqAdWhzRDneAKkyNfa3VLF
0IoqajnhVTdpK/fBcvEhRF40BXACcIS3/TAhApsjdDA5PzJDDsYqzGpuMokKnPm6M1OSs1l8ysGc
493uv8ZiWBipfwOF4X7u47vt402cNNqIIKc7tPuLQIHN1hCZraJc9bt0iXTq4/2Zh/n3sCIezdjK
dQjlNo0gO604awtbCdKHnNVypLQBLbBiBLeX42DbpJ+p3xQvcsH0gLc3vJKXRwe2+2Kw5encYEis
U+bLO1f3veTIMdnn721ZiMh1mb/pVLThJysefqA34Bcv8sKC/bWN9GIr4fDTgk4mhfZOJrg7tU/V
wbf1xb0dl2TwcDR+RvZIBSG6OqWURhthWiFrEw5fwntPYqkdx3aWrTrc0I/rHJ3tFFJH0+hB3mTt
E06yfvxbdrTRssLBhlqf+pQSwwqaam73wu5MzXgkgMxF83GiNgxULOvsfci/Fyru2cxzDMJqx/Xp
BAocPg111d5PabY8/aG5/KnkhivOMsIExq9EA8e/yAhn6cDM/Ez3/sgE2kMqi2eNXotPu0QtC0Oi
gn42YCVc+cNK0qqxalmVEk50ulvaY6ydrbraMTKhELxwxVIiB2vP8RSX4WflzXRCQaAZSBQLO7b4
e/hIAoLG47QAalNZlBzkwJ9vrXxFU9jWINuOWKE3F10VgjB9ZB31ALVHuXqQ3IhSxxt1PtClbC2s
qFSNcbQ3h/BubRmATxFbWGr8rmJtPEZ699B9yvlVMtg8NZNhRL5csic7q1AvuoJczJqU6wKWIxui
xJc+kDNOUYlL3+FNcZV0yeRadrvMLWtg3YtaYdBIn3WC6Uq8rWY+EYhJE7K04wWN16p9jI4nmi+t
7viOr26uzN9jjTyE6DEgFCKBW7ombx7Vzctso5BmPK0mN2K7+CS8blWZ5Q19A/DwHXsU5VtqvXBJ
tE1484CjdIT7oEAkHVFxVOg4J/RlwYkyg+YHbDVezASOOlym2YIE5Nh21XPkhtXtoxN2g7tVj5BL
I3tPuz4fft01+oiko1+1dCHfNepPWk6nN5M4JqiTBLG8cjy9+tTBdeurxXZ8CtEGdxALLuEJkocV
S6qSpfoK4DETreeQUVTtsHB1jlavx9tmXf2k1ISN8UjzZcOMkUfWCKP3ZaCIBE2LukE+RX45PaQZ
Di6ikCE1Gechb8xs4qpmP39eP3ahHkbKwI5xM35yoldwoi84S+Dw+BCPe0Gkw21MSVj5hFOO4K6C
uf0evLtQGJ+oKNK5YqhVgPFEFR5h0TlVmEAlEL9wLF04DWRfT3+XzVxUAQ8vKsP34FUOby5xDQVg
H7Ju2jeHeRZbXXWMVuQO3/f1U8usJ1si4HuwNPkS6ekrnI6WutvflLY5eGumS/V1xaLOoC2Bygt+
Suqm61H7bz81V6q5Cvdsbh4OCb3M20eXCOMJMX1T4emFU/4MMHBSiFmwMrl2i9zdc/d+nZjc7HAi
ntWupJ/3jrFgm04W/70y4yFmGq/v2OeRckd3ZGHwTF9HAS5GSm1A/6VI4f7nSIGaWTiY2Vhx2jlZ
O/8WLRpSTtPc5/2hWK2U+dbXZMDV4SxJolzJgD206t4aZHe8ZNf7g/1sBgiZHH5ziCDhzX6o/Ex7
hw7adejH10xiKpgSKQPbVnWzr0E53NnB3kQpQ8KSggGqxEoQvqVxfZZYDOk4y7zsUBNiBYwFBUQ9
CoxqkPzONdiNRkLruwyRt5eBLLlRUgo6lo+aGfWmJTVMRQQVtuGfD8w44IrbTXuPccUqaQsG3Gc3
P+csvrH2YjaPwNJgROtgmL4V3tzI4VX9YLktsVJTeb5hLbrDApSU94XX47F8NfCqd82m50aidcnr
MXbdJ17hE/Vxa9R1ZQFAZnESp0xqti83OfqWiKyFmede72c2qAc9GdYxfBUJndPtxvOFuINHxpoc
VGy/zyma7tFYFvQLfSxpWKdm4vaKey8STamEY/lZWBz88sUTe9F64gj+dc7CXeHRNDQDxy9TJjsz
Yy2tCGwxe6IP7DMhzu2TcrIblVNWiGMT4zjYZCvnuEhEZSRWqpaEbr6Qw7NV35NGQSOz9VRiOOA7
1fct2hqb4nLwLuB8z2sCSAMfn3WkLmgX93zjLzrSf+osf8bg/I75N13lz1iCn7D/1FH+jL/xF/h/
2U3+TMXya6o/OkkLiJmbW6hKjwoqD4m4nCk64U4N1EyLjCPlpYe22UMGehlA29tQ1te4rKyaqEAi
v75Q6jkFCgOLN+0Mtz/VF4jHfF3c3QC2inOJk5Cneonvs6q71tD68/C1KGo6hsSJfLkmArRUfsDC
y09mzu7DOFxPDb6eSI5vFfb0ZCPz5mkezlhc/zjml1y6sHeqFlPt5GULHAKuSsT1cZpyR5Nh81y9
pZurDAYa9rZfW6FPt8K79OBW4xrvsJKQTwxO9eD6XZYfUdNjY+RxJr4FVuoNdOmZ8Jngk9RvRXmy
u1o1+xF4UHQPIA5YX+TyLvHUwWmsC+HqcHg5MdX+NwvyanJyvHUuRClqk7OYbHt/rXaxB9W9Znkh
eSBzdEuWou3cKCIl2O3adZNzl6ucJpIDz07b0qWBcrDdq0su5/lXLv9Tmf/m+ziQapskQcdpTwmW
hGR7B+JAiCAKM8pGtSaLiY7RUYBQFUSh1DVMNBm/PSZ2cOVY7a2d+RtyInzR3cyU2X4V6zsSs++v
GJrPSsrP0WXg3MXSEsqIF1530JRXf56Ht9gJ6VAXVV/1ep+lm8LiSMOsRtWdwp8UCcgfuaHRigxq
HaI7Kgn8Qn/1M18REVFnRrrnVbZHw567HPiM6BHGaXdRGzBJq8ZeEY+O2KDjTTMMzz/MaLOb1Kxe
ESAVsuME5hFe63pIBz5hD1z8EAlKxdSJHP0uJVKJFSwc/KDR6kFG6/xn7JY0HEU+z4am91qJ0R8G
Ot7EDlWue6/VssbuZoquY+GDT/vtMBIhBRvfNp9tiDqBA/Y7mTM3I0/ftGIplNy0amShCybqwRmv
6G/pXwEcgeVxpClIIXmfrwq33fbQ0AT3Odl/bfkRFcdOPbKyZ9tDg/qrqGD9hy36Qyr9GRZSBM+l
TK/K7bhvm/ow3kTe/8rfRqSkQ4s9v4DAAcFxKDwwe+O3HaiOUe50T1rk3J98o9TQkF9SbCNxvi/T
870yUnO3jVR8I6KMn3dmgp+XxzPUdK/y72TyWYxOxsJzJH3zx7sF2VIOm3cizdeyOaD16d8xu03Y
1IC5SN786NsMakf3kDDhwF0W0POMEcVyftW6+qRW9+TGxvS3yDQiUIJ3YImPquxjYO+khj57ws5I
lP/zk9GV+4uopWp4ANTr3wKz9VW6XmwxmeDj1G/hCmK79ojM0ECwEzOD5i1ilPJu0Xc9oSESwvDm
pGiJthxNwjcbJCCYnGdDpJ8FxrRcqHdCEtu++Pg+psDNucGh6ySY7jeFhTygC3N7P0pvD1kCFvWZ
15cvBUbdT6WX89dev1R2f3ge/KgSt42bQO6UkQBUZIrFJmSFqY/FJNRrhtRrYSEPe2aKEiYdYHu/
veS9d8smPgpamoyMHpJEzzd6UU4YyA5i1cmTZxeLuAMadOdgdksmJFNyarunPDdDW1Qe4uc80bV2
25qR4zSmT3ATRfoRdci3DtwGwXNrUP0P77idPWvIj8x6BZUE5c8LoIt3SiQoP7/+6g7tZ4aLeRvz
Evr4IsPPsIvXOQSXYAJX/vce6iL6fAR+cTiOdQl9eOXiBdDPuIsTX8JLuFX0vxikX4T/0aL8YSv6
ZU8BfpNhv0JgXEIEAv4Ubr9CXXZOPeB/5d6v0Jf39NtfoM9P7a8YqC8xiF/7R7n5M9nFGRD7JbLI
fya7OBq+SHw+QrrYSvJfIi7H/v8NlH5+9IsSnOPSPyDw/1uDepH5XMJfFHrcl5jXiP67oL/IvvHL
czpL8lvO+hUC5xKCmPRylvsV8vJZVSX93/z4K/SNS+iYv0D/zSk7J7qoZVguEb37NdElyXiR9VwH
XSy/PJdYwdf/H6ro54e+WGdYL9Fvk/+Hin6R9rxIXUz4nJdorSn/Y8lSA10FnAPJzt7cZ5/4f2zS
/wFQSwcISyLtvXMYAAB6IQAAUEsDBBQACAAIAP2W20AAAAAAAAAAAAAAAAAZAAAAVGVzdEFubm90
L3NyYy9wL1Rlc3QuamF2YY1TTWvjMBA9O5D/MOxlEwgO+GqW7GWvaaELe1bkcaJW0biS3MSU/vcd
fcRxEwoNjsGamTdv3jx1Qr6IPUJXz2fzmTp2ZD2Q3Zcoteocls+NL4Ux5IVXZMotmW2vdf2tXE4U
O41T6NfyLzpfxaOu32klQWrhHIRjeJ/Pit+5BeTww+4ZpQexk3VRrNdwOqABf1AO+HGhleRPBLSW
LEg6ogPhU4YmGamAMs6jaIBaIBPTU9eGqQub6MLTgXrdgNAnMTjYIVgMnLG51DhxxBFzBYY289l6
XbzHd8EM4RcYPGXKi2UdAx9xqKzF/VRVKEqSFtPxc0ZLtLhW50NawW0eVcsoXxGF9JlJ+Ig80nkF
vppEqhwKWpWJPtVBY2UkWRtgX3slX6BV5xUrYOnkAM8SuyBAqAx/1cLigsDoaZpMZoSuSk9P3iqz
557ALVwSm1UWsH38M91QRx6NV0KHQED5+NTqc58b/ilaw6SFEwP86Cy9qYZX+SZ0j8E6ofpbI1j0
vU2WS+DFFxLdU51Cjgv6CtCZn9m2o9eEgztaG/iHebRQsEd2kcnuP6DF7MsrFeDfVCFeRdWyQhAv
0wB+6EK7Fv2w4WgbxBHa8jKGq8sWewr3im8G8GQh68DkxjCeO3a18svL+HnGm9sQY8yLn/9QSwcI
alDhD+0BAAB5BAAAUEsDBBQACAAIADWX20AAAAAAAAAAAAAAAAAaAAAAVGVzdEFubm90L3NyYy9x
L1Rlc3QyLmphdmGNzD0OwjAMhuGZSLmDR1gyZI2QOEFZuIATTJVinNC46oC4Oz8qgpH1/R59FdMZ
e4JrsMaafKllVChj7yhxro3ccFSHIkVRcxHXFekm5vCXfUKMTO/rOkXOCRJja3Cgph5u1qyWvI8D
JQX1J9iC0LyE9SZ8ze7z96P9a7fmbs0DUEsHCAmpkRF/AAAAyQAAAFBLAwQUAAgACADyldtAAAAA
AAAAAAAAAAAAIQAAAFRlc3RBbm5vdC9zcmMvcS9wYWNrYWdlLWluZm8uamF2YXPIL0rXS03OySwo
TtXLSinRS8zLyy9JLMnMz9Pzy8/zK83Jcap0SU1LLM0p4eUqSEzOTkxPVSi0BgBQSwcI+iw4PDoA
AAA4AAAAUEsBAhQAFAAIAAgA6JDbQP17N4vZAAAAhQEAABQAAAAAAAAAAAAAAAAAAAAAAFRlc3RB
bm5vdC8uY2xhc3NwYXRoUEsBAhQAFAAIAAgAyZDbQDvgk+C/AAAAgQEAABIAAAAAAAAAAAAAAAAA
GwEAAFRlc3RBbm5vdC8ucHJvamVjdFBLAQIUABQACAAIADKR20D48z9RxAQAAG8aAAAuAAAAAAAA
AAAAAAAAABoCAABUZXN0QW5ub3QvLnNldHRpbmdzL29yZy5lY2xpcHNlLmpkdC5jb3JlLnByZWZz
UEsBAhQAFAAIAAgAAJfbQOWelW1IAgAA0wMAABoAAAAAAAAAAAAAAAAAOgcAAFRlc3RBbm5vdC9i
aW4vcC9UZXN0LmNsYXNzUEsBAhQAFAAIAAgANZfbQAN6Za4lAQAAlQEAABsAAAAAAAAAAAAAAAAA
ygkAAFRlc3RBbm5vdC9iaW4vcS9UZXN0Mi5jbGFzc1BLAQIUABQACAAIAPKV20Dr/T6XpAAAAMUA
AAAiAAAAAAAAAAAAAAAAADgLAABUZXN0QW5ub3QvYmluL3EvcGFja2FnZS1pbmZvLmNsYXNzUEsB
AhQAFAAIAAgA6JDbQEsi7b1zGAAAeiEAADsAAAAAAAAAAAAAAAAALAwAAFRlc3RBbm5vdC9vcmcu
ZWNsaXBzZS5qZHQuYW5ub3RhdGlvbl8xLjAuMC4yMDEyMDYyMzIzMjkuamFyUEsBAhQAFAAIAAgA
/ZbbQGpQ4Q/tAQAAeQQAABkAAAAAAAAAAAAAAAAACCUAAFRlc3RBbm5vdC9zcmMvcC9UZXN0Lmph
dmFQSwECFAAUAAgACAA1l9tACamREX8AAADJAAAAGgAAAAAAAAAAAAAAAAA8JwAAVGVzdEFubm90
L3NyYy9xL1Rlc3QyLmphdmFQSwECFAAUAAgACADyldtA+iw4PDoAAAA4AAAAIQAAAAAAAAAAAAAA
AAADKAAAVGVzdEFubm90L3NyYy9xL3BhY2thZ2UtaW5mby5qYXZhUEsFBgAAAAAKAAoABgMAAIwo
AAAAAA==
</data>

          </attachment>
      

    </bug>

</bugzilla>