<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>428019</bug_id>
          
          <creation_ts>2014-02-12 12:36:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Type inference failure with nested generic invocation.</short_desc>
          <delta_ts>2014-02-21 00:21:17 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 8</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Timo Kinnunen">timo.kinnunen</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>jarthana</cc>
    
    <cc>srikanth_sankaran</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2362287</commentid>
    <comment_count>0</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-12 12:36:41 -0500</bug_when>
    <thetext>This test case comes from compiling javac&apos;s unofficial&amp;unsupported Java API from JDK source code; javac compiles it without errors:

@SuppressWarnings(&quot;unused&quot;)
final class Test {
  private static class Key&lt;T&gt; {}
  private static class Context {}
  private static class Obj {}
  private static class Dial&lt;T&gt; {}
  private static interface Factory&lt;T&gt; {T make(Context c);}

  private &lt;T&gt; void put(Key&lt;T&gt; key, Factory&lt;T&gt; fac) {}
  private &lt;T&gt; void put(Key&lt;T&gt; key, T data) {}
  private &lt;T&gt; void put(Class&lt;T&gt; clazz, Factory&lt;T&gt; fac) {}
  private &lt;T&gt; void put(Class&lt;T&gt; clazz, T data) {}

  private static &lt;T&gt; Dial&lt;T&gt; wrap(Dial&lt;T&gt; dl) {return null;}

  static void foo(Dial&lt;? super Obj&gt; dial, Test context) {
    //The method put(Test.Key&lt;T&gt;, Test.Factory&lt;T&gt;) in the type Test is not
    //applicable for the arguments (Class&lt;Test.Dial&gt;, Test.Dial&lt;capture#1-of ? super Test.Obj&gt;)
    context.put(Dial.class, wrap(dial));
  }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363200</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-13 18:47:42 -0500</bug_when>
    <thetext>Shorter test case: 

// --
final class X {
  static class Obj {}
  static class Dial&lt;T&gt; {}

  &lt;T&gt; void put(Class&lt;T&gt; clazz, T data) {
  }

  static &lt;T&gt; Dial&lt;T&gt; wrap(Dial&lt;T&gt; dl) {
	  return null;
  }

  static void foo(Dial&lt;? super Obj&gt; dial, X context) {
    context.put(Dial.class, wrap(dial));
  }
  
  public static void main(String[] args) {
	X.foo(new Dial&lt;Obj&gt;(), new X());
  }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363209</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-13 19:15:53 -0500</bug_when>
    <thetext>Released test GenericsRegressionTest.test428019(): Presently disabled for 1.8,
passes in 1.5 - 1.7.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363221</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-13 23:12:56 -0500</bug_when>
    <thetext>This one may have some interference from raw types too. Dial.class is seen as
a raw type as Dial&lt;?&gt;.class is illegal syntactically. Stephan, thanks for taking
a look.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363311</commentid>
    <comment_count>4</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-14 04:23:27 -0500</bug_when>
    <thetext>Seeing that this code compiles:

final class X {
  static class Obj {}
  static class Dial&lt;T&gt; {}

  &lt;T&gt; void put(Class&lt;T&gt; clazz, T data) {
  }

  static &lt;T&gt; Dial&lt;T&gt; wrap(Dial&lt;T&gt; dl) {
	  return null;
  }

  static void foo(Dial&lt;? super Obj&gt; dial, X context) {
    Dial&lt;? super Obj&gt; wrap = wrap(dial);
    context.put(Dial.class, wrap);
  }
  
  public static void main(String[] args) {
	X.foo(new Dial&lt;Obj&gt;(), new X());
  }
}

I wonder if in this scenario, JLS actually requires us to lift constrains 
from the nested generic invocation and include them in the enclosing 
generic call at all.

In this passage: &quot;If the target type contains inference variables, 
the inference variables and bounds from the nested invocation are &quot;lifted&quot; 
into the outer inference analysis, and dependencies between the outer and 
inner inference variables are inferred&quot; 

is inference variables == type parameters ? 

Asked another way: If the inner method can be completely inferred without the
target type being imposed, should be consider the inner call as a poly 
expression ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363504</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-14 10:35:05 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #4)

&gt; is inference variables == type parameters ? 

Seeing that we have different abstractions for this, it looks reasonable to
conclude they are not. 

FWIW, in JLS7, we enter 15.12.2.8 where target types are considered IFF
15.12.2.7 (15.12.2.7 - Inferring Type Arguments Based on Actual Arguments)
still leaves unresolved type variables.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363765</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-15 08:02:40 -0500</bug_when>
    <thetext>Inference failed to reduce a constraint of the shape C&lt;X&gt; &lt;: C#RAW.

For this kind of constraint (reference types, T is not parameterized) the spec requires to check whether &quot;T is among the supertypes of S&quot;. For lack of an existing implementation for this check I implemented my own little hasSupertype(left,right), which failed to handle the case of one raw type vs. its parameterized variant (and probably was incomplete also in other regards).

Having a proposed new function TB.isSupertypeOf() in the patch for bug 426537 I fetched that implementation and use it instead of the incomplete one and, voil: this bug is resolved.


Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=b6bc90c50286b74cfcc0b4c67c3ded3be552505d</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2366470</commentid>
    <comment_count>7</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-02-21 00:21:17 -0500</bug_when>
    <thetext>Verified for Java 8 RC1 using Kepler SR2 +  
Eclipse Java Development Tools Patch for Java 8 Support (BETA)   
1.0.0.v20140220-2054</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>