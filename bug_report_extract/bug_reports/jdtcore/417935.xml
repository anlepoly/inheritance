<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>417935</bug_id>
          
          <creation_ts>2013-09-24 11:21:00 -0400</creation_ts>
          <short_desc>[1.8][code select] ICU#codeSelect doesn&apos;t work on reference to lambda parameter</short_desc>
          <delta_ts>2013-11-26 04:47:55 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Noopur Gupta">noopur_gupta</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>anchakrk</cc>
    
    <cc>jarthana</cc>
    
    <cc>manju656</cc>
    
    <cc>marcel.bruch</cc>
    
    <cc>markus_keller</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2310332</commentid>
    <comment_count>0</comment_count>
    <who name="Noopur Gupta">noopur_gupta</who>
    <bug_when>2013-09-24 11:21:24 -0400</bug_when>
    <thetext>import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

public class Snippet {

	void foo() {
		Collections.sort(new ArrayList&lt;String&gt;(Arrays.asList(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)),
				new Comparator&lt;String&gt;() {
					@Override
					public int compare(String o1, String o2) {
						return o1.compareTo(o2); //[1]
					}
				});

		Collections.sort(new ArrayList&lt;String&gt;(Arrays.asList(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;)),
				(String o1, String o2) -&gt; o1.compareTo(o2)); //[2]
	}
}
-------------------------

Hover over #compareTo at the specified locations [1] and [2].
Javadoc is shown on hover only at [1] and not at [2].</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2310817</commentid>
    <comment_count>1</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-09-25 12:11:27 -0400</bug_when>
    <thetext>That&apos;s because ICU#codeSelect doesn&apos;t work on references to a lambda parameter (&quot;o1&quot;) nor on method invocations on such a reference (&quot;o1.compareTo&quot;).

I don&apos;t expect that we have to do anything here, so moving this bug to core.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2333888</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-25 05:09:34 -0500</bug_when>
    <thetext>I have a fix for this problem - but it suffers from three issues:

1. There is no java model element corresponding to lambda&apos;s (yet)
As a result, if the selected element is a lambda parameter, it seems
to show up as a child of the enclosing java element:

i.e

Given:

void foo()
    I i = (xyz) -&gt; {
    return xyz;
}

when you select xyz in the return statement, we answer:

&quot;xyz [in foo() [in X [in [Working copy] X.java [in &lt;default&gt; [in src [in Resolve]]]]]]

I don&apos;t know whether this is an issue for UI. The navigation does work correctly
in the IDE.

2. When the lambda parameter types are elided, we don&apos;t always information on
the target type - Selection and completion parsers by design build very minimal
sparse trees with just the bare minimum nodes hierarchically placed in
scopes, declarations and such. This will require a significant rework if
we want to change to include nodes pertinent to context information. Since
the Expression grammar is highly recursive, pretty much every node will be
considered for retention.

As a result of the sparse tree, if you hover over an elided parameter
you won&apos;t get the type information in many situations. That is such a shame,
because this is one of the classic places where hover would be useful/required.

3. I reopened https://bugs.eclipse.org/bugs/show_bug.cgi?id=291040 due
to bad interactions with lambda&apos;s in constructor calls as arguments. This
backing out is only on BETA_JAVA8 and will be repaired before 4.4 ships.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2333924</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-25 07:26:51 -0500</bug_when>
    <thetext>Thanks for the type arguments ;-)

Fix and tests released here:

http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=59b98ddf9de3ca94b46b4e5e55051cbf72bde23a

I raised bug 422468 for discussion and follow up type elided parameter
related issues.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334113</commentid>
    <comment_count>4</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2013-11-25 12:27:01 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #2)
&gt; 1. There is no java model element corresponding to lambda&apos;s (yet)
&gt; As a result, if the selected element is a lambda parameter, it seems
&gt; to show up as a child of the enclosing java element:

I think it&apos;s fine for now to do without a lambda model element. Other scope boundaries are also not available in the Java model (blocks and statements that declare new variables). And even if we had lambda elements, we would have to filter them out e.g. in the Outline, just because they will be so numerous.

&gt; 2. When the lambda parameter types are elided, we don&apos;t always information on
&gt; the target type

I agree bug 422468 is problematic, and I&apos;m looking forward to eventually get the correct type for implicitly-typed lambda variables.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334179</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-11-25 13:50:14 -0500</bug_when>
    <thetext>(In reply to Markus Keller from comment #4)

&gt; I agree bug 422468 is problematic, and I&apos;m looking forward to eventually get
&gt; the correct type for implicitly-typed lambda variables.

The problem looked very complex, but there could be a simple solution: JDT&apos;s
grammar closely follows JLS for this part and there is a single method that
gets entered when an expression statement is reduced by the parser. That should
provide for a clean opportunity to traverse the recovered elements bottom up
and toss out all recovered elements that fall within the range of the expression
statement just reduced and replace them with an instance of a new abstraction
say: RecoveredExpressionStatement - which will simply answer the corresponding
ASTNode for its updatedParseTree() call.

Actually, this opens up exciting possibilities for improving code assist for 
Java 7.

Given the following program:

// --
class X {
	String string;
	
	void goo(String s, int x, int y) {
	 
	}
	void foo() {
		goo(string, 123456, 56789);
	}
}
// --

If you code select or code complete on the first argument to the call to goo,
this is how the recovered parse tree looks like:

class X {
  String string;
  X() {
  }
  void goo(String s, int x, int y) {
  }
  void foo() {
    &lt;SelectOnName:string&gt;;
  }
}

We have completely tossed out the pertinent fact that selection/completion
is happening on a method argument expression. Such a fact is much more
valuable for completion in that we could boost the relevant of certain
proposals based on the parameter type and weed out several others.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2334402</commentid>
    <comment_count>6</comment_count>
    <who name="Marcel Bruch">marcel.bruch</who>
    <bug_when>2013-11-26 04:47:55 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #5)
&gt; We have completely tossed out the pertinent fact that selection/completion
&gt; is happening on a method argument expression. Such a fact is much more
&gt; valuable for completion in that we could boost the relevant of certain
&gt; proposals based on the parameter type and weed out several others.

FWIW:
If I get this proposal right, this one in particular would allow us to build a great parameter completion in recommenders or even a crowdsourced one that ranks variables or static methods/fields (like SWT.* constants in constructors or addListener methods) properly.

For instance, in &quot;new Button(SWT.|&lt;^space&gt;)&quot; --&gt; we could learn that users often used SWT.BORDER, CHECK or RADIO.


In general:
I&apos;d love to get as much information as possible in code selections and code completions. Every single bit more in information will help us to build additional tools on top of this. I don&apos;t mind internal APIs if you don&apos;t want to make this public available.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>