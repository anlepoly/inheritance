<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>429490</bug_id>
          
          <creation_ts>2014-03-03 11:56:00 -0500</creation_ts>
          <short_desc>[1.8] The method addListener(Junk11.ExpressionHelper&lt;Object&gt;, Junk11.ObservableValue&lt;Object&gt;, Junk11.InvalidationListener) is ambiguous for the type Junk11</short_desc>
          <delta_ts>2014-03-06 22:26:24 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS X</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          <blocked>429559</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Steve Northover">snorthov</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      <flag name="review"
          id="61792"
          type_id="1"
          status="+"
          setter="srikanth_sankaran"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2370667</commentid>
    <comment_count>0</comment_count>
    <who name="Steve Northover">snorthov</who>
    <bug_when>2014-03-03 11:56:20 -0500</bug_when>
    <thetext>The following code compiles under JDK8 but not under Eclipse 8:

package junk;

public class Junk11 {
    class Observable&lt;T&gt; {}
    class ObservableValue&lt;T&gt; {}
    interface InvalidationListener {
        public void invalidated(Observable observable);
    }
    public interface ChangeListener&lt;T&gt; {
        void changed(ObservableValue&lt;? extends T&gt; observable, T oldValue, T newValue);
    }
    class ExpressionHelper&lt;T&gt; {}
    public static &lt;T&gt; ExpressionHelper&lt;T&gt; addListener(ExpressionHelper&lt;T&gt; helper, ObservableValue&lt;T&gt; observable, InvalidationListener listener) {
        return helper;
    }
    public static &lt;T&gt; ExpressionHelper&lt;T&gt; addListener(ExpressionHelper&lt;T&gt; helper, ObservableValue&lt;T&gt; observable, ChangeListener&lt;? super T&gt; listener) {
        return helper;
    }
    void junk() {
        addListener(null, null, new InvalidationListener () {
            public void invalidated(Observable o) {throw new RuntimeException();}
        });
        addListener(null, null, (o) -&gt; {throw new RuntimeException();});
    }
}


NOTE:  This is a recent regression.  I updated this morning and got the compile error.  A guess: The single abstract method invalidated() should be selected based on the number of arguments?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2370773</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-03 14:41:46 -0500</bug_when>
    <thetext>Stephan, thanks for taking a look.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2370893</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-03 18:40:06 -0500</bug_when>
    <thetext>This change was caused by a commit on behalf of bug 428811. I made this comment: &quot;For lack of any good excuse I released that change ...&quot;.

I&apos;m happy to see an example where the change makes a difference.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2370905</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-03 19:09:29 -0500</bug_when>
    <thetext>Sorry to say: the implicitly typed lambda is not &quot;pertinent to applicability&quot;.

Type information from this lambda would be used only *after* selecting the most specific applicable method. However, this selection fails and there is no provision for backtracking or the like.

My current understanding: we had a bug, and incidentally produced the same result that also javac is producing, for no good reason as it turns out.

Overload resolution just based on an implicitly typed lambda is not supported (and I&apos;m happy about this - for the sake of comprehensibility).

Let&apos;s keep the bug on the radar for 4.4, so we have time to report a bug against javac and await their excuse for accepting this :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2370907</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-03 19:21:19 -0500</bug_when>
    <thetext>Negative regression test released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=55937e1c59536ae2b5bf5c1974bd9004ae584981</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371077</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 06:18:32 -0500</bug_when>
    <thetext>(In reply to Steve Northover from comment #0)
&gt; A guess: The single abstract method invalidated() should be
&gt; selected based on the number of arguments?

This sounds like a plausible explanation of what javac might be doing. 

I went back to the spec and checked if the section &quot;18.5.4 More Specific Method Inference&quot; bends the term &quot;more specific&quot; to actually pick a selection in this situation. Indeed for functional expressions this section does more than checking whether one is more specific than the other, it additionally checks a few conditions to see if one method is more *appropriate for the given arguments* than the other. (In strict &quot;more specific&quot; analysis, the provided arguments are not considered).

Even the specific treatment of lambdas only applies to explicitly typed lambdas. =&gt; The code should indeed be rejected.

In previous discussions on the EG list, I heard that javac had code for experimental spec rules that have been withdrawn from the spec but the implementation was left in javac. I imagine that this issue is a similar situation.

Using this minimal test: 

@FunctionalInterface
interface FI1 {
	void run(Object o);
}
@FunctionalInterface
interface FI2 {
	void run(Object o1, Object o2);
}
public class Test {
	void m(FI1 f) {
		System.out.println(&quot;m(FI1)&quot;);
	}
	void m(FI2 f) {
		System.out.println(&quot;m(FI2)&quot;);
	}
	public static void main(String[] args) {
		Test t = new Test();
		t.m((o) -&gt; {});
		t.m((o1, o2) -&gt; {});
	}
}

We get these results:
 javac8: accept
 ecj8: 2 &quot;ambiguous&quot; errors

So perhaps indeed the number of lambda arguments is illegally considered during selection.

As a special courtesy for our users I added a new tweak:
  InferenceContext18.CONSIDER_NUM_ARGS_OF_IMPLICIT_LAMBDA_DURING_18_5_4
which tells ecj to behave like javac in this regard and inspect the number of arguments of implicitly typed lambdas.

This tweak should be removed ASAP, but only in coordination with javac.

Ergo: we are now accepting the example in comment 0, but from all I can see this is the WRONG behavior, implemented only to avoid incompatibility. The code should be rewritten into legal Java code.

Tweak released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=fecb7356870e11bfa0606dab85da0b88f89888ac</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371093</commentid>
    <comment_count>6</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 06:46:19 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #5)

Stephan, there is some confusion here:
The minimal test you cite actually *compiles* with eclipse as it should

A lambda expression (15.27) is potentially compatible with a functional interface type (9.8) if all of the following are true: 
- The arity of the targeted type&apos;s function type is the same as the arity of the lambda expression. 
- If the targeted type&apos;s function type has a void return, then the lambda body is either a statement expression (14.8) or a void-compatible block (15.27.2). 
- If the targeted type&apos;s function type has a (non-void) return type, then the lambda body is either an expression or a value-compatible block (15.27.2). 

So I think this needs a relook - the non generic case you cite does not
require a tweak to pass - can you confirm ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371094</commentid>
    <comment_count>7</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 06:48:27 -0500</bug_when>
    <thetext>And I believe potential compatibility check happens before applicability check
at which stage the question of whether an expression is pertinent to applicability 
gets looked into.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371095</commentid>
    <comment_count>8</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 06:50:47 -0500</bug_when>
    <thetext>Note however, that javac is broken in the area of potential compatibility
of lambda expressions and ECJ has deliberately has chosen to emulate the
buggy behavior: 

See https://bugs.eclipse.org/bugs/show_bug.cgi?id=422810 and
https://bugs.openjdk.java.net/browse/JDK-8029718</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371107</commentid>
    <comment_count>9</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 07:23:03 -0500</bug_when>
    <thetext>if you agree, any fix should not be considered a tweak - I think the
involved change may be small enough to be rolled into orthodox fix as
is ? (to preclude a follow up, I am talking about secular orthodoxy here :))</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371116</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 07:48:03 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #6)
&gt; So I think this needs a relook - the non generic case you cite does not
&gt; require a tweak to pass - can you confirm ?

Oops, so this part of the confusion is obviously my fault, I pasted the wrong version of the test, should&apos;ve been:

@FunctionalInterface interface FI1&lt;T&gt; {
  void run(T o); 
}
@FunctionalInterface interface FI2&lt;T&gt; {
  void run(T o1, T o2);
}
public class Test {
	&lt;T&gt; void m(FI1&lt;T&gt; f) {
		System.out.println(&quot;m(FI1)&quot;);
	}
	&lt;T&gt; void m(FI2&lt;T&gt; f) {
		System.out.println(&quot;m(FI2)&quot;);
	}
	public static void main(String[] args) {
		Test t = new Test();
		t.m((String o) -&gt; {});
		t.m((String o1, String o2) -&gt; {});
	}
}

This version does require the tweak to compile in ecj, right?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371120</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 07:58:39 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #7)
&gt; And I believe potential compatibility check happens before applicability
&gt; check at which stage the question of whether an expression is pertinent to
&gt; applicability gets looked into.

This seems to be the core of the problem. Can you point me to the place in our code that implements the potential compatibility checks?

If I understand correctly, you&apos;re saying, inference should never see the method with mismatching arity between the functional interface parameter and the lambda being passed as the corresponding argument?

I was simply trying to mend this inside inference where it clearly isn&apos;t a &quot;fix&quot; but a &quot;tweak&quot;. If that&apos;s the wrong place to change, than the tweak can perhaps be migrated into a fix :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371122</commentid>
    <comment_count>12</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 08:00:02 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #10)

&gt; @FunctionalInterface interface FI1&lt;T&gt; {
&gt;   void run(T o); 
&gt; }
&gt; @FunctionalInterface interface FI2&lt;T&gt; {
&gt;   void run(T o1, T o2);
&gt; }
&gt; public class Test {
&gt; 	&lt;T&gt; void m(FI1&lt;T&gt; f) {
&gt; 		System.out.println(&quot;m(FI1)&quot;);
&gt; 	}
&gt; 	&lt;T&gt; void m(FI2&lt;T&gt; f) {
&gt; 		System.out.println(&quot;m(FI2)&quot;);
&gt; 	}
&gt; 	public static void main(String[] args) {
&gt; 		Test t = new Test();
&gt; 		t.m((String o) -&gt; {});
&gt; 		t.m((String o1, String o2) -&gt; {});
&gt; 	}
&gt; }
&gt; 
&gt; This version does require the tweak to compile in ecj, right?

No, I am still confused - if I backed out the change to InferenceContext18.java
made in http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=fecb7356870e11bfa0606dab85da0b88f89888ac,

the code you have pasted now still compiles.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371124</commentid>
    <comment_count>13</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 08:08:31 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #12)
&gt; No, I am still confused - if I backed out the change to
&gt; InferenceContext18.java
&gt; made in
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA8&amp;id=fecb7356870e11bfa0606dab85da0b88f89888ac,
&gt; 
&gt; the code you have pasted now still compiles.

I&apos;m awfully sorry, should&apos;ve finished the current task before answering here. The test should read:


@FunctionalInterface interface FI1&lt;T&gt; {
  void run(T o); 
}
@FunctionalInterface interface FI2&lt;T&gt; {
  void run(T o1, T o2);
}
public class Test {
	&lt;T&gt; void m(FI1&lt;T&gt; f) {
		System.out.println(&quot;m(FI1)&quot;);
	}
	&lt;T&gt; void m(FI2&lt;T&gt; f) {
		System.out.println(&quot;m(FI2)&quot;);
	}
	public static void main(String[] args) {
		Test t = new Test();
		t.m((o) -&gt; {});
		t.m((o1,o2) -&gt; {});
	}
}

I.e.: *with* generics and *without* explicit types in the lambda.

At commit 1f1c7c285f7f6d962c03df0c90855f08aed5d7d3 ecj answers:
----------
1. ERROR in /tmp/Test.java (at line 16)
        t.m((o) -&gt; {});
          ^
The method m(FI1&lt;Object&gt;) is ambiguous for the type Test
----------
2. ERROR in /tmp/Test.java (at line 17)
        t.m((o1,o2) -&gt; {});
          ^
The method m(FI1&lt;Object&gt;) is ambiguous for the type Test
----------
2 problems (2 errors)


is this reproduceable on your side?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371127</commentid>
    <comment_count>14</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 08:12:19 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #11)
&gt; (In reply to Srikanth Sankaran from comment #7)
&gt; &gt; And I believe potential compatibility check happens before applicability
&gt; &gt; check at which stage the question of whether an expression is pertinent to
&gt; &gt; applicability gets looked into.
&gt; 
&gt; This seems to be the core of the problem. Can you point me to the place in
&gt; our code that implements the potential compatibility checks?

We don&apos;t have a separate phase to determine potentially compatible methods.
In the JLS7 world, it is merged with computeCompatibleMethod() this will
never return a valid binding if there are arity mismatches. Perhaps this
unstated but widely relied upon post variant is what could causing Scope.mSMB
to be entered with inapplicable methods sometimes.

In the case of Lambdas as arguments to non generic methods they continue
to be weeded out under computeCompatibleMethod with the lambda argument
arity check happening in:

LambdaExpression.isCompatibleWith(TypeBinding, Scope) line: 698	
MethodScope(Scope).compatibilityLevel18FromInner(MethodBinding, InnerInferenceHelper, Expression, TypeBinding, int, int, boolean[]) line: 890	
MethodScope(Scope).parameterCompatibilityLevel18(MethodBinding, TypeBinding[], boolean, InvocationSite) line: 797	
MethodScope(Scope).computeCompatibleMethod(MethodBinding, TypeBinding[], InvocationSite, int, boolean) line: 759	
MethodScope(Scope).computeCompatibleMethod(MethodBinding, TypeBinding[], InvocationSite, int) line: 698	
MethodScope(Scope).findMethod0(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1763	
MethodScope(Scope).findMethod(ReferenceBinding, char[], TypeBinding[], InvocationSite, boolean) line: 1664	


&gt; If I understand correctly, you&apos;re saying, inference should never see the
&gt; method with mismatching arity between the functional interface parameter and
&gt; the lambda being passed as the corresponding argument?

Yep

&gt; I was simply trying to mend this inside inference where it clearly isn&apos;t a
&gt; &quot;fix&quot; but a &quot;tweak&quot;. If that&apos;s the wrong place to change, than the tweak can
&gt; perhaps be migrated into a fix :)

To summarize, it does appear to be en ECJ bug that is playing out here.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371131</commentid>
    <comment_count>15</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 08:17:26 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #14)

&gt; &gt; If I understand correctly, you&apos;re saying, inference should never see the
&gt; &gt; method with mismatching arity between the functional interface parameter and
&gt; &gt; the lambda being passed as the corresponding argument?
&gt; 
&gt; Yep

To be clear - it is not just arity incompatibilities that should
eliminate candidates with functional interface types that don&apos;t match the
actual lambda argument aritywise - it is all the factors that go into the shape 
of the lambda - i.e value/void compatibility also plays a role there - but
this is the part that is completely unimplemented by javac as acknowledged
in the bug https://bugs.openjdk.java.net/browse/JDK-8029718

See my comment in LE.774:

// This check should happen after return type check below, but for buggy javac compatibility we have left it in.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371137</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 08:27:35 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #14)
&gt; We don&apos;t have a separate phase to determine potentially compatible methods.
&gt; In the JLS7 world, it is merged with computeCompatibleMethod() this will
&gt; never return a valid binding if there are arity mismatches. Perhaps this
&gt; unstated but widely relied upon post variant is what could causing Scope.mSMB
&gt; to be entered with inapplicable methods sometimes.
&gt; 
&gt; In the case of Lambdas as arguments to non generic methods they continue
&gt; to be weeded out under computeCompatibleMethod with the lambda argument
&gt; arity check happening in:
&gt; 
&gt; LambdaExpression.isCompatibleWith(TypeBinding, Scope) line: 698	
&gt; MethodScope(Scope).compatibilityLevel18FromInner(MethodBinding,
&gt; InnerInferenceHelper, Expression, TypeBinding, int, int, boolean[]) line:
&gt; 890	
&gt; MethodScope(Scope).parameterCompatibilityLevel18(MethodBinding,
&gt; TypeBinding[], boolean, InvocationSite) line: 797	
&gt; MethodScope(Scope).computeCompatibleMethod(MethodBinding, TypeBinding[],
&gt; InvocationSite, int, boolean) line: 759	
&gt; MethodScope(Scope).computeCompatibleMethod(MethodBinding, TypeBinding[],
&gt; InvocationSite, int) line: 698	
&gt; MethodScope(Scope).findMethod0(ReferenceBinding, char[], TypeBinding[],
&gt; InvocationSite, boolean) line: 1763	
&gt; MethodScope(Scope).findMethod(ReferenceBinding, char[], TypeBinding[],
&gt; InvocationSite, boolean) line: 1664	
&gt; 
&gt; 
&gt; &gt; If I understand correctly, you&apos;re saying, inference should never see the
&gt; &gt; method with mismatching arity between the functional interface parameter and
&gt; &gt; the lambda being passed as the corresponding argument?
&gt; 
&gt; Yep

Thanks, I understand this better, now.

Can you recommend, how to mend this going forward?

We don&apos;t really want to perform inference for methods whose arguments are not even potentially compatible.

Checks for potential compatibility are triggered from the parameterCompatibilityLevel family of methods, which is called as the *last* thing in computeCompatibleMethod(), i.e., after applicability inference is done and finished, and finally once more from mSMB().

Would you prefer:
- to simply revert my change from bug 428811?, or
- to add another round of checks *before* inference?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371142</commentid>
    <comment_count>17</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 08:35:21 -0500</bug_when>
    <thetext>To add insult to injury I forgot to enable my tweak before committing. To let tests pass for now I flipped the switch via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=95cf1c51bda98298c8465ff64b742f30d6302c1e

All to be reverted shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371149</commentid>
    <comment_count>18</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 08:40:07 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #13)

&gt; 2 problems (2 errors)
&gt; 
&gt; 
&gt; is this reproduceable on your side?

Yes. And if CONSIDER_NUM_ARGS_OF_IMPLICIT_LAMBDA_DURING_18_5_4 to true, it compiles fine.

So perhaps constant propagating it with true may be a fix already.

The ideal situation however is to weed out such mismatched candidates out of
reckoning as early possible so they don&apos;t cause interference of any kind. If
that calls for too much and if right results could be obtained by still having
them in contention with the code under CONSIDER_NUM_ARGS_OF_IMPLICIT_LAMBDA_DURING_18_5_4 set to true &quot;handling&quot;
them, that could be an interim solution too.

(In reply to Stephan Herrmann from comment #16)

&gt; Can you recommend, how to mend this going forward?
&gt; 
&gt; We don&apos;t really want to perform inference for methods whose arguments are
&gt; not even potentially compatible.

Per above, ideal situation is to knock them out of contention as early as
possible. If finding the right place to do that is going to require work
or carry with risks given the time frame, then we need to ask, can we safely
chug them along and still eliminate them with such code as you have put in.

&gt; Would you prefer:
&gt; - to simply revert my change from bug 428811?, or

Would you consider flipping the initializer of CONSIDER* to true to be
a fix in itself ? That would be the &quot;chug along needless baggage, but still
do the right thing&quot; model we can settle for now ? 

&gt; - to add another round of checks *before* inference?

I am fine with this too, it is all going to boil down to can we come
up with a clean place as early as possible where such candidates could
be eliminated. And what the risks of the change are.

OK, lots of midair collisions, let us see if that one flies and lands :)

[Nope, that crashed too :)]

(In reply to Stephan Herrmann from comment #17)
&gt; To add insult to injury I forgot to enable my tweak before committing.

I wondered about that.

&gt; All to be reverted shortly.

Why ? Wouldn&apos;t this cover all cases where we should eliminate incompatible
entries ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371158</commentid>
    <comment_count>19</comment_count>
    <who name="Steve Northover">snorthov</who>
    <bug_when>2014-03-04 08:54:16 -0500</bug_when>
    <thetext>I am assuming that this will get fixed and that once again, OpenJFX will compile clean (except for the &lt;?&gt; verses &lt;? extends Object&gt; issue that is covered elsewhere)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371164</commentid>
    <comment_count>20</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 08:59:52 -0500</bug_when>
    <thetext>(In reply to Steve Northover from comment #19)
&gt; I am assuming that this will get fixed and that once again, OpenJFX will
&gt; compile clean (except for the &lt;?&gt; verses &lt;? extends Object&gt; issue that is
&gt; covered elsewhere)?

Stephan released a commit just now http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=95cf1c51bda98298c8465ff64b742f30d6302c1e

that compiles the test case from comment#0.

We are evaluating whether that is good enough or a more ideal solution (from 
an implementation pov) could be devised.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371194</commentid>
    <comment_count>21</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 09:37:17 -0500</bug_when>
    <thetext>Now it was my turn to collide in this crowded airspace :)

----

Let me try to describe the options I see in a way that let&apos;s you take a pick:

(A) Before bug 428811 the preamble of mSMB weeded out any methods, where any invocation argument is not compatible to the corresponding parameter. This should cover all issues of &quot;potential compatibility&quot;, but does it later than we want, it actually fires the warning &quot;(Recovered) Internal inconsistency while checking invocation ambiguity&quot;.

(B) As of bug 428811 I disabled these checks for arguments that are not pertinent to applicability. This left us with necessary checks missing.

(C) With the CONSIDER* flag I added the option to only check for arity mismatches. Still the checks are done late, even slightly later than in (A): during more specific method inference. This option does not cover any of the other criteria for potential compatibility.

(D) According to my book the orthodox way would be to let LE provide a dedicated function isPotentiallyCompatible(TypeBinding), which would do most of what LE.isCompatibleWith() does, but *without* invoking copy.resolveType(), IFF such a method can be meaningfully implemented. That function would be called before inference starts (similar for RE, of course). I made a quick experiment in using the existing isCompatibleWith() for checks prior to type inference. As expected this rejects way too many good methods, because we don&apos;t yet have a good target type for doing full checks.

 
My personal humble judgement as of now:

(A) Regression fixed, go back to a tested version, just one thing changed: I learned that we apply criteria for method selection in a somewhat unorthodox order :) - And: we should disable our safety-net-warning before GA, since we know a reason why we may get there.

(B) Regression.

(C) Specific regression fixed, potentially similar regressions persist regarding other criteria of &quot;potentially applicable&quot;.

(D) Probably too expensive for now.



Should I go back to square one?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371207</commentid>
    <comment_count>22</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 09:53:43 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #21)

&gt; (C) With the CONSIDER* flag I added the option to only check for arity
&gt; mismatches. Still the checks are done late, even slightly later than in (A):
&gt; during more specific method inference. This option does not cover any of the
&gt; other criteria for potential compatibility.

&gt; (C) Specific regression fixed, potentially similar regressions persist
&gt; regarding other criteria of &quot;potentially applicable&quot;.


I presume (C) describes HEAD.

Could you clarify what you mean by &quot;other criteria for potential 
compatibility.&quot; ?

If you are referring to the second and third bullets from the citation
in https://bugs.eclipse.org/bugs/show_bug.cgi?id=429490#c6, then I won&apos;t
worry about it - javac has admitted to not implementing it generic method
or otherwise.

Thanks for the write up, I&apos;ll study it later today and share my opinions.
Now I need to head out for a hot dinner :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371226</commentid>
    <comment_count>23</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 10:12:50 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #22)
&gt; I presume (C) describes HEAD.

Yes.
 
&gt; Could you clarify what you mean by &quot;other criteria for potential 
&gt; compatibility.&quot; ?
&gt; 
&gt; If you are referring to the second and third bullets from the citation
&gt; in https://bugs.eclipse.org/bugs/show_bug.cgi?id=429490#c6, then I won&apos;t
&gt; worry about it - javac has admitted to not implementing it generic method
&gt; or otherwise.

Yes, again.

For posterity, we&apos;re talking about 
   &quot;15.12.2.1 Identify Potentially Applicable Methods&quot;,
which also has one more item for lambdas further down:
    &quot;A lambda expression or a method reference is potentially compatible 
    with a type variable if the type variable is a type parameter of the
    candidate method.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371235</commentid>
    <comment_count>24</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 10:21:30 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #21)

&gt; (D) According to my book the orthodox way would be to let LE provide a
&gt; dedicated function isPotentiallyCompatible(TypeBinding), which would do most
&gt; of what LE.isCompatibleWith() does, but *without* invoking
&gt; copy.resolveType(), IFF such a method can be meaningfully implemented. That

But what is the TypeBinding argument passed in in this case ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371238</commentid>
    <comment_count>25</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 10:26:22 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #24)
&gt; (In reply to Stephan Herrmann from comment #21)
&gt; 
&gt; &gt; (D) According to my book the orthodox way would be to let LE provide a
&gt; &gt; dedicated function isPotentiallyCompatible(TypeBinding), which would do most
&gt; &gt; of what LE.isCompatibleWith() does, but *without* invoking
&gt; &gt; copy.resolveType(), IFF such a method can be meaningfully implemented. That
&gt; 
&gt; But what is the TypeBinding argument passed in in this case ?

I believe we should use the parameter of the original method, with no substitutions. See that potential compatibility has special provision for handling a type variable as the target type.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371295</commentid>
    <comment_count>26</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 11:28:11 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #25)
&gt; (In reply to Srikanth Sankaran from comment #24)
&gt; &gt; (In reply to Stephan Herrmann from comment #21)
&gt; &gt; 
&gt; &gt; &gt; (D) According to my book the orthodox way would be to let LE provide a
&gt; &gt; &gt; dedicated function isPotentiallyCompatible(TypeBinding), which would do most
&gt; &gt; &gt; of what LE.isCompatibleWith() does, but *without* invoking
&gt; &gt; &gt; copy.resolveType(), IFF such a method can be meaningfully implemented. That
&gt; &gt; 
&gt; &gt; But what is the TypeBinding argument passed in in this case ?
&gt; 
&gt; I believe we should use the parameter of the original method, with no
&gt; substitutions. See that potential compatibility has special provision for
&gt; handling a type variable as the target type.

(Not for immediate follow up action)

Then this would appear to simply collapse to isCompatibleWith augmented to 
answer yes for the TVB case.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371305</commentid>
    <comment_count>27</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 11:47:19 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #21)

&gt; Let me try to describe the options I see in a way that let&apos;s you take a pick:

OK, it took me a while to understand the chronology - it looks a no-brainer
option to me that we should back out the changes made in (B) and back out
the changes made in (C) to work around the bug caused by (B) and address (D)
post GA.
 
&gt; My personal humble judgement as of now:

&gt; (A) Regression fixed, go back to a tested version, just one thing changed: I
&gt; learned that we apply criteria for method selection in a somewhat unorthodox
&gt; order :) - And: we should disable our safety-net-warning before GA, since we
&gt; know a reason why we may get there.


&gt; Should I go back to square one?

Just to avoid all ambiguity: This would be (A) right ? The reason for being
paranoid and asking is that the phrase &quot;Regression fixed&quot; - I think you meant
to say (A) Predates the regression or that going back to it would take care of 
the regression.

Again, to me this looks the safest option. As you point out (A) also represents
a state that has enjoyed wide testing.

If we are agreement, please proceed to follow up, pull up this bug back to
BETA_J8 and resolve by reverting the changes we are agreeing should be reverted.

Thanks for detailing the options Stephan.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371311</commentid>
    <comment_count>28</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 11:59:55 -0500</bug_when>
    <thetext>Yes, 
    &quot;square one&quot; = (A), 
    &quot;regression fixed&quot; = &quot;fixed by reverting to pre-regression state&quot;.

I&apos;ll do as you suggest, once I come to a stable state in bug 426537.

As you say &quot;address (D) post GA&quot;, do you want a fresh new bug for that, or OK to leave this bug exactly in it&apos;s current state? (while still releasing the planned changes).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371319</commentid>
    <comment_count>29</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 12:05:31 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #28)
&gt; Yes, 
&gt;     &quot;square one&quot; = (A), 
&gt;     &quot;regression fixed&quot; = &quot;fixed by reverting to pre-regression state&quot;.
&gt; 
&gt; I&apos;ll do as you suggest, once I come to a stable state in bug 426537.

Thanks, 

&gt; As you say &quot;address (D) post GA&quot;, do you want a fresh new bug for that,

I think a fresh bug that captures the essence of what we are trying to do
would be better.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371320</commentid>
    <comment_count>30</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 12:06:47 -0500</bug_when>
    <thetext>Pulling this up back to J8 GA. As agreed upon we are reverting to pre-regression state by pulling back the change that caused the regression as well subsequent
attempts to mend/repair the regression.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371519</commentid>
    <comment_count>31</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-04 18:45:39 -0500</bug_when>
    <thetext>Cleanup released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=a209f427039b5b4db27a67f609cb706801ba28e5

- revert the change from bug 428811

- revert the tweak/repair from this bug, comment 5

- disabled the warning
  &quot;(Recovered) Internal inconsistency while checking invocation ambiguity&quot;
  because this is now explained and regular behavior

- filed bug 429617 for follow-up.

Wow, ever heard of life-long learning? ;-)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371567</commentid>
    <comment_count>32</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-04 23:35:56 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #31)
&gt; Cleanup released via
&gt; http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/
&gt; ?h=BETA_JAVA8&amp;id=a209f427039b5b4db27a67f609cb706801ba28e5
&gt; 
&gt; - revert the change from bug 428811
&gt; 
&gt; - revert the tweak/repair from this bug, comment 5
&gt; 
&gt; - disabled the warning
&gt;   &quot;(Recovered) Internal inconsistency while checking invocation ambiguity&quot;
&gt;   because this is now explained and regular behavior
&gt; 
&gt; - filed bug 429617 for follow-up.

OK, just to be safe, I reviewed the revert process and it looks good.

Thanks Stephan,

Thanks Steve, sorry about the churn.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2371973</commentid>
    <comment_count>33</comment_count>
    <who name="Steve Northover">snorthov</who>
    <bug_when>2014-03-05 11:56:18 -0500</bug_when>
    <thetext>Unfortunately, this is not quite fixed:

package junk;

public class Junk12 {
    class Observable&lt;T&gt; {}
    class ObservableValue&lt;T&gt; {}
    interface InvalidationListener {
        public void invalidated(Observable observable);
    }
    public interface ChangeListener&lt;T&gt; {
        void changed(ObservableValue&lt;? extends T&gt; observable, T oldValue, T newValue);
    }
    class ExpressionHelper&lt;T&gt; {}
    public static &lt;T&gt; ExpressionHelper&lt;T&gt; addListener(ExpressionHelper&lt;T&gt; helper, ObservableValue&lt;T&gt; observable, InvalidationListener listener) {
        return helper;
    }
    public static &lt;T&gt; ExpressionHelper&lt;T&gt; addListener(ExpressionHelper&lt;T&gt; helper, ObservableValue&lt;T&gt; observable, ChangeListener&lt;? super T&gt; listener) {
        return helper;
    }
    void junk() {
        addListener(null, null, new ChangeListener () {
            public void changed(ObservableValue observable, Object oldValue, Object newValue) {
                throw new RuntimeException();
            }
        });
        addListener(null, null, (value, o1, o2) -&gt; {throw new RuntimeException();});
    }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372024</commentid>
    <comment_count>34</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-05 13:42:14 -0500</bug_when>
    <thetext>(In reply to Steve Northover from comment #33)
&gt; Unfortunately, this is not quite fixed:

Is that a regression, too, or is that s.t. that never worked?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372097</commentid>
    <comment_count>35</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-03-05 16:28:34 -0500</bug_when>
    <thetext>(In reply to Steve Northover from comment #33)
&gt; Unfortunately, this is not quite fixed:

Thanks for checking, I can see that the version tagged P20140305-1600 indeed had Junk11 fixed and Junk12 broken. This version reflects the state after comment 17, but without the final fix from comment 31.

In HEAD the test passes. I released the additional test via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=d57293f4f12e1bef48b48f8eb4effbb7e4554bd3.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372110</commentid>
    <comment_count>36</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-05 16:58:30 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #35)
&gt; (In reply to Steve Northover from comment #33)
&gt; &gt; Unfortunately, this is not quite fixed:
&gt; 
&gt; Thanks for checking, I can see that the version tagged P20140305-1600 indeed
&gt; had Junk11 fixed and Junk12 broken. This version reflects the state after
&gt; comment 17, but without the final fix from comment 31.

Thanks Stephan.

Given the lateness of the hour - I double checked on head and confirm it compiles
without errors.

Steve, Thanks in advance for verifying against the next build.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372553</commentid>
    <comment_count>37</comment_count>
    <who name="Steve Northover">snorthov</who>
    <bug_when>2014-03-06 11:34:40 -0500</bug_when>
    <thetext>I have updated and can confirm that this regression is fixed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372756</commentid>
    <comment_count>38</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-03-06 22:26:24 -0500</bug_when>
    <thetext>Verified as working for Eclipse + Java 8 RC2 using Kepler SR1 +   
Eclipse Java Development Tools Patch for Java 8 Support (BETA)
1.0.0.v20140306-1935</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>