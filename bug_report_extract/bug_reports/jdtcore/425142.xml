<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>425142</bug_id>
          
          <creation_ts>2014-01-08 18:39:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] NPE in ConstraintTypeFormula.reduceSubType</short_desc>
          <delta_ts>2014-01-09 08:41:27 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 8</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          
          <blocked>424053</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Timo Kinnunen">timo.kinnunen</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2347216</commentid>
    <comment_count>0</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-01-08 18:39:21 -0500</bug_when>
    <thetext>Whilst optimizing for least ambiguity in overloaded methods with most flexibility in how an API might let them be called I listed all the options that I could think of and got a lot of these exceptions. I&apos;m not sure which of the 10 cause it so the test class is a bit bigger:

package npe.ConstraintTypeFormula.reduceSubType.line201;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.function.Consumer;

@FunctionalInterface interface Use&lt;T, E extends Throwable&gt; {   void accept(T t) throws E; }

@SuppressWarnings(&quot;unused&quot;) public class SomethingBreaks&lt;T, E extends Throwable&gt; {
  protected static SomethingBreaks&lt;String, IOException&gt; stream() {     return null;  }

  public void forEach(Consumer&lt;T&gt; use) throws E {}

  public &lt;E2 extends E&gt; void forEach(Use&lt;T, E2&gt; use) throws E, E2 {}

  private static void methodReference(String s) throws IOException {
    System.out.println(Files.size(Paths.get(s)));
  }
  
  public static void useCase1() throws IOException {
    Use&lt;String, IOException&gt; c =
      (String s) -&gt; System.out.println(Files.size(Paths.get(s)));
    stream().forEach(c);
  }
  
  public static void useCase2() throws IOException {
    Use&lt;String, IOException&gt; c = SomethingBreaks::methodReference;
    stream().forEach(c);
  }
  
  public static void useCase3() throws IOException {
    stream().forEach((Use&lt;String, IOException&gt;) (String s) -&gt; System.out.println(Files.size(Paths.get(s))));
  }
  
  public static void useCase4() throws IOException {
    stream().forEach((Use&lt;String, IOException&gt;) SomethingBreaks::methodReference);
  }
  
  public static void useCase5() throws IOException {
    stream().&lt;IOException&gt; forEach((String s) -&gt; System.out.println(Files.size(Paths.get(s))));
  }
  
  public static void useCase6() throws IOException {
    stream().&lt;IOException&gt; forEach(SomethingBreaks::methodReference);
  }
  
  public static void useCase7() throws IOException {
    stream().&lt;Use&lt;String, IOException&gt;&gt; forEach((String s) -&gt; System.out.println(Files.size(Paths.get(s))));
  }
  
  public static void useCase8() throws IOException {
    stream().&lt;Use&lt;String, IOException&gt;&gt; forEach(SomethingBreaks::methodReference);
  }
  
  public static void useCase9() throws IOException {
    stream().forEach((String s) -&gt; System.out.println(Files.size(Paths.get(s))));
  }
  
  public static void useCase10() throws IOException {
    stream().forEach(SomethingBreaks::methodReference);
  }
}


This is the stack trace:
java.lang.NullPointerException
	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduceSubType(ConstraintTypeFormula.java:201)
	at org.eclipse.jdt.internal.compiler.lookup.ConstraintTypeFormula.reduce(ConstraintTypeFormula.java:85)
	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:587)
	at org.eclipse.jdt.internal.compiler.lookup.BoundSet.reduceOneConstraint(BoundSet.java:603)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.reduce(InferenceContext18.java:541)
	at org.eclipse.jdt.internal.compiler.lookup.InferenceContext18.solve(InferenceContext18.java:526)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedGenericMethodBinding.computeCompatibleMethod(ParameterizedGenericMethodBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:717)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.computeCompatibleMethod(Scope.java:673)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findMethod(Scope.java:1630)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getMethod(Scope.java:2752)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.findMethodBinding(MessageSend.java:852)
	at org.eclipse.jdt.internal.compiler.ast.MessageSend.resolveType(MessageSend.java:684)
	at org.eclipse.jdt.internal.compiler.ast.Expression.resolve(Expression.java:1016)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:620)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:303)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:531)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1211)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1321)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:570)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:1207)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.resolve(CompilationUnitResolver.java:692)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1186)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:812)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider$1.run(ASTProvider.java:549)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:42)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.createAST(ASTProvider.java:542)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:485)
	at org.eclipse.jdt.internal.ui.javaeditor.ASTProvider.getAST(ASTProvider.java:475)
	at org.eclipse.jdt.ui.SharedASTProvider.getAST(SharedASTProvider.java:132)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:170)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:155)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:53)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2347219</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-08 18:51:54 -0500</bug_when>
    <thetext>thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2347440</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-01-09 08:41:27 -0500</bug_when>
    <thetext>We were creating a type constraint from the type of an unresolved lambda.
That&apos;s where null comes into play and later explodes.

Fix consists of two steps:

- don&apos;t assume resolved when this.shapeAnalysisComplete is set

- add missing  FE.getExpressionContext() (was constantly answering 
  VANILLA_CONTEXT from Statement.getExpressionContext() )

Released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=c1cf01c530411de2efbd387e25a51a976ee057a9</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>