<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>392238</bug_id>
          
          <creation_ts>2012-10-17 17:45:00 -0400</creation_ts>
          <short_desc>[1.8][compiler][null] Detect semantically invalid null type annotations</short_desc>
          <delta_ts>2014-03-07 01:42:17 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.3</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>BETA J8</target_milestone>
          <dependson>391331</dependson>
          <blocked>392099</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Stephan Herrmann">stephan.herrmann</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>noopur_gupta</cc>
    
    <cc>srikanth_sankaran</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2173258</commentid>
    <comment_count>0</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-17 17:45:15 -0400</bug_when>
    <thetext>Null annotations used via TYPE_USE are not meaningful in all locations that are syntactically valid.

Specifically for nested types saying 
  my.pack.age. @Nullable Outer. @NonNull Inner
does not denote anything useful:
- if Inner is a static nested class than no instance of Outer is involved
- if Inner is a non-static inner class than the enclosing instance
  must implicitly exist for any reference to an Inner
Neither case features a reference to an Outer that can optionally be null.

Rejecting such combinations also avoids the ambiguity that would arise in situations like this:

  void foo(@Nullable Outer. @NonNull Inner arg)

where the @Nullable annotation could apply to the Outer part of the type *and* to the entire argument declaration. With latest moves in the spec, where this annotation would be duplicated into both kinds (SE7 and 308) annotations, this would be contradictory.

In this bug I will investigate what other uses must be rejected for null annotations, too.

I consider to treat these &apos;malformed&apos; declarations like this:
- with annotation based null analysis disabled: accept
- with annotation based null analysis enabled: report as error, 
  because we don&apos;t want to define rules how to continue analysis
  starting from such contradictory declarations</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2173285</commentid>
    <comment_count>1</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-17 18:48:50 -0400</bug_when>
    <thetext>x-ref: bug 391331 mentions the replication of mixed SE7/SE8 annotations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2173334</commentid>
    <comment_count>2</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-10-17 21:29:03 -0400</bug_when>
    <thetext>(In reply to comment #0)

&gt; Specifically for nested types saying 
&gt;   my.pack.age. @Nullable Outer. @NonNull Inner

Nitpicking: The annotations on the left most type should precede
its package name and cannot be specified just before the type as
would be the case for inner types:

my.pack.age. @Nullable Outer. @NonNull Inner // illegal

@Nullable my.pack.age. Outer. @NonNull Inner // legal</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2174414</commentid>
    <comment_count>3</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-19 18:57:02 -0400</bug_when>
    <thetext>More useless constructs (from bug 392099 comment 15);

  - cast &quot;(@Nullable X&lt;T&gt;)x&quot; (cannot insert dynamic check)
  - (x instanceof @Nullable X&lt;T&gt;) (if it succeeds value cannot be null)
  - alloc: &quot;new @Nullable X&lt;T&gt;()&quot; - cannot be null :)

These should be rejected, but severity might be lower than the example in comment 0, since after the errors here, analysis can safely continue by just ignoring the bogus annotations.

All these will need to be documented in the annotation JavaDoc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2176069</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2012-10-25 15:26:55 -0400</bug_when>
    <thetext>(In reply to comment #2)
&gt; (In reply to comment #0)
&gt; 
&gt; &gt; Specifically for nested types saying
&gt; &gt;   my.pack.age. @Nullable Outer. @NonNull Inner
&gt; 
&gt; Nitpicking: The annotations on the left most type should precede
&gt; its package name and cannot be specified just before the type as
&gt; would be the case for inner types:
&gt; 
&gt; my.pack.age. @Nullable Outer. @NonNull Inner // illegal
&gt; 
&gt; @Nullable my.pack.age. Outer. @NonNull Inner // legal

Sure.

A general solution for this analysis depends on bug 391331.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2176149</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2012-10-25 23:23:07 -0400</bug_when>
    <thetext>(In reply to comment #4)
&gt; (In reply to comment #2)
&gt; &gt; (In reply to comment #0)
&gt; &gt; 
&gt; &gt; &gt; Specifically for nested types saying
&gt; &gt; &gt;   my.pack.age. @Nullable Outer. @NonNull Inner
&gt; &gt; 
&gt; &gt; Nitpicking: The annotations on the left most type should precede
&gt; &gt; its package name and cannot be specified just before the type as
&gt; &gt; would be the case for inner types:
&gt; &gt; 
&gt; &gt; my.pack.age. @Nullable Outer. @NonNull Inner // illegal
&gt; &gt; 
&gt; &gt; @Nullable my.pack.age. Outer. @NonNull Inner // legal
&gt; 
&gt; Sure.

As noted elsewhere, we are approaching the 308 EG with a request to change
this so annotations precede the type name and not the package name.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2234860</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-03-21 08:38:52 -0400</bug_when>
    <thetext>From bug 403816 comment 5:
&gt; (In reply to comment #0)
&gt; &gt; 	@Deprecated @NonNull String s  = new @NonNull String();
&gt; 
&gt; Stephan, do/should we emit an unnecessary @NonNull annotation for the
&gt; annotation just after new ? Likewise an error for new @Nullable String() ?

I&apos;ll take care of these, when coming back to this bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2279206</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-06-30 13:12:56 -0400</bug_when>
    <thetext>Using the target_type table from the JSR 308 class file encoding for a 
systematic approach I think we can rule out the following locations:

cannot be nullable:
- METHOD_RECEIVER
- THROWS
- EXCEPTION_PARAMETER (in catch)
- INSTANCE_OF
- NEW
- CONSTRUCTOR_REFERENCE (receiver)
- METHOD_REFERENCE (receiver)


not applicable otherwise
- CLASS_EXTENDS
  nullness is a matter of type use not class declaration, we don&apos;t allow
  &quot;@Nullable class NotOptional { }&quot; to begin with.
- CAST
  cannot insert dynamic check for cast to @NonNull T

For some of these it may still be relevant to support null annotations for
type details (type arguments / array dimensions), e.g.:
  class Foo implements List&lt;@Nullable String&gt; { ... }

even this is useless for
- INSTANCE_OF
- CAST (? - would *always* be unchecked)
- THROWS,
  EXCEPTION_PARAMETER (exceptions cannot be generic / arrays)

I hope this makes sense to everybody.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2294626</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-14 05:52:48 -0400</bug_when>
    <thetext>Via bug 392099 I&apos;m already detecting the following locations as illegal for
null annotations:
- TypeDeclaration
- ConstructorDeclaration

The error message is

  The nullness annotation &apos;&apos;{0}&apos;&apos; is not applicable at this location

I believe that this should always be reported as an error if annotation-based
null analysis is enabled, or does anyone see a reason for making this
configurable?

Detection for more locations to follow after committing bug 392099.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298728</commentid>
    <comment_count>9</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-25 12:47:25 -0400</bug_when>
    <thetext>(In reply to comment #8)
&gt; Via bug 392099 I&apos;m already detecting the following locations as illegal for
&gt; null annotations:
&gt; - TypeDeclaration

This is not strictly necessary. We could accept a nullness annotation on a type declaration as specifying that this type must always be used with this annotation
(explicit or implicit). So, we could specify that null is *never* a valid value for type Person:
   @NonNull class Person { ... }

I&apos;m not sure about the benefit of such interpretation and leave this for a future RFE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298729</commentid>
    <comment_count>10</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-08-25 12:55:01 -0400</bug_when>
    <thetext>(In reply to comment #9)
&gt; (In reply to comment #8)
&gt; &gt; Via bug 392099 I&apos;m already detecting the following locations as illegal for
&gt; &gt; null annotations:
&gt; &gt; - TypeDeclaration
&gt; 
&gt; This is not strictly necessary. We could accept a nullness annotation on a
&gt; type declaration as specifying that this type must always be used with this
&gt; annotation
&gt; (explicit or implicit). So, we could specify that null is *never* a valid
&gt; value for type Person:
&gt;    @NonNull class Person { ... }
&gt; 
&gt; I&apos;m not sure about the benefit of such interpretation and leave this for a
&gt; future RFE.

Sec 2.3 states:

A type annotation (one meta-annotated with @Target(ElementType.TYPE USE)) is permitted to be written anywhere
@Target(ElementType.TYPE) or @Target(ElementType.TYPE PARAMETER) would permitthat is, on a class,
interface, or enum declaration, or on a type parameter declaration. Strictly speaking, these are declaration
sites, not uses of a type. However, it is convenient to write a type annotation at a type declaration, as shorthand
for applying it at all uses. For example, @Interned class MyClass { ... } could indicate that all uses
of MyClass are interned, even though for other classes some instances may be interned and other instances
not interned.

----

@Interned is a much easier example to understand/appreciate than @NonNull
for this scenario.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298760</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-25 17:56:25 -0400</bug_when>
    <thetext>(In reply to comment #10)
&gt; @Interned is a much easier example to understand/appreciate than @NonNull
&gt; for this scenario.

Are you OK with disabling such usage of null annotations for now?
I&apos;m raising an error actually, if null annotations are enabled. OK?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298769</commentid>
    <comment_count>12</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-25 20:23:19 -0400</bug_when>
    <thetext>Progress pushed via commit 792caf681810140ce615d98d3abfdde62639719c:
- complain about nullness type annotations on an outer type (&quot;@Nullable X.Inner&quot;)
- code cleanup</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2298784</commentid>
    <comment_count>13</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-08-25 22:53:47 -0400</bug_when>
    <thetext>(In reply to comment #11)
&gt; (In reply to comment #10)
&gt; &gt; @Interned is a much easier example to understand/appreciate than @NonNull
&gt; &gt; for this scenario.
&gt; 
&gt; Are you OK with disabling such usage of null annotations for now?
&gt; I&apos;m raising an error actually, if null annotations are enabled. OK?

OK, let us have a follow up bug raised so it is on the radar. 

What should the semantics look like when this is implemented ? It would appear
given:

import org.eclipse.jdt.annotation.NonNull;

@NonNull
public class X {
	X x;
}

the field x should be treated some what akin to a loose hybrid of an uninitialized
local variable and a blank final field ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2299279</commentid>
    <comment_count>14</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-26 19:25:29 -0400</bug_when>
    <thetext>(In reply to comment #13)
&gt; (In reply to comment #11)
&gt; &gt; (In reply to comment #10)
&gt; &gt; &gt; @Interned is a much easier example to understand/appreciate than @NonNull
&gt; &gt; &gt; for this scenario.
&gt; &gt; 
&gt; &gt; Are you OK with disabling such usage of null annotations for now?
&gt; &gt; I&apos;m raising an error actually, if null annotations are enabled. OK?
&gt; 
&gt; OK, let us have a follow up bug raised so it is on the radar. 

It&apos;s now in bug 415918

&gt; What should the semantics look like when this is implemented ? It would
&gt; appear
&gt; given:
&gt; 
&gt; import org.eclipse.jdt.annotation.NonNull;
&gt; 
&gt; @NonNull
&gt; public class X {
&gt; 	X x;
&gt; }
&gt; 
&gt; the field x should be treated some what akin to a loose hybrid of an
&gt; uninitialized
&gt; local variable and a blank final field ?

I don&apos;t exactly get what you mean by hybrid, I understand the spec as saying that
the above implicitly denotes the same semantics as we get from:
  public class X {
       @NonNull X x;
  }
(plus @NonNull at all other uses of X, too).

From here we have our rules that every constructor or an initializer must initialize 
the field to non-null, so your example as-is would be rejected:
  &quot;The @NonNull field x may not have been initialized&quot;
(We don&apos;t discriminate potential / definite in this situation).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2299286</commentid>
    <comment_count>15</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2013-08-26 21:05:32 -0400</bug_when>
    <thetext>(In reply to comment #14)

&gt; I don&apos;t exactly get what you mean by hybrid, I understand the spec as saying
&gt; that
&gt; the above implicitly denotes the same semantics as we get from:
&gt;   public class X {
&gt;        @NonNull X x;
&gt;   }
&gt; (plus @NonNull at all other uses of X, too).
&gt; 
&gt; From here we have our rules that every constructor or an initializer must
&gt; initialize 
&gt; the field to non-null, so your example as-is would be rejected:
&gt;   &quot;The @NonNull field x may not have been initialized&quot;
&gt; (We don&apos;t discriminate potential / definite in this situation).

yes, that sounds right, thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2301520</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-31 14:54:18 -0400</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #3)
&gt; More useless constructs (from bug 392099 comment 15);
&gt; 
&gt;   - cast &quot;(@Nullable X&lt;T&gt;)x&quot; (cannot insert dynamic check)
&gt;   - (x instanceof @Nullable X&lt;T&gt;) (if it succeeds value cannot be null)

There&apos;s a difference between casts and instanceof:

 - annotations on instanceof are useless (cannot check)
   =&gt; will report an error:
   The nullness annotation &apos;NonNull&apos; is not applicable at this location

 - annotations on casts mean the cast will be unchecked
   =&gt; will report a warning (irritant is NullUncheckedConversion)
   Null type safety: Unchecked cast from X to @NonNull X</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2301527</commentid>
    <comment_count>17</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-08-31 17:40:17 -0400</bug_when>
    <thetext>(In reply to comment #3)
&gt;   - cast &quot;(@Nullable X&lt;T&gt;)x&quot; (cannot insert dynamic check)
&gt;   - (x instanceof @Nullable X&lt;T&gt;) (if it succeeds value cannot be null)
&gt;   - alloc: &quot;new @Nullable X&lt;T&gt;()&quot; - cannot be null :)

Next difference:

- for allocation expressions only the top-level null annotation is bogus

- for cast &amp; instanceof null annotations on any type details need to be analysed.

Question: should I put more fine tuning into top level annotations of instanceof?
I could say: @NonNull is redundant, @Nullable always wrong.
My current feeling: saying &quot;is not applicable at this location&quot; is sufficient.

BTW: for cast I&apos;m complaining only against those annotations that are present
on the cast type but missing on the expression, so this is OK:

  ArrayList&lt;@NonNull String&gt; foo(List&lt;@NonNull String&gt; l) {
      return (ArrayList&lt;@NonNull String&gt;) l;
  }


Implementation regarding cast, instanceof and allocation has been released
via commit c67d112c20f07c2dcda11714ef23687a9781a753</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2309600</commentid>
    <comment_count>18</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2013-09-22 13:51:16 -0400</bug_when>
    <thetext>One issue to consider: type variables and wildcards can have multiple bounds. What exact rules do we enforce to ensure consistency?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367330</commentid>
    <comment_count>19</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-23 15:26:33 -0500</bug_when>
    <thetext>Starting from the list in comment 7 I have implemented all remaining checks.

Tests &amp; fix released via http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?h=BETA_JAVA8&amp;id=cefc7f3f8677282aa49e610700500999ffcaffcb</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2372808</commentid>
    <comment_count>20</comment_count>
    <who name="Noopur Gupta">noopur_gupta</who>
    <bug_when>2014-03-07 01:42:17 -0500</bug_when>
    <thetext>Verified as working for Eclipse + Java 8 RC2 using Kepler SR2 +   
Eclipse Java Development Tools Patch for Java 8 Support (BETA)
1.0.0.v20140306-1935</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>