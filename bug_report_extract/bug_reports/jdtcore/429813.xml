<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>429813</bug_id>
          
          <creation_ts>2014-03-06 14:22:00 -0500</creation_ts>
          <short_desc>[1.8][dom ast] IMethodBinding#getJavaElement() should return IMethod for lambda</short_desc>
          <delta_ts>2015-04-29 00:53:42 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>https://git.eclipse.org/r/46030</see_also>
    
    <see_also>https://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=488811f5b30befaaae3f5995fcfa0b0505629e6e</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>4.5 M7</target_milestone>
          
          <blocked>403917</blocked>
          <everconfirmed>1</everconfirmed>
          <reporter name="Markus Keller">markus_keller</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>daniel_megert</cc>
    
    <cc>jarthana</cc>
    
    <cc>manpalat</cc>
    
    <cc>noopur_gupta</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      <flag name="pmc_approved"
          id="64472"
          type_id="2"
          status="+"
          setter="daniel_megert"
    />

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2372625</commentid>
    <comment_count>0</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2014-03-06 14:22:08 -0500</bug_when>
    <thetext>IMethodBinding#getJavaElement() should return the IMethod for a lambda method binding.

Just for consistency; I currently don&apos;t have an urgent use case.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2429780</commentid>
    <comment_count>1</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2014-07-21 09:40:48 -0400</bug_when>
    <thetext>Snippet shaped after bug 440000:

import java.util.function.*;
public class Snippet {
    Function&lt;Integer, int[]&gt; m1L = n -&gt; new int[n];
}

LambdaExpression#resolveMethodBinding() currently returns a synthetic method

    private static int[] lambda$0(Integer)

whose getDeclaringClass() is Snippet. I think this lambda$n method is an implementation detail that should not be surfaced in the DOM API. I would expect a method binding that actually overrides the functional interface method

    public abstract int[] apply(Integer)

from type Function&lt;Integer, int[]&gt;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2430013</commentid>
    <comment_count>2</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-07-22 01:18:57 -0400</bug_when>
    <thetext>I&apos;ll take a look at this one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2437534</commentid>
    <comment_count>3</comment_count>
    <who name="Noopur Gupta">noopur_gupta</who>
    <bug_when>2014-08-11 08:08:14 -0400</bug_when>
    <thetext>Another property that differs in the synthetic method binding is varargs:

@FunctionalInterface
interface FTest {
	Object foo (int[]... ints);
}

class TestX {
	FTest fi= ints -&gt; null;
}

Here, the synthetic method binding is: lambda$0(int[][]) and returns false for IMethodBinding.isVarargs().</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2438282</commentid>
    <comment_count>4</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-08-13 00:58:16 -0400</bug_when>
    <thetext>Refer to bug 432614 comment #9 also.

If we decide to alter the current behavior, we should also take a close look at the Java model side (not saying we should change yet).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2438312</commentid>
    <comment_count>5</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2014-08-13 03:01:38 -0400</bug_when>
    <thetext>(In reply to Jayaprakash Arthanareeswaran from comment #4)
&gt; Refer to bug 432614 comment #9 also.
&gt; 
&gt; If we decide to alter the current behavior, we should also take a close look
&gt; at the Java model side (not saying we should change yet).

Should also mention that the lambda expression on Java model side doesn&apos;t expose/carry parameter annotations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2526139</commentid>
    <comment_count>6</comment_count>
      <attachid>251253</attachid>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-03-03 09:41:19 -0500</bug_when>
    <thetext>Created attachment 251253
Draft patch

Here&apos;s a patch that mixes and matches from lambda&apos;s implementation and SAM. At the moment, the only things that come from the implementation are the key, modifiers and annotations. As a result, there are five failing test that need to be looked at:

----------- Expected ------------
private static java.lang.Object foo(int[])
------------ but was ------------
public abstract java.lang.Object foo(int[])</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2533458</commentid>
    <comment_count>7</comment_count>
    <who name="Manoj Palat Away Until May 11 2015">manpalat</who>
    <bug_when>2015-03-18 05:39:17 -0400</bug_when>
    <thetext>moving to M7</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2548294</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-19 08:45:10 -0400</bug_when>
    <thetext>I came across this bug during work on bug 403917; this current bug made it impossible to compute a comprehensive label for a lambda based on DOM bindings.

I found that Jay&apos;s draft patch goes a long way towards what I need, and extended it like so:

* MethodBinding.LambdaMethod is basically taken from the patch, but for navigation purposes I override getMethodDeclaration() so that it returns the (possibly parameterized) SAM (aka descriptor). The next invocation of getMethodDeclaration() answers the SAM&apos;s original.

This change is reflected in an added bullet in the javadoc of IMethodBinding.getMethodDeclaration():
      &quot; * For lambda methods, returns the (possibly parameterized) 
       single abstract method of the functional type.&quot;

* I extended VariableBinding.getDeclaringMethod() to answer a lambda method if suitable, i.e., if the variable is a lambda parameter or a local variable inside a lambda body.

* Also DOMFinder needs another update to find lambda methods from both representations: LambdaExpression and LambdaMethod (model).


* Next I observed that bindings for lambdas as well as anonymous classes lack a facility to find out the declaring member (method, field, initializer). Since declaringClass and declaringMethod are genuine part of bindings I figured that also the declaring member of any anonymous implementation should be represented in DOM bindings as well.

For this purpose I created a new interface 

package org.eclipse.jdt.core.dom;
public interface IAnonymousImplementation {
    public IBinding getDeclaringMember();
}

I have two implementors of this interface:
 - MethodBinding.LambdaMethod from Jay&apos;s patch
 - TypeBinding.AnonymousTypeBinding new in my patch
All is hooked into DefaultBindingResolver to instantiate the appropriate classes for lambdas and anonymous classes.

Unfortunately this means in order to make progress we need new API past API freeze.


* By way of the previous change I found that anonymous things declared inside an initializer did not find any binding representation for the initializer. I fixed this by a small addition in Initializer (compiler AST) whose only client is DefaultBindingResolver. I&apos;m creating a MethodBinding (compiler) which is never seen in the compiler but backs additional MethodBindings (DOM) with selectors &quot;&lt;init&gt;&quot; and &quot;&lt;clinit&gt;&quot; respectively.

With these additions the full structure of lambdas and anonymous classes can be inspected just using DOM bindings with linkage both from implementation to declaration and also containment within declaring things.


* Finally I adjusted the test expectations in ASTConverter18Test, arguing that
 - the SAM name is better than lambda$&lt;n&gt; (subject of this bug)
 - all lambdas must be seen as public non-abstract non-static</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2548295</commentid>
    <comment_count>9</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-04-19 08:47:02 -0400</bug_when>
    <thetext>New Gerrit change created: https://git.eclipse.org/r/46030</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2548297</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-19 09:05:37 -0400</bug_when>
    <thetext>Let me mention a strategy which I chose *not* to pursue:

In the Java model, lambdas are represented in two &apos;views&apos;: as an IMethod using LambdaMethod and as an IType using LambdaExpression. During my work I saw no necessity for such split identity in the binding world. S.o. interested in the type of a lambda can simply use LambdaMethod.getDeclaringClass() which answers the (parameterized) functional type. Hence, my patch gives only one binding for each lambda. SAM and functional type (both in parameterized and original versions) are already supported concepts in DOM bindings. This should be sufficient, IMHO.
As a result requesting the binding for a LambdaMethod and the corresponding LambdaExpression will answer the same MethodBinding.LambdaMethod.

I&apos;m not too familiar with this particular design aspect of the Java model. Am I missing essential reasons for split identity, should the same be replicated in DOM bindings, too?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2548303</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-19 09:58:02 -0400</bug_when>
    <thetext>I&apos;m requesting an exception for adding new API in JDT/Core as contained in the linked gerrit change.

The proposed API can be seen at https://git.eclipse.org/r/#/c/46030/1/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IAnonymousImplementation.java
Also a Javadoc addition is proposed in https://git.eclipse.org/r/#/c/46030/1/org.eclipse.jdt.core/dom/org/eclipse/jdt/core/dom/IMethodBinding.java


Motivation for action:

Clients of DOM bindings expect that they can use the binding API to find out where in a Java class / interface a given element is declared (methods getDeclaringMethod() / getDeclaringClass()).
This approach is incomplete for anonymous classes and lambda expressions, which can also be declared in the initialization of a field or a (static or non-static) block of a class (initializer).
I will argue in bug 403917 why I think this is important to be fixed for 4.5.


Justification for the chosen approach:

I believe the proposed API is minimal and still universal. I refrained from adding a method IMethodBinding#isLambda() (which would be trivial to add, if requested), but checking &quot;m instanceof IAnonymousImplementation&quot; is sufficient for this task.

I.e., one purpose of the new interface is to *mark* method bindings that represent a lambda expression. While previously this information _could_ be computed by checking a selector for the &quot;lambda$&quot; prefix, this information is lost when hiding this synthetic name.

Secondly, the proposed interface identifies a common property of otherwise disjoint binding types. The insufficiency of getDeclaringMethod() / getDeclaringClass() is common to lambda expressions and anonymous classes.

For the new method getDeclaringMember() answering a regular MethodBinding or FieldBinding is straight forward.

For anonymous things declared inside an initializer I chose the approach with minimal impact:
No new binding kind, but use IMethodBindings with special selectors. These method bindings are only loosely connected: they only ever appear as the declaring member of an IAnonymousImplementation, but are not part of the answer from ITypeBinding#getDeclaredMethods().
I chose this approach in order to avoid havoc for existing clients which simply do not expect initializers to be answered from getDeclaredMethods(). If this is felt as an undue asymmetry we could add ITypeBinding#getDeclaredInitializers(), but currently I don&apos;t see a need for this.
Thus, only clients of the new API #getDeclaringMember() will ever see an IMethodBinding representing an initializer. They can identify the initializer by inspecting the selector. Otherwise the IMethodBinding can be used like normal.

Summarizing, by adding one interface with a single method plus some semantic clarifications in Javadoc, we are able to fully connect bindings for lambdas and anonymous classes to their context.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2548506</commentid>
    <comment_count>12</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-04-20 04:25:04 -0400</bug_when>
    <thetext>I am fine with the API addition. As the process demands, I am putting the new API here:

  /**
   * Abstraction over anonymous types and lambdas.
   *
   * @since 3.11
   */
  public interface IAnonymousImplementation {

     /**
      * If the anonymous implementation is declared in the body of a method,
      * answer the binding of that declaring method. Otherwise, if the
      * anonymous implementation is declared in the initializer of a field,
      * answer the binding of that declaring field.
      * &lt;p&gt;
      * If the anonymous implementation is declared in an initializer,
      * answer a binding for that initializer (selector is &quot;&amp;lt;clinit&amp;gt;&quot;
      * or &quot;&amp;lt;init&amp;gt;&quot; in this case).
      * &lt;/p&gt;
      * @return the binding of a method or field containing the declaration
      *   of this anonymous implementation.
      */
     public IBinding getDeclaringMember();
  }

Markus, please take a look.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549622</commentid>
    <comment_count>13</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2015-04-21 15:12:40 -0400</bug_when>
    <thetext>I support the addition of a new API

    public IBinding getDeclaringMember();

However, it should follow the style of the existing IBinding APIs, which don&apos;t use mixin interfaces, but just add the method to the base interface and specify to return null if not applicable. In this case, that would mean new methods on IMethodBinding and ITypeBinding.

For completeness, getDeclaringMember() should also work for local types:

public class LambdaTests {
    {
        class Local implements Function&lt;Integer, String&gt; {
            @Override
            public String apply(Integer t) {
                return t.toString();
            }
        }
        
        Function&lt;Integer, String&gt; toStringL = new Local();
        System.out.println(toStringL.apply(123));
    }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549633</commentid>
    <comment_count>14</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-21 15:41:40 -0400</bug_when>
    <thetext>(In reply to Markus Keller from comment #13)
&gt; I support the addition of a new API
&gt; 
&gt;     public IBinding getDeclaringMember();

Thanks!

&gt; However, it should follow the style of the existing IBinding APIs, which
&gt; don&apos;t use mixin interfaces, but just add the method to the base interface
&gt; and specify to return null if not applicable. In this case, that would mean
&gt; new methods on IMethodBinding and ITypeBinding.

I assume this implies that clients wanting to find out if an IMethodBinding represents a lambda have to say

  method.getDeclaringMember() != null

instead of (with my proposal):

  method instanceof IAnonymousImplementation

Since this is a matter of style, not functionality, I&apos;m fine with the requested change.

&gt; For completeness, getDeclaringMember() should also work for local types:

Makes perfect sense, the case of local type inside an initializer was indeed unhandled in my proposal.

I&apos;ll prepare an updated patch shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549707</commentid>
    <comment_count>15</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-21 21:13:48 -0400</bug_when>
    <thetext>Updated API (see also https://git.eclipse.org/r/#/c/46030/3):

IMethodBinding:
/**
 * If this method binding represents a lambda expression then:
 * &lt;ul&gt;
 * &lt;li&gt;If the lambda expression is declared in the body of a method,
 *   answers the binding of that declaring method.
 * &lt;/li&gt;
 * &lt;li&gt;Otherwise, if the lambda expression is declared in the 
 *   initializer of a field, answers the binding of that declaring field.
 * &lt;/li&gt;
 * &lt;li&gt;Otherwise, if the lambda expression is declared in a static initializer or an
 *   instance initializer, a method binding is returned to represent that initializer
 *   (selector is &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; in this case).
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * If this method binding does not represent a lambda expression,
 * &lt;code&gt;null&lt;/code&gt; is returned.
 * &lt;/p&gt;
 * @return a method binding or field binding representing the member that
 * contains the lambda expression represented by this method binding,
 * or null for regular method bindings.
 * @since 3.11
 */
public IBinding getDeclaringMember();


ITypeBinding:
/**
 * If this type binding represents a local type, possibly an anonymous class, then:
 * &lt;ul&gt;
 * &lt;li&gt;If the local type is declared in the body of a method,
 *   answers the binding of that declaring method.
 * &lt;/li&gt;
 * &lt;li&gt;Otherwise, if the local type (an anonymous class in this case) is declared
 *   in the initializer of a field, answers the binding of that declaring field.
 * &lt;/li&gt;
 * &lt;li&gt;Otherwise, if the local type is declared in a static initializer or
 *   an instance initializer, a method binding is returned to represent that initializer
 *   (selector is &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; in this case).
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * If this type binding does not represent a local type, &lt;code&gt;null&lt;/code&gt; is returned.
 * &lt;/p&gt;
 * @return a method binding or field binding representing the member that
 * contains the local type represented by this type binding,
 * or null for non-local type bindings.
 * @since 3.11
 */
public IBinding getDeclaringMember();

All this is heavily exercised via tests for bug 403917 (updated patch in that bug to follow tomorrow). I plan to add additional test directly in JDT/Core post M7.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549808</commentid>
    <comment_count>16</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-04-22 03:00:01 -0400</bug_when>
    <thetext>Thanks Stephan, for taking over this one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549824</commentid>
    <comment_count>17</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-22 03:14:34 -0400</bug_when>
    <thetext>While working on the example in comment 13, I realized that the name &lt;init&gt; for bindings for instance initializers is not perfect, as we could not distinguish such bindings from constructor bindings.

This should be avoided by using an empty string instead, see https://git.eclipse.org/r/#/c/46030/4

As for the API this means to change this line

 *   (selector is &lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;init&amp;gt;&lt;/code&gt; in this case).

to:

 *   (selector is an empty string in this case).

(two occurrences).

&lt;clinit&gt; would have been OK, but is also changed for consistency. Distinction between static intializers and instance intializers is still possible by checking for AccStatic.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2549830</commentid>
    <comment_count>18</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-04-22 03:19:43 -0400</bug_when>
    <thetext>Dani, we need PMC approval for this one. Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2551898</commentid>
    <comment_count>19</comment_count>
    <who name="Markus Keller">markus_keller</who>
    <bug_when>2015-04-26 19:53:27 -0400</bug_when>
    <thetext>I just gave my +1 on bug 403917 and I recommend the PMC to grant the API request from comment 15.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2552351</commentid>
    <comment_count>20</comment_count>
    <who name="Eclipse Genie">genie</who>
    <bug_when>2015-04-27 10:40:17 -0400</bug_when>
    <thetext>Gerrit change https://git.eclipse.org/r/46030 was merged to [master].
Commit: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=488811f5b30befaaae3f5995fcfa0b0505629e6e</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2552354</commentid>
    <comment_count>21</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-04-27 10:41:03 -0400</bug_when>
    <thetext>Thanks, released for 4.5 M7</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2553479</commentid>
    <comment_count>22</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-04-29 00:53:42 -0400</bug_when>
    <thetext>Verified for 4.5 M7 with build I20150428-2000</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="1"
              isprivate="0"
          >
            <attachid>251253</attachid>
            <date>2015-03-03 09:41:00 -0500</date>
            <delta_ts>2015-03-03 09:41:19 -0500</delta_ts>
            <desc>Draft patch</desc>
            <filename>Bug-429813.patch</filename>
            <type>text/plain</type>
            <size>9161</size>
            <attacher name="Jay Arthanareeswaran">jarthana</attacher>
            
              <data encoding="base64">ZGlmZiAtLWdpdCBhL29yZy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLm1vZGVsL3NyYy9vcmcvZWNs
aXBzZS9qZHQvY29yZS90ZXN0cy9kb20vQVNUQ29udmVydGVyMThUZXN0LmphdmEgYi9vcmcuZWNs
aXBzZS5qZHQuY29yZS50ZXN0cy5tb2RlbC9zcmMvb3JnL2VjbGlwc2UvamR0L2NvcmUvdGVzdHMv
ZG9tL0FTVENvbnZlcnRlcjE4VGVzdC5qYXZhCmluZGV4IDY1ODY5ODIuLjlhZjYzYzMgMTAwNjQ0
Ci0tLSBhL29yZy5lY2xpcHNlLmpkdC5jb3JlLnRlc3RzLm1vZGVsL3NyYy9vcmcvZWNsaXBzZS9q
ZHQvY29yZS90ZXN0cy9kb20vQVNUQ29udmVydGVyMThUZXN0LmphdmEKKysrIGIvb3JnLmVjbGlw
c2UuamR0LmNvcmUudGVzdHMubW9kZWwvc3JjL29yZy9lY2xpcHNlL2pkdC9jb3JlL3Rlc3RzL2Rv
bS9BU1RDb252ZXJ0ZXIxOFRlc3QuamF2YQpAQCAtNDYsNSArNDYsNSBAQAogLy8JCVRFU1RTX05V
TUJFUlMgPSBuZXcgaW50W10geyAxOSB9OwogLy8JCVRFU1RTX1JBTkdFID0gbmV3IGludFtdIHsg
MSwgLTEgfTsKLS8vCQlURVNUU19OQU1FUyA9IG5ldyBTdHJpbmdbXSB7InRlc3QwMDAxIn07Cisv
LwkJVEVTVFNfTkFNRVMgPSBuZXcgU3RyaW5nW10geyJ0ZXN0NDI5ODEzIn07CiAJfQogCXB1Ymxp
YyBzdGF0aWMgVGVzdCBzdWl0ZSgpIHsKQEAgLTE1NzksNSArMTU3OSw1IEBACiAJCWFzc2VydFRy
dWUobGFtYmRhRXhwcmVzc2lvbi5wYXJhbWV0ZXJzKCkuc2l6ZSgpID09IDEpOwogCQlJTWV0aG9k
QmluZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5yZXNvbHZlTWV0aG9kQmluZGluZygp
OwotCQlhc3NlcnRFcXVhbHMoInByaXZhdGUgc3RhdGljIGludCBsYW1iZGEkMChpbnQpICIsIGJp
bmRpbmcudG9TdHJpbmcoKSk7CisJCWFzc2VydEVxdWFscygicHJpdmF0ZSBzdGF0aWMgaW50IGZv
byhpbnQpICIsIGJpbmRpbmcudG9TdHJpbmcoKSk7CiAJCVZhcmlhYmxlRGVjbGFyYXRpb24gdmFy
aWFibGVEZWNsYXJhdGlvbiA9IChWYXJpYWJsZURlY2xhcmF0aW9uKSBsYW1iZGFFeHByZXNzaW9u
LnBhcmFtZXRlcnMoKS5nZXQoMCk7CiAJCWFzc2VydFRydWUodmFyaWFibGVEZWNsYXJhdGlvbiBp
bnN0YW5jZW9mIFZhcmlhYmxlRGVjbGFyYXRpb25GcmFnbWVudCk7CkBAIC0xNjE0LDUgKzE2MTQs
NSBAQAogCQlhc3NlcnRFcXVhbHMoInZsYW1iZGEgLT4gMjAwIiwgbGFtYmRhRXhwcmVzc2lvbi50
b1N0cmluZygpKTsKIAkJSU1ldGhvZEJpbmRpbmcgYmluZGluZyA9IGxhbWJkYUV4cHJlc3Npb24u
cmVzb2x2ZU1ldGhvZEJpbmRpbmcoKTsKLQkJYXNzZXJ0RXF1YWxzKCJwcml2YXRlIHN0YXRpYyBp
bnQgbGFtYmRhJDAoaW50KSAiLCBiaW5kaW5nLnRvU3RyaW5nKCkpOworCQlhc3NlcnRFcXVhbHMo
InByaXZhdGUgc3RhdGljIGludCBmb28oaW50KSAiLCBiaW5kaW5nLnRvU3RyaW5nKCkpOwogCQlh
c3NlcnRUcnVlKGxhbWJkYUV4cHJlc3Npb24ucGFyYW1ldGVycygpLnNpemUoKSA9PSAxKTsKIAkJ
VmFyaWFibGVEZWNsYXJhdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uID0gKFZhcmlhYmxlRGVjbGFy
YXRpb24pIGxhbWJkYUV4cHJlc3Npb24ucGFyYW1ldGVycygpLmdldCgwKTsKQEAgLTE2NDgsNSAr
MTY0OCw1IEBACiAJCWFzc2VydEVxdWFscygiKGludFtdIGlhKSAtPiB7XG4gIHJldHVybiBpYS5j
bG9uZSgpO1xufVxuIiwgbGFtYmRhRXhwcmVzc2lvbi50b1N0cmluZygpKTsKIAkJSU1ldGhvZEJp
bmRpbmcgYmluZGluZyA9IGxhbWJkYUV4cHJlc3Npb24ucmVzb2x2ZU1ldGhvZEJpbmRpbmcoKTsK
LQkJYXNzZXJ0RXF1YWxzKCJwcml2YXRlIHN0YXRpYyBqYXZhLmxhbmcuT2JqZWN0IGxhbWJkYSQw
KGludFtdKSAiLCBiaW5kaW5nLnRvU3RyaW5nKCkpOworCQlhc3NlcnRFcXVhbHMoInByaXZhdGUg
c3RhdGljIGphdmEubGFuZy5PYmplY3QgZm9vKGludFtdKSAiLCBiaW5kaW5nLnRvU3RyaW5nKCkp
OwogCQlhc3NlcnRUcnVlKGxhbWJkYUV4cHJlc3Npb24ucGFyYW1ldGVycygpLnNpemUoKSA9PSAx
KTsKIAkJVmFyaWFibGVEZWNsYXJhdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uID0gKFZhcmlhYmxl
RGVjbGFyYXRpb24pIGxhbWJkYUV4cHJlc3Npb24ucGFyYW1ldGVycygpLmdldCgwKTsKQEAgLTE2
OTAsNSArMTY5MCw1IEBACiAJCWFzc2VydEVxdWFscygiKCkgLT4ge1xuICBTeXN0ZW0ub3V0LnBy
aW50bG4odGhpcyk7XG4gIEkgaj0oKSAtPiB7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKHRoaXMp
O1xuICAgIEkgaz0oKSAtPiB7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4odGhpcyk7XG4gICAg
fVxuO1xuICB9XG47XG59XG4iLCBsYW1iZGFFeHByZXNzaW9uLnRvU3RyaW5nKCkpOwogCQlJTWV0
aG9kQmluZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5yZXNvbHZlTWV0aG9kQmluZGlu
ZygpOwotCQlhc3NlcnRFcXVhbHMoInByaXZhdGUgdm9pZCBsYW1iZGEkMCgpICIsIGJpbmRpbmcu
dG9TdHJpbmcoKSk7CisJCWFzc2VydEVxdWFscygicHJpdmF0ZSB2b2lkIGZvbygpICIsIGJpbmRp
bmcudG9TdHJpbmcoKSk7CiAJCWFzc2VydFRydWUobGFtYmRhRXhwcmVzc2lvbi5wYXJhbWV0ZXJz
KCkuc2l6ZSgpID09IDApOwogCX0KQEAgLTE5NDMsNSArMTk0Myw1IEBACiAJCWFzc2VydEVxdWFs
cygiKCkgLT4gKCkgLT4gMTAiLCBsYW1iZGFFeHByZXNzaW9uLnRvU3RyaW5nKCkpOwogCQlJTWV0
aG9kQmluZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5yZXNvbHZlTWV0aG9kQmluZGlu
ZygpOwotCQlhc3NlcnRFcXVhbHMoInByaXZhdGUgc3RhdGljIHRlc3QzOTk3OTMuSiBsYW1iZGEk
MCgpICIsIGJpbmRpbmcudG9TdHJpbmcoKSk7CisJCWFzc2VydEVxdWFscygicHJpdmF0ZSBzdGF0
aWMgdGVzdDM5OTc5My5KIGZvbygpICIsIGJpbmRpbmcudG9TdHJpbmcoKSk7CiAJCWFzc2VydFRy
dWUobGFtYmRhRXhwcmVzc2lvbi5wYXJhbWV0ZXJzKCkuc2l6ZSgpID09IDApOwogCX0JCkBAIC0y
ODM1LDUgKzI4MzUsNSBAQAogCQlJVHlwZUJpbmRpbmdbXSBwYXJhbWV0ZXJUeXBlcz0gbGFtYmRh
LnJlc29sdmVNZXRob2RCaW5kaW5nKCkuZ2V0UGFyYW1ldGVyVHlwZXMoKTsKIAkJYXNzZXJ0VHJ1
ZSgiSW5jb3JyZWN0IE51bWJlciBvZiBwYXJhbWV0ZXIgdHlwZSIsIHBhcmFtZXRlclR5cGVzLmxl
bmd0aCA9PSAxKTsKLQkJYXNzZXJ0RXF1YWxzKCJJbmNvcnJlY3QgcGFyYW1ldGVyIHR5cGUiLCAi
ZmxvYXQiLCBwYXJhbWV0ZXJUeXBlc1swXS50b1N0cmluZygpKTsKKwkJYXNzZXJ0RXF1YWxzKCJJ
bmNvcnJlY3QgcGFyYW1ldGVyIHR5cGUiLCAiaW50IiwgcGFyYW1ldGVyVHlwZXNbMF0udG9TdHJp
bmcoKSk7CiAJfQogCS8qKgpAQCAtNDc1MywzICs0NzUzLDUyIEBACiAJfQogfQorLyoqCisgKiBo
dHRwczovL2J1Z3MuZWNsaXBzZS5vcmcvYnVncy9zaG93X2J1Zy5jZ2k/aWQ9NDI5ODEzCisgKiAK
KyAqIEB0aHJvd3MgSmF2YU1vZGVsRXhjZXB0aW9uCisgKi8KK3B1YmxpYyB2b2lkIHRlc3Q0Mjk4
MTMoKSB0aHJvd3MgSmF2YU1vZGVsRXhjZXB0aW9uIHsKKwl0aGlzLndvcmtpbmdDb3B5ID0gZ2V0
V29ya2luZ0NvcHkoIi9Db252ZXJ0ZXIxOC9zcmMvdGVzdDQyOTgxMy9TbmlwcGV0LmphdmEiLAor
CQkJdHJ1ZS8qIHJlc29sdmUgKi8pOworCVN0cmluZyBjb250ZW50cyA9ICJwYWNrYWdlIHRlc3Q0
Mjk4MTM7IgorCQkJKyAicHVibGljIGNsYXNzIFNuaXBwZXQge1xuIgorCQkJKyAiCQlGdW5jdGlv
bjxJbnRlZ2VyLCBpbnRbXT4gbTFMID0gbiAtPiBuZXcgaW50W25dO1xuIgorCQkJKyAifSIKKwkJ
CSsgImludGVyZmFjZSBGdW5jdGlvbjxULCBSPiB7XG4iCisJCQkrICIgICBwdWJsaWMgUiBhcHBs
eShUIHQpO1xuIgorCQkJKyAifVxuIjsKKwlDb21waWxhdGlvblVuaXQgY3UgPSAoQ29tcGlsYXRp
b25Vbml0KSBidWlsZEFTVChjb250ZW50cywgdGhpcy53b3JraW5nQ29weSk7CisJVHlwZURlY2xh
cmF0aW9uIHR5cGVkZWNsYXJhdGlvbiA9IChUeXBlRGVjbGFyYXRpb24pIGdldEFTVE5vZGUoY3Us
IDApOworCUZpZWxkRGVjbGFyYXRpb24gZmllbGREZWNsYXJhdGlvbiA9IChGaWVsZERlY2xhcmF0
aW9uKSB0eXBlZGVjbGFyYXRpb24uYm9keURlY2xhcmF0aW9ucygpLmdldCgwKTsKKwlWYXJpYWJs
ZURlY2xhcmF0aW9uRnJhZ21lbnQgZnJhZ21lbnQgPSAoVmFyaWFibGVEZWNsYXJhdGlvbkZyYWdt
ZW50KWZpZWxkRGVjbGFyYXRpb24uZnJhZ21lbnRzKCkuZ2V0KDApOworCUV4cHJlc3Npb24gZXhw
cmVzc2lvbiA9IGZyYWdtZW50LmdldEluaXRpYWxpemVyKCk7CisJYXNzZXJ0VHJ1ZShleHByZXNz
aW9uIGluc3RhbmNlb2YgTGFtYmRhRXhwcmVzc2lvbik7CisJTGFtYmRhRXhwcmVzc2lvbiBsYW1i
ZGFFeHByZXNzaW9uID0gKExhbWJkYUV4cHJlc3Npb24pZXhwcmVzc2lvbjsKKwlJTWV0aG9kQmlu
ZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5yZXNvbHZlTWV0aG9kQmluZGluZygpOwor
CUlKYXZhRWxlbWVudCBlbGVtZW50ID0gYmluZGluZy5nZXRKYXZhRWxlbWVudCgpOworCWFzc2Vy
dEVxdWFscygiTm90IGEgbWV0aG9kIiwgSUphdmFFbGVtZW50Lk1FVEhPRCwgZWxlbWVudC5nZXRF
bGVtZW50VHlwZSgpKTsKKwlhc3NlcnRGYWxzZSgiU2hvdWxkIG5vdCBiZSBhIHN5bnRoZXRpYyIs
IGJpbmRpbmcuaXNTeW50aGV0aWMoKSk7Cit9CisKK3B1YmxpYyB2b2lkIHRlc3Q0Mjk4MTNhKCkg
dGhyb3dzIEphdmFNb2RlbEV4Y2VwdGlvbiB7CisJdGhpcy53b3JraW5nQ29weSA9IGdldFdvcmtp
bmdDb3B5KCIvQ29udmVydGVyMTgvc3JjL3Rlc3Q0Mjk4MTMvU25pcHBldC5qYXZhIiwKKwkJCXRy
dWUvKiByZXNvbHZlICovKTsKKwlTdHJpbmcgY29udGVudHMgPSAicGFja2FnZSB0ZXN0NDI5ODEz
OyIKKwkJCSsgImludGVyZmFjZSBGVGVzdCB7XG4iCisJCQkrICIJCU9iamVjdCBmb28gKGludFtd
Li4uIGludHMpO1xuIgorCQkJKyAifTsiCisJCQkrICJjbGFzcyBUZXN0WCB7IgorCQkJKyAiCQlG
VGVzdCBmaT0gaW50cyAtPiBudWxsO1xuIgorCQkJKyAifVxuIjsKKwlDb21waWxhdGlvblVuaXQg
Y3UgPSAoQ29tcGlsYXRpb25Vbml0KSBidWlsZEFTVChjb250ZW50cywgdGhpcy53b3JraW5nQ29w
eSk7CisJVHlwZURlY2xhcmF0aW9uIHR5cGVkZWNsYXJhdGlvbiA9IChUeXBlRGVjbGFyYXRpb24p
IGdldEFTVE5vZGUoY3UsIDEpOworCUZpZWxkRGVjbGFyYXRpb24gZmllbGREZWNsYXJhdGlvbiA9
IChGaWVsZERlY2xhcmF0aW9uKSB0eXBlZGVjbGFyYXRpb24uYm9keURlY2xhcmF0aW9ucygpLmdl
dCgwKTsKKwlWYXJpYWJsZURlY2xhcmF0aW9uRnJhZ21lbnQgZnJhZ21lbnQgPSAoVmFyaWFibGVE
ZWNsYXJhdGlvbkZyYWdtZW50KWZpZWxkRGVjbGFyYXRpb24uZnJhZ21lbnRzKCkuZ2V0KDApOwor
CUV4cHJlc3Npb24gZXhwcmVzc2lvbiA9IGZyYWdtZW50LmdldEluaXRpYWxpemVyKCk7CisJYXNz
ZXJ0VHJ1ZShleHByZXNzaW9uIGluc3RhbmNlb2YgTGFtYmRhRXhwcmVzc2lvbik7CisJTGFtYmRh
RXhwcmVzc2lvbiBsYW1iZGFFeHByZXNzaW9uID0gKExhbWJkYUV4cHJlc3Npb24pZXhwcmVzc2lv
bjsKKwlJTWV0aG9kQmluZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5yZXNvbHZlTWV0
aG9kQmluZGluZygpOworCWFzc2VydFRydWUoIlNob3VsZCBiZSBhIHZhcmFyZ3MiLCBiaW5kaW5n
LmlzVmFyYXJncygpKTsKK30KKwogfQpkaWZmIC0tZ2l0IGEvb3JnLmVjbGlwc2UuamR0LmNvcmUv
ZG9tL29yZy9lY2xpcHNlL2pkdC9jb3JlL2RvbS9EZWZhdWx0QmluZGluZ1Jlc29sdmVyLmphdmEg
Yi9vcmcuZWNsaXBzZS5qZHQuY29yZS9kb20vb3JnL2VjbGlwc2UvamR0L2NvcmUvZG9tL0RlZmF1
bHRCaW5kaW5nUmVzb2x2ZXIuamF2YQppbmRleCA4ZGJjMDJiLi4yNTJmMmYyIDEwMDY0NAotLS0g
YS9vcmcuZWNsaXBzZS5qZHQuY29yZS9kb20vb3JnL2VjbGlwc2UvamR0L2NvcmUvZG9tL0RlZmF1
bHRCaW5kaW5nUmVzb2x2ZXIuamF2YQorKysgYi9vcmcuZWNsaXBzZS5qZHQuY29yZS9kb20vb3Jn
L2VjbGlwc2UvamR0L2NvcmUvZG9tL0RlZmF1bHRCaW5kaW5nUmVzb2x2ZXIuamF2YQpAQCAtMSw0
ICsxLDQgQEAKIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCi0gKiBDb3B5cmlnaHQgKGMpIDIwMDAs
IDIwMTQgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMuCisgKiBDb3B5cmlnaHQgKGMpIDIwMDAs
IDIwMTUgSUJNIENvcnBvcmF0aW9uIGFuZCBvdGhlcnMuCiAgKiBBbGwgcmlnaHRzIHJlc2VydmVk
LiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzCiAgKiBhcmUgbWFk
ZSBhdmFpbGFibGUgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBFY2xpcHNlIFB1YmxpYyBMaWNlbnNl
IHYxLjAKQEAgLTg4Myw1ICs4ODMsMjIgQEAKIAkJaWYgKG9sZE5vZGUgaW5zdGFuY2VvZiBvcmcu
ZWNsaXBzZS5qZHQuaW50ZXJuYWwuY29tcGlsZXIuYXN0LkxhbWJkYUV4cHJlc3Npb24pIHsKIAkJ
CW9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5hc3QuTGFtYmRhRXhwcmVzc2lvbiBs
YW1iZGFFeHByZXNzaW9uID0gKG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5hc3Qu
TGFtYmRhRXhwcmVzc2lvbikgb2xkTm9kZTsKLQkJCUlNZXRob2RCaW5kaW5nIG1ldGhvZEJpbmRp
bmcgPSBnZXRNZXRob2RCaW5kaW5nKGxhbWJkYUV4cHJlc3Npb24uZ2V0TWV0aG9kQmluZGluZygp
KTsKKwkJCW9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5sb29rdXAuTWV0aG9kQmlu
ZGluZyBiaW5kaW5nID0gbGFtYmRhRXhwcmVzc2lvbi5nZXRNZXRob2RCaW5kaW5nKCk7CisJCQlJ
TWV0aG9kQmluZGluZyBtZXRob2RCaW5kaW5nID0gbnVsbDsKKwkgCQlpZiAoYmluZGluZyAhPSBu
dWxsICYmICFiaW5kaW5nLmlzVmFsaWRCaW5kaW5nKCkpIHsKKwkJCQlvcmcuZWNsaXBzZS5qZHQu
aW50ZXJuYWwuY29tcGlsZXIubG9va3VwLlByb2JsZW1NZXRob2RCaW5kaW5nIHByb2JsZW1NZXRo
b2RCaW5kaW5nID0KKwkJCQkJKG9yZy5lY2xpcHNlLmpkdC5pbnRlcm5hbC5jb21waWxlci5sb29r
dXAuUHJvYmxlbU1ldGhvZEJpbmRpbmcpIGJpbmRpbmc7CisJCQkJYmluZGluZyA9IHByb2JsZW1N
ZXRob2RCaW5kaW5nLmNsb3Nlc3RNYXRjaDsKKwkgCQl9CisKKwkJCWlmIChiaW5kaW5nICE9IG51
bGwpIHsKKwkJCQlpZiAoIXRoaXMuaXNSZWNvdmVyaW5nQmluZGluZ3MgJiYgKChiaW5kaW5nLnRh
Z0JpdHMgJiBUYWdCaXRzLkhhc01pc3NpbmdUeXBlKSAhPSAwKSkgeworCQkJCQlyZXR1cm4gbnVs
bDsKKwkJCQl9CisJCQkJbWV0aG9kQmluZGluZyA9IChJTWV0aG9kQmluZGluZykgdGhpcy5iaW5k
aW5nVGFibGVzLmNvbXBpbGVyQmluZGluZ3NUb0FTVEJpbmRpbmdzLmdldChiaW5kaW5nKTsKKwkJ
CQlpZiAobWV0aG9kQmluZGluZyA9PSBudWxsKSB7CisJCQkJCW1ldGhvZEJpbmRpbmcgPSBuZXcg
TGFtYmRhQmluZGluZyh0aGlzLCBiaW5kaW5nLCBsYW1iZGFFeHByZXNzaW9uLmRlc2NyaXB0b3Ip
OworCQkJCQl0aGlzLmJpbmRpbmdUYWJsZXMuY29tcGlsZXJCaW5kaW5nc1RvQVNUQmluZGluZ3Mu
cHV0KGJpbmRpbmcsIG1ldGhvZEJpbmRpbmcpOworCQkJCX0KKwkJCX0KIAkJCWlmIChtZXRob2RC
aW5kaW5nID09IG51bGwpIHsKIAkJCQlyZXR1cm4gbnVsbDsKZGlmZiAtLWdpdCBhL29yZy5lY2xp
cHNlLmpkdC5jb3JlL2RvbS9vcmcvZWNsaXBzZS9qZHQvY29yZS9kb20vTWV0aG9kQmluZGluZy5q
YXZhIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvZG9tL29yZy9lY2xpcHNlL2pkdC9jb3JlL2RvbS9N
ZXRob2RCaW5kaW5nLmphdmEKaW5kZXggM2EwZjVkNS4uYmIwZjllMiAxMDA2NDQKLS0tIGEvb3Jn
LmVjbGlwc2UuamR0LmNvcmUvZG9tL29yZy9lY2xpcHNlL2pkdC9jb3JlL2RvbS9NZXRob2RCaW5k
aW5nLmphdmEKKysrIGIvb3JnLmVjbGlwc2UuamR0LmNvcmUvZG9tL29yZy9lY2xpcHNlL2pkdC9j
b3JlL2RvbS9NZXRob2RCaW5kaW5nLmphdmEKQEAgLTEsNCArMSw0IEBACiAvKioqKioqKioqKioq
KioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioq
KioqKioqKioqKgotICogQ29weXJpZ2h0IChjKSAyMDAwLCAyMDE0IElCTSBDb3Jwb3JhdGlvbiBh
bmQgb3RoZXJzLgorICogQ29weXJpZ2h0IChjKSAyMDAwLCAyMDE1IElCTSBDb3Jwb3JhdGlvbiBh
bmQgb3RoZXJzLgogICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gVGhpcyBwcm9ncmFtIGFuZCB0aGUg
YWNjb21wYW55aW5nIG1hdGVyaWFscwogICogYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSB0
ZXJtcyBvZiB0aGUgRWNsaXBzZSBQdWJsaWMgTGljZW5zZSB2MS4wCkBAIC00NjUsMiArNDY1LDMy
IEBACiAJfQogfQorY2xhc3MgTGFtYmRhQmluZGluZyBleHRlbmRzIE1ldGhvZEJpbmRpbmcgewor
CQorCU1ldGhvZEJpbmRpbmcgaW1wbCA9IG51bGw7CisJCisJTGFtYmRhQmluZGluZyhCaW5kaW5n
UmVzb2x2ZXIgcmVzb2x2ZXIsIAorCQkJb3JnLmVjbGlwc2UuamR0LmludGVybmFsLmNvbXBpbGVy
Lmxvb2t1cC5NZXRob2RCaW5kaW5nIGJpbmRpbmcsIAorCQkJb3JnLmVjbGlwc2UuamR0LmludGVy
bmFsLmNvbXBpbGVyLmxvb2t1cC5NZXRob2RCaW5kaW5nIHNhbSkgeworCQlzdXBlcihyZXNvbHZl
ciwgc2FtKTsKKwkJdGhpcy5pbXBsID0gbmV3IE1ldGhvZEJpbmRpbmcocmVzb2x2ZXIsIGJpbmRp
bmcpOworCX0KKworCUBPdmVycmlkZQorCXB1YmxpYyBTdHJpbmcgZ2V0S2V5KCkgeworCQlyZXR1
cm4gdGhpcy5pbXBsLmdldEtleSgpOworCX0KKwkKKwlAT3ZlcnJpZGUKKwlwdWJsaWMgaW50IGdl
dE1vZGlmaWVycygpIHsKKwkJcmV0dXJuIHRoaXMuaW1wbC5nZXRNb2RpZmllcnMoKTsKKwl9CisK
KwlAT3ZlcnJpZGUKKwlwdWJsaWMgSUFubm90YXRpb25CaW5kaW5nW10gZ2V0UGFyYW1ldGVyQW5u
b3RhdGlvbnMoaW50IHBhcmFtSW5kZXgpIHsKKwkJcmV0dXJuIHRoaXMuaW1wbC5nZXRQYXJhbWV0
ZXJBbm5vdGF0aW9ucyhwYXJhbUluZGV4KTsKKwl9CisKKwlwdWJsaWMgSUFubm90YXRpb25CaW5k
aW5nW10gZ2V0QW5ub3RhdGlvbnMoKSB7CisJCXJldHVybiB0aGlzLmltcGwuZ2V0QW5ub3RhdGlv
bnMoKTsKKwl9Cit9ClwgTm8gbmV3bGluZSBhdCBlbmQgb2YgZmlsZQo=
</data>

          </attachment>
      

    </bug>

</bugzilla>