<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>456924</bug_id>
          
          <creation_ts>2015-01-07 09:43:00 -0500</creation_ts>
          <short_desc>StackOverflowError during compilation</short_desc>
          <delta_ts>2015-02-28 09:48:24 -0500</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4.1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 7</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M5</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Dieter Kleinrath">dieter.kleinrath</reporter>
          <assigned_to name="Stephan Herrmann">stephan.herrmann</assigned_to>
          <cc>jarthana</cc>
    
    <cc>stephan.herrmann</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2502867</commentid>
    <comment_count>0</comment_count>
    <who name="Dieter Kleinrath">dieter.kleinrath</who>
    <bug_when>2015-01-07 09:43:14 -0500</bug_when>
    <thetext>Since upgrading to JDT 3.11.0.v20141210-2000 I get a StackOverflowError during the compilation of a JDT project that compiled fine with JDT 3.11.0.v20141029-2000.

I was able to reduce the code causing the error to the following snippet:

--------------------------------

class Test1&lt;E&gt; {
	&lt;T extends Test1&lt;T&gt;&gt; void method1(Class&lt;T&gt; t) {
		Test2&lt;? super T&gt; test2 = getTest2(t);
                // getTest2(t); // --&gt; no error
	}
	&lt;T extends Test1&lt;T&gt;&gt; Test2&lt;? super T&gt; getTest2(Class&lt;T&gt; t){
		return null;
	}
	
}

class Test2&lt;E extends Test1&lt;E&gt;&gt;{}

---------------------------------

I&apos;m not exactly sure what causes the error but it seems to have to do with the generic parameter &lt;E extends Test1&lt;E&gt;&gt; in class Test2 in combination with the returned Test2&lt;? super T&gt; of the method getTest2.

The error goes away when doing any the following:
- removing &quot;Test2&lt;? super T&gt; test2 =&quot; (see the commented out code in the snippet)
- changing the generic type of Test2 to be just &lt;E&gt;
- changing the return type of getTest2 to be just Test2&lt;?&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2502906</commentid>
    <comment_count>1</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-01-07 10:40:39 -0500</bug_when>
    <thetext>Reproduced on master.

The cycle is between the capture binding 

capture#1-of ? super T#0

and it&apos;s superclass, which contains the same capture binding as one of it&apos;s arguments.

class Test1&lt;capture#1-of ? super T#0&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2502908</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-07 10:53:43 -0500</bug_when>
    <thetext>(In reply to Jay Arthanareeswaran from comment #1)
&gt; Reproduced on master.
&gt; 
&gt; The cycle is between the capture binding 
&gt; 
&gt; capture#1-of ? super T#0
&gt; 
&gt; and it&apos;s superclass, which contains the same capture binding as one of it&apos;s
&gt; arguments.
&gt; 
&gt; class Test1&lt;capture#1-of ? super T#0&gt;

Cyclic types alone shouldn&apos;t be a reason for StackOverflow.

Where does the stack overflow happen?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2502910</commentid>
    <comment_count>3</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-01-07 10:55:01 -0500</bug_when>
    <thetext>The code that causes this was released as part of bug 448800.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2502913</commentid>
    <comment_count>4</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-01-07 10:56:22 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #2)
&gt; Where does the stack overflow happen?

	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.substituteInferenceVariable(ParameterizedTypeBinding.java:869)
	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.substituteInferenceVariable(CaptureBinding.java:388)
	at org.eclipse.jdt.internal.compiler.lookup.ParameterizedTypeBinding.substituteInferenceVariable(ParameterizedTypeBinding.java:869)
	at org.eclipse.jdt.internal.compiler.lookup.CaptureBinding.substituteInferenceVariable(CaptureBinding.java:388)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2502939</commentid>
    <comment_count>5</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-07 11:34:35 -0500</bug_when>
    <thetext>thanks, I&apos;ll take a look</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2505223</commentid>
    <comment_count>6</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-13 16:30:34 -0500</bug_when>
    <thetext>The immediate issue can be fixed right in CaptureBinding.substituteInferenceVariable(), by one of the typical recursion-limiting techniques (cf. TVB#inRecursiveFunction). For correctness, when we detect recursion, we should probably answer the substitute being assembled in the invocation down the call stack.

Next, I observed that substitution still didn&apos;t work correctly. Apparently, a non-proper capture binding was registered as a naked type in TypeSystem, which forced the non-proper capture into substitution, even when a proper variant was provided (TypeBinding.equalsEquals is agnostic to inference variable substitution?). During debugging I worked around this by some Force Returns.

Finally, inference fails at a constraint where it shouldn&apos;t fail. When it happens we have a &apos;captureof ? super T#0&apos;, which we wrongly consider as a proper type. When fixing CaptureBinding.isProperType() to also search for ivars in the lower bound, inference succeeds.

Interestingly, with the third part of the fix, the first part is no longer triggered. I still need to figure out why that is so, and whether this implies that the first part is unnecessary / concerns a situation that should never occur.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2505252</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-13 17:30:42 -0500</bug_when>
    <thetext>Here&apos;s where behavior diverges with different implementations for CaptureBinding.isProperType():

In CExprF.inferPolyInvocationType(), we have a section protected by &quot;if (SHOULD_WORKAROUND_BUG_JDK_8054721)&quot;, where in HEAD we would create this type bound:
   ? super T#0#1 = capture#1-of ? super T#0
LHS is an ivar for the same wildcard that is captured by the RHS. With the corrected version of isProperType() this type bound is no longer created.

From that bound it takes several steps of incorporation until we request (in BoundSet.combineSameSameWithProperType()):
   capture#1-of ? super T#0 [ T#0 := &lt;T extends Test1&lt;T&gt;&gt; ]
where the capture is this recursive thing (recursive via its superclass), causing the SOE during substitution.

Perhaps the key observation in this analysis: the recursive capture existed before the point of divergence (it is actually the very type which answers wrongly to isProperType()).

For the method CaptureBinding.substituteInferenceVariable() I don&apos;t see evidence in either direction:

- is it safe? If the recursive capture would be impossible, we would be sure to never get into this situation, but, NO: it&apos;s not impossible, the recursive capture with ivar can indeed be observed

- is it a definite problem? NO: in our entire RunAllJava8Tests we see not a single instance where such recursion happens after isProperType() has been fixed.

Ergo: it&apos;s probably safest to apply both fixes even if one part is not triggered.

See https://git.eclipse.org/r/39542</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2505274</commentid>
    <comment_count>8</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-01-13 18:53:19 -0500</bug_when>
    <thetext>Released for 4.5 M5 via commit 3c1fddff6d397917a4f2c0ea6ea46a4e7420b00d</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2511110</commentid>
    <comment_count>9</comment_count>
    <who name="Jay Arthanareeswaran">jarthana</who>
    <bug_when>2015-01-28 00:47:28 -0500</bug_when>
    <thetext>Verified for 4.5 M5 with build I20150127-0900</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2525185</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2015-02-28 09:48:24 -0500</bug_when>
    <thetext>*** Bug 452810 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>