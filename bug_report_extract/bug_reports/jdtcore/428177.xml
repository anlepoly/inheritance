<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>428177</bug_id>
          
          <creation_ts>2014-02-14 05:59:00 -0500</creation_ts>
          <short_desc>[1.8][compiler] Insistent capture issues.</short_desc>
          <delta_ts>2014-10-29 07:14:34 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>2</classification_id>
          <classification>Eclipse</classification>
          <product>JDT</product>
          <component>Core</component>
          <version>4.4</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows 8</op_sys>
          <bug_status>VERIFIED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P3</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>4.5 M3</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Srikanth Sankaran">srikanth_sankaran</reporter>
          <assigned_to name="Srikanth Sankaran">srikanth_sankaran</assigned_to>
          <cc>shankhba</cc>
    
    <cc>srikanth_sankaran</cc>
    
    <cc>stephan.herrmann</cc>
    
    <cc>timo.kinnunen</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2363364</commentid>
    <comment_count>0</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-14 05:59:02 -0500</bug_when>
    <thetext>+++ This bug was initially created as a clone of Bug #424198 +++

Test case is same as https://bugs.eclipse.org/bugs/attachment.cgi?id=238389.

NOTE: this test contains some errors which are also issued by JDK.

I&apos;ll release junits shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2363384</commentid>
    <comment_count>1</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-14 06:13:11 -0500</bug_when>
    <thetext>Released NegativeLambdaExpressionsTest._test424198()

The expected results need to adjusted after fixing and after comparing with JDK8.

Stephan, As we wondered in the context of  Bug 426984, there could be more
places where we may have to &quot;uncapture&quot; - The IPI is simply 
TypeBinding.uncapture(Scope).

If you discover the one central systematic way of doing this, we should
withdraw the present set of calls to uncapture() from other places. A reminder
that my attempts at doing it in InferenceContext18.getParameter found several
failing tests.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2364773</commentid>
    <comment_count>2</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-18 07:41:38 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #1)
&gt; Released NegativeLambdaExpressionsTest._test424198()

mh, I can&apos;t find the test. Do you?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2364820</commentid>
    <comment_count>3</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-18 09:00:44 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #2)

&gt; mh, I can&apos;t find the test. Do you?

Sorry, don&apos;t know what happened. Released org.eclipse.jdt.core.tests.compiler.regression.NegativeLambdaExpressionsTest._test428177() now.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365216</commentid>
    <comment_count>4</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-18 19:06:28 -0500</bug_when>
    <thetext>The first example I looked at is at line 19:

Stream&lt;String&gt; stream2 = entries.map(toName).distinct();
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Type mismatch: cannot convert from Stream&lt;capture#2-of ? extends String&gt; to Stream&lt;String&gt;

Here, toName has a capture type, which propagates through map and distinct into the result type of the RHS.

The LHS does not have a wildcard type. 

=&gt; I&apos;m convinced that our error is correct

Javac, however, is silent about this line. :(

I should dig out the email where Dan inferred how javac seems to incorrectly apply uncapture-and-recapture in situations where this is unsound.


Srikanth, can you name an example in the test where you expect a different answer than what ecj currently says?

(javac complains only at lines 21, 36 and 38)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365238</commentid>
    <comment_count>5</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-18 20:18:43 -0500</bug_when>
    <thetext>Timo, can you take a closer look and see if there are to be reported against
javac - I will also do so.

A good exercise would be to transform this to use only 1.7 constructs.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365244</commentid>
    <comment_count>6</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-18 21:32:16 -0500</bug_when>
    <thetext>(In reply to comment #4)
&gt; The first example I looked at is at line 19:
&gt; 
&gt; Stream&lt;String&gt; stream2 = entries.map(toName).distinct();
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&gt; Type mismatch: cannot convert from Stream&lt;capture#2-of ? extends String&gt; to
&gt; Stream&lt;String&gt;
&gt; 
&gt; Here, toName has a capture type, which propagates through map and distinct into
&gt; the result type of the RHS.
&gt; 
&gt; The LHS does not have a wildcard type.
&gt; 
&gt; =&gt; I&apos;m convinced that our error is correct
&gt; 
&gt; Javac, however, is silent about this line. :(

This is how I understand this case to go: entries has non-wildcard type Stream&lt;JarEntry&gt; from Stream&lt;T&gt;, giving T=JarEntry. &lt;R&gt;map takes in parameter types &lt;? super T, ? extends R&gt; and returns Stream&lt;R&gt;. Giving it an argument with parameter types &lt;? super JarEntry, ? extends String&gt; fits perfectly when T=JarEntry, R=String and so the return value&apos;s type Stream&lt;R&gt; is Stream&lt;String&gt;. Then distinct just passes through the type without changes.

I admit wildcards are not my specialty and I think I misdiagnosed the first javac error as incorrect. So of the 3 javac errors first and last are Ok, I think. Not sure about the middle one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365533</commentid>
    <comment_count>7</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-19 10:36:50 -0500</bug_when>
    <thetext>I admit my reasoning was a bit superficial :)

First point to mention:
Type of variable access &apos;toName&apos; is
  Function&lt;captureof ? super JarEntry, captureof ? extends String&gt;
I tried if uncapture of this type right when it enters inference helps:
Result: nope.

When inferring types for &lt;R&gt;map we have this constraint:
  toName -&gt; Function&lt;? super JarEntry, ? extends R#0&gt;
where R#0 is the inference variable representing R.

From here on I have to check in micro steps, whether R#0 should be inferred to String (as you suggest) or to &quot;capture of ? extends String&quot; (as my implementation suggests).

I&apos;ll be back with more details later today.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365652</commentid>
    <comment_count>8</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-19 14:01:53 -0500</bug_when>
    <thetext>static Stream&lt;String&gt; coerce(Stream&lt;? extends String&gt; stream) { return stream.collect(Collectors.toList()).stream(); }

For the second javac error (code above) that I wasn&apos;t sure about, I&apos;m still not sure but I&apos;m not likely to make much more further progress, so here&apos;s what I think.

I think javac is working forwards starting from Collector&lt;? super T, A, R&gt; which
gives T=? extends String (from Stream&lt;? extends String&gt;)
gives Collector&lt;? super ? extends String, A, R&gt;
gives ? super ? extends String=Object (any supertype of any subtype of the concrete type == unrelated interfaces with only Object in common)
gives Collector&lt;Object, A R&gt;
gives T=Object 
gives R=List&lt;Object&gt;
gives E=Object
gives Stream&lt;E&gt;=Stream&lt;Object&gt; (Stream&lt;Object&gt; != Stream&lt;String&gt;, the end.)

But it seems if this was worked backwards from the returned type it could work out if Collector&lt;String, ?, List&lt;String&gt;&gt; is reached first, like here:

static Stream&lt;String&gt; coerce(Stream&lt;? extends String&gt; stream) { return stream.collect(Collectors.&lt;String&gt;toList()).stream(); }

Most notable would be inferring       
Collection&lt;String&gt;=List&lt;T2&gt;
gives Collection&lt;String&gt; super List&lt;T2&gt;
gives T2=String (anything else gives failure)

Whether the inference as specified allows determining this is another thing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365763</commentid>
    <comment_count>9</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-19 17:32:58 -0500</bug_when>
    <thetext>Alright, here&apos;s the reference I&apos;ve been searching:
http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000448.html

More diligence is needed to see if/how that statement helps address this bug, but it&apos;s always good to remember: &quot;The problem is in the vaguely-defined notion of the supertypes of a wildcard-parameterized type&quot;. There&apos;s more goodness in that post.


I must correct a previous statement: uncapturing type of actual invocation arguments *would* lead to accepting line 19. But then we&apos;d deliberately (and against the spec) enter the realm of comparing wildcard-types with real types. As expected, this change causes regressions in other tests which would require more workarounds, which would take us further and further away from the spec. Not a bright perspective. 
The argument toName is an expression with a capture type, no reason to change this to the wildcard thing. Wildcards are for required types, not for provided types.

For the time being let me just reproduce the reduction for said line 19,
starting from the initial constraint for the argument of entries.map(toName):

toName  Function&lt;? super JarEntry,? extends R#0&gt;

Function&lt;capture#1-of ? super JarEntry,capture#2-of ? extends String&gt;  Function&lt;? super JarEntry,? extends R#0&gt;

Function&lt;capture#1-of ? super JarEntry,capture#2-of ? extends String&gt; &lt;: Function&lt;? super JarEntry,? extends R#0&gt;

    capture#1-of ? super JarEntry &lt;= ? super JarEntry
        JarEntry &lt;: capture#1-of ? super JarEntry
            TRUE

    capture#2-of ? extends String &lt;= ? extends R#0
        capture#2-of ? extends String &lt;: R#0
            capture#2-of ? extends String &lt;: R#0

The last line is a type bound, which cannot be further reduced.
Later during resolution this type bound directly leads to instantiating the inference variable R#0 as &quot;capture#2-of ? extends String&quot;.

Feel free to ask if any symbols are unclear or reduction steps look wrong. But rest assured, I didn&apos;t manually write this reduction, its just a transcript from the inference engine :)

From the instantiation of R#0 continues my reasoning from comment 4.
Ergo: I&apos;m not keen to change how we handle this line.


Other lines I should investigate?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365771</commentid>
    <comment_count>10</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-19 17:58:50 -0500</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #8)
&gt; I think javac is working forwards starting from ...

when looking at this expression:
    stream.collect(Collectors.toList()).stream()
in an assignment context targeting 
    Stream&lt;String&gt;

The order of processing must be:

1. resolve stream

2. infer collect(Collectors.toList())
   - this is a standalone expression, no target type available
   - we know the receiver type from stream
   - type argument for toList() is determined as part of this inference

3. resolve or infer .stream()
   - assignment context, target type is Stream&lt;String&gt;
   - we use the type inferred in (2) as the receiver type


For the curios I&apos;m dumping the results of inference:

Step 2: candidate is &lt;R,A&gt; R collect(Collector&lt;? super T,A,R&gt;) 

Inference Context (type inferred) (loose) (resolved)
Inference Variables:
	R#0	:	java.util.List&lt;capture#1-of ? extends java.lang.String&gt;
	A#1	:	java.lang.Object
	T#2	:	capture#1-of ? extends java.lang.String
	T#2	:	capture#1-of ? extends java.lang.String
	?#3	:	java.lang.Object
	List&lt;T#2&gt;#4	:	java.util.List&lt;capture#1-of ? extends java.lang.String&gt;
Type Bounds:
	Dependency ?#3 = A#1
	TypeBound  ?#3 = java.lang.Object
	TypeBound  ?#3 &lt;: java.lang.Object
	Dependency R#0 = java.util.List&lt;T#2&gt;
	TypeBound  R#0 = java.util.List&lt;capture#1-of ? extends java.lang.String&gt;
	TypeBound  R#0 &lt;: java.lang.Object
	TypeBound  A#1 = java.lang.Object
	TypeBound  A#1 &lt;: java.lang.Object
	TypeBound  T#2 :&gt; capture#1-of ? extends java.lang.String
	TypeBound  T#2 = capture#1-of ? extends java.lang.String
	Dependency T#2 = T#2
	TypeBound  T#2 &lt;: java.lang.Object
	Dependency List&lt;T#2&gt;#4 = R#0
	Dependency List&lt;T#2&gt;#4 = java.util.List&lt;T#2&gt;
	TypeBound  List&lt;T#2&gt;#4 = java.util.List&lt;capture#1-of ? extends java.lang.String&gt;
	TypeBound  List&lt;T#2&gt;#4 &lt;: java.lang.Object


Step 3: exact method is Stream&lt;E&gt; stream(), no inference is needed.
From receiver type 
   List&lt;capture#1-of ? extends java.lang.String&gt;
the method is instantiated as
   Stream&lt;capture#1-of ? extends java.lang.String&gt; stream()

Final type check:
required: Stream&lt;java.lang.String&gt;
provided: Stream&lt;capture#1-of ? extends java.lang.String&gt;
verdict:  guilty

Questions? :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365773</commentid>
    <comment_count>11</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-19 18:20:13 -0500</bug_when>
    <thetext>To anybody wanting to learn more about javac and capture I recommend this:

https://bugs.openjdk.java.net/browse/JDK-8016207


Concrete proposal for this bug: can we prioritize criteria for potential changes like this:

1. does ecj behavior violate the spec?

If that leaves room for interpretation:

2. does ecj reject programs that are actually type safe?

If that leaves room for interpretation:

3. can we align ecj behavior with javac?


I&apos;d hate to invest tremendous efforts in making our compiler worse.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365779</commentid>
    <comment_count>12</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 19:21:39 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #11)
&gt; I&apos;d hate to invest tremendous efforts in making our compiler worse.

I agree. Timo, could you report this bug to JDK and letv us know what the
response is please ? TIA.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365784</commentid>
    <comment_count>13</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-19 19:46:50 -0500</bug_when>
    <thetext>As at the moment, the smoking gun points at javac compiler doing unspecified
steps, I am taking this out of reckoning for GA. If evidence emerges to the
contrary will pull it back up. If evidence emerges confirming our hypothesis
will resolve as WONTFIX.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2365963</commentid>
    <comment_count>14</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-20 07:13:34 -0500</bug_when>
    <thetext>(In reply to comment #12)
&gt; I agree. Timo, could you report this bug to JDK and letv us know what the
&gt; response is please ? TIA.

I&apos;m sorry, I&apos;m the wrong person for writing that up, this is way too abstract for me. I can barely follow along as it is, trying to communicate some new insights into the inner intricacies in inference, succinctly but precisely and correctly, would end up anything but.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367212</commentid>
    <comment_count>15</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-22 10:40:42 -0500</bug_when>
    <thetext>(In reply to comment #9)
&gt; Alright, here&apos;s the reference I&apos;ve been searching:
&gt; http://mail.openjdk.java.net/pipermail/lambda-spec-experts/2013-December/000448.html
&gt; 
&gt; More diligence is needed to see if/how that statement helps address this bug,
&gt; but it&apos;s always good to remember: &quot;The problem is in the vaguely-defined notion
&gt; of the supertypes of a wildcard-parameterized type&quot;. There&apos;s more goodness in
&gt; that post.

Hmm, doesn&apos;t sound very reassuring :) I skimmed the Wild FJ paper mentioned in JLS7 to try to make some sense of what all this is supposed to be in the end but I&apos;m not sure it helped. It had this one: &quot;We state the subject reduction theorem. A proof is in progress, and we expect to publish it in a later version of this work. This of course is an entirely vacuous statement as far as validity of the theorem goes, but we are nevertheless optimistic.&quot; And of the calculus: &quot; A constructor is implicit, taking one argument for each eld. Method declarations (M) contain type variables with bounds, return type, method name, arguments, and a body that returns the result of evaluating an expression.&quot;, which is notable for failing to account for checked exceptions as early as 2005.

Another paper from 2007, On Decidability of Nominal Subtyping with Variance, doesn&apos;t mention any breakthroughs since the first but there is this gem in Appendix A:
Example 2   The following example causes both javac 1.5 and javac 1.6.0-beta2 to run out of stack.
class T { } 
class N&lt;Z&gt; { }
class C&lt;X&gt; extends N&lt;N&lt;? super C&lt;C&lt;X&gt;&gt;&gt;&gt; {
  N&lt;? super C&lt;T&gt;&gt; cast(C&lt;T&gt; c) { return c; } 
} 

Still works today.

&gt; Feel free to ask if any symbols are unclear or reduction steps look wrong. But
&gt; rest assured, I didn&apos;t manually write this reduction, its just a transcript from
&gt; the inference engine :)

Ok, here goes :)

&gt; The last line is a type bound, which cannot be further reduced.
&gt; Later during resolution this type bound directly leads to instantiating the
&gt; inference variable R#0 as &quot;capture#2-of ? extends String&quot;.

So as I understand, &quot;capture#2-of ? extends String&quot; means in plain English &quot;a type we&apos;re not sure we&apos;ve seen before, of which we know it&apos;s either String or any one of its subtypes&quot;. So what is determining that &quot;capture#2-of ? extends String&quot; is not String?

And a followup: type parameters can pass through any wildcard-originated types without problems, like here:

  private static &lt;STRING&gt; Stream&lt;STRING&gt; immutableStream(Stream&lt;STRING&gt; s) { return s; }
  private static void streamIn4(Stream&lt;String&gt; s1, Stream&lt;? super String&gt; s2, Stream&lt;? extends String&gt; s3, Stream&lt;?&gt; s4) {
    Stream&lt;String&gt;           a1 = immutableStream(s1);
    Stream&lt;? super String&gt;   b2 = immutableStream(s2);
    Stream&lt;? extends String&gt; c3 = immutableStream(s3);
    Stream&lt;?&gt;                d4 = immutableStream(s4);
  }

So then how come adding one such level of indirection around the distinct()-method call gets rid of the error? Like this:

  private static &lt;T&gt; Stream&lt;T&gt; distinguish(Stream&lt;T&gt; z) { return z.distinct(); }
  private static void varieties() {
    Stream&lt;String&gt; a1 = ((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null).distinct(); // error
    Stream&lt;String&gt; a4 = distinguish(((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null)); // ok
    Stream&lt;? super String&gt; b1 = ((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null).distinct(); // error
    Stream&lt;? super String&gt; b4 = distinguish(((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null)); // ok
  }

&gt; Other lines I should investigate?

These ones please, although I suspect these might get fixed in bug 428786 

The first version shows 2 errors, the second one has none. I didn&apos;t notice before, but one error is new since opening this bug. As a special request, could they be done in parallel and interleaved? :) Might be illustrative of how big a difference there is between them.

  private static void without(Stream&lt;String&gt; distinct) {distinct.forEach(s -&gt; System.out.println(s));}
  static void process(Stream&lt;? extends String&gt; s1, Stream&lt;? extends String&gt; s2) {
    without(s1.map((String v) -&gt; { // ERROR
      String r = &quot;&quot; + v;
      return r; // NEW ERROR
    }));
    without(s2.map((v) -&gt; { // Ok
      String r = &quot;&quot; + v;
      return r; // Ok
    }));
  }</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367219</commentid>
    <comment_count>16</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-22 11:27:45 -0500</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #15)
&gt; Hmm, doesn&apos;t sound very reassuring :) I skimmed the Wild FJ paper mentioned
&gt; in JLS7 to try to make some sense of what all this is supposed to be in the
&gt; end but I&apos;m not sure it helped.

I&apos;m not firm wrt the content of that paper, but I personally know one of the authors, so if you have specific questions, it should be quite easy to get clarification..

&gt; Example 2   The following example causes both javac 1.5 and javac
&gt; 1.6.0-beta2 to run out of stack.

the same for ecj, so running out of stack might be the spec&apos;d behavior ;-P


&gt; &gt; The last line is a type bound, which cannot be further reduced.
&gt; &gt; Later during resolution this type bound directly leads to instantiating the
&gt; &gt; inference variable R#0 as &quot;capture#2-of ? extends String&quot;.
&gt; 
&gt; So as I understand, &quot;capture#2-of ? extends String&quot; means in plain English
&gt; &quot;a type we&apos;re not sure we&apos;ve seen before, of which we know it&apos;s either
&gt; String or any one of its subtypes&quot;. So what is determining that
&gt; &quot;capture#2-of ? extends String&quot; is not String?

The question is: who&apos;s to decide the exact type? 
By constructing a capture we basically say: someone else (e.g. the caller of the current method) has already decided the exact type, just he can&apos;t tell us. We&apos;re no longer free to chose the interpretation. E.g.

void test(List&lt;? extends Person&gt; l, Person p) {
   l.add(p);
}
Gives this error:
The method add(capture#1-of ? extends Person) in the type List&lt;capture#1-of ? extends Person&gt; is not applicable for the arguments (Person)

This is to account for clients that could be calling test with, e.g., a List&lt;Employee&gt; (Employee subtype of Person). All we know about the type parameter is an upper bound. Whatever we try to pass to add() will break *some* client of test(), because for a safe call to add() we&apos;d need a lower bound (or exact type argument).

This makes capture-parameterized types pretty much incompatible to anything (each capture creates a new type), except for matching wildcard-parameterized types.


&gt; And a followup: type parameters can pass through any wildcard-originated
&gt; types without problems, like here:
&gt; 
&gt;   private static &lt;STRING&gt; Stream&lt;STRING&gt; immutableStream(Stream&lt;STRING&gt; s) {
&gt; return s; }
&gt;   private static void streamIn4(Stream&lt;String&gt; s1, Stream&lt;? super String&gt;
&gt; s2, Stream&lt;? extends String&gt; s3, Stream&lt;?&gt; s4) {
&gt;     Stream&lt;String&gt;           a1 = immutableStream(s1);
&gt;     Stream&lt;? super String&gt;   b2 = immutableStream(s2);
&gt;     Stream&lt;? extends String&gt; c3 = immutableStream(s3);
&gt;     Stream&lt;?&gt;                d4 = immutableStream(s4);
&gt;   }

yes, each of the assignments b2, c3, d4 simply drops some of the type information which the signature of immutableStream() provides.

&gt; So then how come adding one such level of indirection around the
&gt; distinct()-method call gets rid of the error? Like this:

I&apos;m not sure I understand your expectation.

One thing to note: by adding the .distinct() call, we prevent any information about the target type (given by the type of the local variable) to flow into inference of the map call. This means we first have to decide a type for map(), which forces application of capture if the return type contains wildcards. Only after capturing we analyse the signature of distinct().

&gt; &gt; Other lines I should investigate?
&gt; 
&gt; These ones please, although I suspect these might get fixed in bug 428786 
&gt; 
&gt; The first version shows 2 errors, the second one has none. I didn&apos;t notice
&gt; before, but one error is new since opening this bug. As a special request,
&gt; could they be done in parallel and interleaved? :) Might be illustrative of
&gt; how big a difference there is between them.
&gt; 
&gt;   private static void without(Stream&lt;String&gt; distinct) {distinct.forEach(s
&gt; -&gt; System.out.println(s));}
&gt;   static void process(Stream&lt;? extends String&gt; s1, Stream&lt;? extends String&gt;
&gt; s2) {
&gt;     without(s1.map((String v) -&gt; { // ERROR
&gt;       String r = &quot;&quot; + v;
&gt;       return r; // NEW ERROR
&gt;     }));
&gt;     without(s2.map((v) -&gt; { // Ok
&gt;       String r = &quot;&quot; + v;
&gt;       return r; // Ok
&gt;     }));
&gt;   }

As of HEAD this compiles without any errors :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367220</commentid>
    <comment_count>17</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-22 11:33:50 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #16)
 
&gt; &gt; Example 2   The following example causes both javac 1.5 and javac
&gt; &gt; 1.6.0-beta2 to run out of stack.
&gt; 
&gt; the same for ecj, so running out of stack might be the spec&apos;d behavior ;-P

https://bugs.eclipse.org/bugs/show_bug.cgi?id=172672</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367221</commentid>
    <comment_count>18</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-22 11:38:35 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #17)
&gt; (In reply to Stephan Herrmann from comment #16)
&gt;  
&gt; &gt; &gt; Example 2   The following example causes both javac 1.5 and javac
&gt; &gt; &gt; 1.6.0-beta2 to run out of stack.
&gt; &gt; 
&gt; &gt; the same for ecj, so running out of stack might be the spec&apos;d behavior ;-P
&gt; 
&gt; https://bugs.eclipse.org/bugs/show_bug.cgi?id=172672

I see you beat us to it :)

Any plans to address this? (I wouldn&apos;t expect so)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367229</commentid>
    <comment_count>19</comment_count>
    <who name="Timo Kinnunen">timo.kinnunen</who>
    <bug_when>2014-02-22 13:11:28 -0500</bug_when>
    <thetext>(In reply to comment #16)
&gt; (In reply to Timo Kinnunen from comment #15)
&gt; &gt; Hmm, doesn&apos;t sound very reassuring :) I skimmed the Wild FJ paper mentioned
&gt; &gt; in JLS7 to try to make some sense of what all this is supposed to be in the
&gt; &gt; end but I&apos;m not sure it helped.
&gt; 
&gt; I&apos;m not firm wrt the content of that paper, but I personally know one of the
&gt; authors, so if you have specific questions, it should be quite easy to get
&gt; clarification..

No specific questions, anything more would require learning the DSL, its idioms, unstated assumptions, its conventions and deviations from them, then parsing the DSL in your head and I&apos;d rather have my Java types in an editor where I can poke at them. But I do wonder how much of the calculus is formally proven.

&gt; 
&gt; &gt; Example 2   The following example causes both javac 1.5 and javac
&gt; &gt; 1.6.0-beta2 to run out of stack.
&gt; 
&gt; the same for ecj, so running out of stack might be the spec&apos;d behavior ;-P
&gt; 
&gt; 
&gt; &gt; &gt; The last line is a type bound, which cannot be further reduced.
&gt; &gt; &gt; Later during resolution this type bound directly leads to instantiating the
&gt; &gt; &gt; inference variable R#0 as &quot;capture#2-of ? extends String&quot;.
&gt; &gt;
&gt; &gt; So as I understand, &quot;capture#2-of ? extends String&quot; means in plain English
&gt; &gt; &quot;a type we&apos;re not sure we&apos;ve seen before, of which we know it&apos;s either
&gt; &gt; String or any one of its subtypes&quot;. So what is determining that
&gt; &gt; &quot;capture#2-of ? extends String&quot; is not String?
&gt; 
&gt; The question is: who&apos;s to decide the exact type?
&gt; By constructing a capture we basically say: someone else (e.g. the caller of the
&gt; current method) has already decided the exact type, just he can&apos;t tell us. We&apos;re
&gt; no longer free to chose the interpretation. E.g.
&gt; 
&gt; void test(List&lt;? extends Person&gt; l, Person p) {
&gt; l.add(p);
&gt; }
&gt; Gives this error:
&gt; The method add(capture#1-of ? extends Person) in the type List&lt;capture#1-of ?
&gt; extends Person&gt; is not applicable for the arguments (Person)
&gt; 
&gt; This is to account for clients that could be calling test with, e.g., a
&gt; List&lt;Employee&gt; (Employee subtype of Person). All we know about the type
&gt; parameter is an upper bound. Whatever we try to pass to add() will break *some*
&gt; client of test(), because for a safe call to add() we&apos;d need a lower bound (or
&gt; exact type argument).
&gt; 
&gt; This makes capture-parameterized types pretty much incompatible to anything
&gt; (each capture creates a new type), except for matching wildcard-parameterized
&gt; types.

Hmm, I think Function::andThen shows the difference well from both providers and consumers POV. Rather than giving a straight road from A to B to C andThen gives all the roads that go via A to B followed by a night at a hotel followed by all the roads that go via B to C the next morning. It&apos;s almost like the segments weren&apos;t really connected and just happened to meet by chance.

&gt; &gt; And a followup: type parameters can pass through any wildcard-originated
&gt; &gt; types without problems, like here:
&gt; &gt;
&gt; &gt;   private static &lt;STRING&gt; Stream&lt;STRING&gt; immutableStream(Stream&lt;STRING&gt; s) {
&gt; &gt; return s; }
&gt; &gt;   private static void streamIn4(Stream&lt;String&gt; s1, Stream&lt;? super String&gt;
&gt; &gt; s2, Stream&lt;? extends String&gt; s3, Stream&lt;?&gt; s4) {
&gt; &gt;     Stream&lt;String&gt;           a1 = immutableStream(s1);
&gt; &gt;     Stream&lt;? super String&gt;   b2 = immutableStream(s2);
&gt; &gt;     Stream&lt;? extends String&gt; c3 = immutableStream(s3);
&gt; &gt;     Stream&lt;?&gt;                d4 = immutableStream(s4);
&gt; &gt;   }
&gt; 
&gt; yes, each of the assignments b2, c3, d4 simply drops some of the type
&gt; information which the signature of immutableStream() provides.

Please have another look :) All of the information should still be there, perfectly preserved across each method call boundary. Of course the caller can&apos;t see that but presumably it doesn&apos;t need to because it&apos;s using wildcards.

&gt; &gt; So then how come adding one such level of indirection around the
&gt; &gt; distinct()-method call gets rid of the error? Like this:
&gt; 
&gt; I&apos;m not sure I understand your expectation.
&gt; 
&gt; One thing to note: by adding the .distinct() call, we prevent any information
&gt; about the target type (given by the type of the local variable) to flow into
&gt; inference of the map call. This means we first have to decide a type for map(),
&gt; which forces application of capture if the return type contains wildcards. Only
&gt; after capturing we analyse the signature of distinct().

Right, in this instance what I&apos;m specifically pondering is why a1 works differently than a4 and likewise for b1 and b4:

  private static &lt;T&gt; Stream&lt;T&gt; distinguish(Stream&lt;T&gt; z) { return z.distinct(); }
  private static void varieties() {
    Stream&lt;String&gt; a1 = ((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null).distinct(); // error
    Stream&lt;String&gt; a4 = distinguish(((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null)); // ok
    Stream&lt;? super String&gt; b1 = ((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null).distinct(); // error
    Stream&lt;? super String&gt; b4 = distinguish(((Stream&lt;JarEntry&gt;) null).map((Function&lt;? super JarEntry, ? extends String&gt;) null)); // ok
  }

There&apos;s
1) member function distinct which receives Stream&lt;T&gt; and gives out Stream&lt;T&gt;
2) static function distinguish which is given &lt;T&gt; Stream&lt;T&gt; and gives out Stream&lt;T&gt;

and so I&apos;m wondering why these two give out different types for same inputs.

&gt; As of HEAD this compiles without any errors :)

I knew it!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367243</commentid>
    <comment_count>20</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-22 15:16:33 -0500</bug_when>
    <thetext>(In reply to Timo Kinnunen from comment #19)
Trying to understand the differences between your examples &quot;a1&quot; and &quot;a4&quot; I see to factors:

(One)
The shape of the statement, represented in a simplified way as:
  A a = s.map(f).distinct() 
vs. 
  A a = distinguish(s).map(f)

Remember: any &quot;.&quot; in an expression is a barrier for inference. We first have to decide the type left of the dot and only then inference for the rest starts. In particular, if the receiver expression evaluates to a capture type, this cannot be eliminated when inferring the second method call. In our case map is the one that&apos;s prone to introducing captures, so trouble occurs only when map is to the left of the dot.


(Two)
There&apos;s some asymmetry in how inference handles constraints regarding type argument containment. During inference for the s.map(f) expression I see this constraint (inferred: LHS from the argument f, RHS from the signature of map):
    capture#2-of ? extends String &lt;= ? extends R#0
this is reduced to this one:
    capture#2-of ? extends String &lt;: R#0

Notice that just the &quot;?&quot; on the RHS has been eliminated, not the capture on the LHS. From now on, the inference variable relates to a capture, which steers inference towards answering the following result type:
    capture#2-of ? extends String

Intuitively, we might say inferring &quot;String&quot; should be enough, but the capture type is more specific and hence that one is picked.

After this, and considering the &quot;.&quot; between map and distinct there&apos;s no way to get rid of the capture again. -&gt; Not assignment compatible.

----

IFF there&apos;s a bug in our compiler, where could it be? 

I don&apos;t think there&apos;s arguing about (One).

The decisive rule in the inference chain in (Two) is 18.2.3 [1]:
&quot;A constraint formula of the form S &lt;= T, ...
  ...
  If T is a wildcard of the form ? extends T&apos;:
     If S is a type, the constraint reduces to S &lt;: T&apos;.
     ...
&quot;
Insert from above:
 T = ? extends R#0
 T&apos; = R#0
 S = capture#2-of ? extends String

Feel free to step through the inference process and tell me what looks wrong.
No kidding, on request I will tell you some breakpoints where you can watch how inference proceeds as if it where the latest blockbuster :)


http://cr.openjdk.java.net/~dlsmith/jsr335-0.9.3/G.html#G18.2.3</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367244</commentid>
    <comment_count>21</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-02-22 15:31:56 -0500</bug_when>
    <thetext>As a final attempt to mind-read javac, I inserted one non-spec&apos;d uncapture() call at the point where we know that R#0 has &quot;capture#2-of ? extends String&quot; as its *lower bound*. Why not rather use &quot;? extends String&quot; as the result, this would make the example from comment 19 happy, indeed.

Point against: this &quot;point-fix&quot; causes 25 comile errors in package &quot;java&quot; and stackoverflow when compiling the entire JRE8.

At this point I have to disengage from this nice discussion. If anyone sees indications that ecj is at fault, too, (we already *know* that javac is at fault in this area), please argue in terms of the spec (because that&apos;s what I&apos;ve implemented), not what common sense might suggest.

Thanks.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367266</commentid>
    <comment_count>22</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-22 20:05:40 -0500</bug_when>
    <thetext>(In reply to Stephan Herrmann from comment #21)
&gt; As a final attempt to mind-read javac, I inserted one non-spec&apos;d uncapture()
&gt; call at the point where we know that R#0 has &quot;capture#2-of ? extends String&quot;
&gt; as its *lower bound*. Why not rather use &quot;? extends String&quot; as the result,
&gt; this would make the example from comment 19 happy, indeed.

I haven&apos;t studied all the comments in detail - just this one flying by, a 
curiosity question. Did you eliminate the capture in this place in general or
with some special handling for String being a final class and so 
&quot;capture#2-of ? extends String&quot; really just being String.

I tripped into a similar situation in 
https://bugs.eclipse.org/bugs/show_bug.cgi?id=428285.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2367272</commentid>
    <comment_count>23</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-02-22 22:13:51 -0500</bug_when>
    <thetext>(In reply to Srikanth Sankaran from comment #22)
&gt; I haven&apos;t studied all the comments in detail - just this one flying by, a 
&gt; curiosity question. Did you eliminate the capture in this place in general or
&gt; with some special handling for String being a final class and so 
&gt; &quot;capture#2-of ? extends String&quot; really just being String.

I tried this and this results in several regressions in our suite, not all of
which is due to textual differences in the expected output.

At this point, I am retargetting this to 4.4 - more study is needed and we also
need to watch how the various javac/spec issues Stephan has called out and have
been acknowledged as ones in which there is gap between javac and JLS get 
resolved.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456805</commentid>
    <comment_count>24</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-26 12:41:13 -0400</bug_when>
    <thetext>I&apos;ll take over this one, I have a fix coming shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456810</commentid>
    <comment_count>25</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-26 13:04:34 -0400</bug_when>
    <thetext>Fix and tests here: http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=48bf00145f70fca24101eaac33adc5d495f9e595.

Basically there was a bug in reducing type argument containment formulas.
CaptureBinding does not answer Binding.WILDCARD_TYPE but answers TYPE_PARAMETER.
So were injecting bad constraints that cause problems down the road.

This fix also aligns us fully with javac for bug 428177 and better aligns us
with javac on bug 432759 - we not emit one error there that javac also emits and
compile one more call than javac does, as opposed to no errors earlier.

Stephan, review at your convenience,</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2456826</commentid>
    <comment_count>26</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-09-26 13:39:03 -0400</bug_when>
    <thetext>*** Bug 443596 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2458025</commentid>
    <comment_count>27</comment_count>
    <who name="Stephan Herrmann">stephan.herrmann</who>
    <bug_when>2014-09-30 10:20:25 -0400</bug_when>
    <thetext>By sharing the fix with bug 432605 it should probably also share its status ...
See bug 432605 comment 11.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2472082</commentid>
    <comment_count>28</comment_count>
    <who name="Srikanth Sankaran">srikanth_sankaran</who>
    <bug_when>2014-10-26 21:26:56 -0400</bug_when>
    <thetext>OK, this entry has seen much more action and back and forth than necessary
including misguided adventurism on my part to change how type argument
containtment constraints are to be handled to make the program compile.

That some experimental code change of mine referred to in comment#25
made us compile this:

Stream&lt;String&gt; stream2 = entries.map(toName).distinct();

is screaming proof that the experimental change was completely wrong, but
my guards have been down at that moment to allow such code to get into master
even if only briefly.

Various interim wrong conclusions - this is a duplicate of that, that is
resolved by this patch etc have finally settled down and there is clarity
finally. Apologies for the confusion - I&apos;ll consider my wrists slapped ;-)

I agree with the analysis in comment#4. Released junit here:
http://git.eclipse.org/c/jdt/eclipse.jdt.core.git/commit/?id=4997f1f5c27828dc6733e1f0cda3081f9d59b298

bug 424198 is tracked on its own ticket.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2473480</commentid>
    <comment_count>29</comment_count>
    <who name="shankha banerjee">shankhba</who>
    <bug_when>2014-10-29 07:14:34 -0400</bug_when>
    <thetext>Verified for 4.5 M3 using  I20141027-2000 build.</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>