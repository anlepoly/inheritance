<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://bugs.eclipse.org/bugs/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.7"
          urlbase="https://bugs.eclipse.org/bugs/"
          
          maintainer="webmaster@eclipse.org"
>

    <bug>
          <bug_id>409343</bug_id>
          
          <creation_ts>2013-05-28 17:19:00 -0400</creation_ts>
          <short_desc>[regression] [editor] Fix life-cycle issues</short_desc>
          <delta_ts>2013-06-11 14:17:22 -0400</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>14</classification_id>
          <classification>Mylyn</classification>
          <product>Mylyn Reviews</product>
          <component>Framework</component>
          <version>unspecified</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P1</priority>
          <bug_severity>blocker</bug_severity>
          <target_milestone>2.0</target_milestone>
          <dependson>406354</dependson>
    
    <dependson>408737</dependson>
    
    <dependson>408765</dependson>
    
    <dependson>409306</dependson>
          
          <everconfirmed>1</everconfirmed>
          <reporter name="Miles Parker">milesparker</reporter>
          <assigned_to name="Miles Parker">milesparker</assigned_to>
          <cc>gunnar</cc>
    
    <cc>sam.davis</cc>
    
    <cc>steffen.pingel</cc>
    
    <cc>tomasz.zarna</cc>
          
          <votes>0</votes>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>2264659</commentid>
    <comment_count>0</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-28 17:19:32 -0400</bug_when>
    <thetext>This is a bug to round up all of the life-cycle issues for the editor the current release -- the # of bugs aren&apos;t really manageable individually and these issues should all have the same root causes. We&apos;ll reetain the orginal bugs so that we can be sure we&apos;ve addressed all issues. Any bugs later determined not to be caused by life-cycle issues will be removed from dependencies.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2264691</commentid>
    <comment_count>1</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-28 18:50:32 -0400</bug_when>
    <thetext>https://git.eclipse.org/r/#/c/13154/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2264696</commentid>
    <comment_count>2</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-05-28 18:55:38 -0400</bug_when>
    <thetext>Miles, can you provide some detail what you suspect the cause of the problem is and how it can be fixed?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2264700</commentid>
    <comment_count>3</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-28 19:31:54 -0400</bug_when>
    <thetext>Sure. So the basic issue is that we need to construct and update a complex set of nested controls (editor, sections, etc..) and do so in a way that matches expectations of task editors workflow (what happens when users click refresh, etc..), still works with Mylyn Tasks retrieval (so that comments and dates work proeperly)  but also meshes with the more direct communication provided through remote Gerrit API calls as mediated by the new Remote API. Within the Remote API context, we need to retrieve model objects a) when they don&apos;t exist at all on local machine or b) when the user requests them, or c) for creating buttons (since this *always* requires a live connection to backend). To give an idea of the complexity of this note that we might have any one of these situations -- note that this is just for patch sets, which is the most complex case:

a) Have a local Review model, but an non-existent (say new) patchset. In this case, we need to do a live retrieval when user first opens the patch set, which may or may not be when the editor is opened. Note that we *will* have some of the patch set data from the review retireval, and so we need to display that part, even when we don&apos;t have a connection to Gerrit.
b) Have an existing patchset but no connection to Gerrit. (In this case, the buttons cannot be displayed.)
c) Have an existing patchset, but a connection to Gerrit. (In this case, the patch set is displayed, but the buttons have to be created as part of a seperate remote update!)
d) Have changes to that patchset, such as comments, that need to be updated after user clicks refresh button.
e) Have the patch set notified of changes when another process (such as review navigator) causes the patch set to be refreshed.
f) There are probably one or two cases that I missed here...

So the problem is that this is not all working well for all cases.  This is all compounded by not having a good testing approach for the overall editor life-cycle. We have the classic issue where fixing one issue can introduce regressions elsewhere, and it&apos;s difficult to cover all cases in manual testing. Before, all of this code was hand written inside of the editor itself, which was nearly impossible to understand from a maintenance POV especially once I replaced the gerrit stuff w/ Remote API calls. I tried to regularize all of this by creating the Remote Clients, but I&apos;m not sure that was a good idea, because there end up being so many special cases anyway.

So, there a few ways to approach this. 1) I think no  matter what we should iterate a bit more on the current approach, as frustrating as it is, perhaps we&apos;re close and it&apos;s worth a day or two to find out. 2) We have very limited time, but we may need to step back a bit and really capture the entire life-cycle more formally, perhaps w/ an Activity diagram or something. 3) Think about how we might dramatically simplify the life-cycle, by say making all Gerrit reviews &quot;live&quot;, pre-empting the existing lazy updating scheme.

hth explain where we are..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2264747</commentid>
    <comment_count>4</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-05-29 02:53:23 -0400</bug_when>
    <thetext>With the latest patch set I still ran into problems refreshing the editor. Pressing refresh several times eventually resulted in exceptions being logged:

Caused by: java.lang.NullPointerException
	at org.eclipse.mylyn.internal.gerrit.ui.factories.SubmitUiFactory.isExecutable(SubmitUiFactory.java:38)
	at org.eclipse.mylyn.reviews.ui.spi.factories.AbstractUiFactory.createControl(AbstractUiFactory.java:60)
	at org.eclipse.mylyn.reviews.ui.spi.factories.AbstractUiFactoryProvider.createButtons(AbstractUiFactoryProvider.java:38)
	at org.eclipse.mylyn.reviews.ui.spi.editor.ReviewSetContentSection.updateButtons(ReviewSetContentSection.java:348)
	at org.eclipse.mylyn.reviews.ui.spi.editor.ReviewSetContentSection$2.update(ReviewSetContentSection.java:136)
	at org.eclipse.mylyn.reviews.core.spi.remote.emf.RemoteEmfClient.checkUpdate(RemoteEmfClient.java:52)
	at org.eclipse.mylyn.reviews.core.spi.remote.emf.RemoteEmfClient.updated(RemoteEmfClient.java:84)
	at org.eclipse.mylyn.reviews.core.spi.remote.emf.RemoteEmfConsumer$ConsumerAdapter.notifyChanged(RemoteEmfConsumer.java:85)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:374)
	at org.eclipse.emf.common.notify.impl.NotificationChainImpl.dispatch(NotificationChainImpl.java:98)
	at org.eclipse.emf.common.notify.impl.NotificationChainImpl.dispatch(NotificationChainImpl.java:86)
	at org.eclipse.mylyn.reviews.core.spi.remote.emf.RemoteEmfConsumer.applyModel(RemoteEmfConsumer.java:237)
	at org.eclipse.mylyn.reviews.core.spi.remote.JobRemoteService$2$1.run(JobRemoteService.java:77)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:164)

I&apos;m also seeing patch sets getting duplicated (bug 409306).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2264752</commentid>
    <comment_count>5</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-05-29 03:01:19 -0400</bug_when>
    <thetext>(In reply to comment #3)
&gt; Sure. So the basic issue is that we need to construct and update a complex set
&gt; of nested controls (editor, sections, etc..) and do so in a way that matches
&gt; expectations of task editors workflow (what happens when users click refresh,
&gt; etc..), still works with Mylyn Tasks retrieval (so that comments and dates work
&gt; proeperly)  but also meshes with the more direct communication provided through
&gt; remote Gerrit API calls as mediated by the new Remote API. 

Is the review model refresh always driven by the task editor or does it hook into the task refresh as well?

&gt; b) Have an existing patchset but no connection to Gerrit. (In this case, the
&gt; buttons cannot be displayed.)

Why handle buttons as a special case? Why not always display them and fail on submission. I would expect the model to have all information required to render buttons since eventually the editor should support full offline modifications including workflows.

&gt; c) Have an existing patchset, but a connection to Gerrit. (In this case, the
&gt; patch set is displayed, but the buttons have to be created as part of a seperate
&gt; remote update!)

I&apos;m not quite getting why this needs to be separate. Why can&apos;t that be retrieved when getting the patch set or patch set content?

&gt; 3) Think
&gt; about how we might dramatically simplify the life-cycle, by say making all
&gt; Gerrit reviews &quot;live&quot;, pre-empting the existing lazy updating scheme.

That sounds right to me. I would be careful about caching patch set content but it seems reasonable to me to cache all other information as part of task retrieval as it was done in 1.0. Even if we sacrifice some performance advantage we will be much better of with a radically simplified refresh strategy.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2265181</commentid>
    <comment_count>6</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-29 15:47:50 -0400</bug_when>
    <thetext>(In reply to comment #5)
&gt; Is the review model refresh always driven by the task editor or does it hook
&gt; into the task refresh as well?

No, it is only manually refreshed through the task editor (the user can initiate this from Review explorer as well). My understanding was that this was the expected approach, i.e. the task framework should only refresh large sets of data when the user explicitly requests. 

&gt; &gt; b) Have an existing patchset but no connection to Gerrit. (In this case, the
&gt; &gt; buttons cannot be displayed.)
&gt; 
&gt; Why handle buttons as a special case? Why not always display them and fail on
&gt; submission. I would expect the model to have all information required to render
&gt; buttons since eventually the editor should support full offline modifications
&gt; including workflows.

Well, the issue is that we don&apos;t know which buttons to provide. For example, you can submit some patch sets only if you have credentials.. And if you don&apos;t have a remote connection at all, it doesn&apos;t seem to make sense to do that. Also, as the errors attest, you actually need the remote data, as the exceptions attest. Though we could trap for those and/or make the buttons non-executable. I thought it better just not to show them at all, but hmm...

&gt; &gt; c) Have an existing patchset, but a connection to Gerrit. (In this case, the
&gt; &gt; patch set is displayed, but the buttons have to be created as part of a
&gt; seperate
&gt; &gt; remote update!)
&gt; 
&gt; I&apos;m not quite getting why this needs to be separate. Why can&apos;t that be retrieved
&gt; when getting the patch set or patch set content?

We do. But note that we may have the patch set items (because they&apos;re coming from the local model) but not the remote.

BTW, an additional complication that I didn&apos;t state is that we actually have multiple states that we can be in..

1. We can have the Review task data, but no model.
2. We can have the Review model, but no Remote object (the Gerrit API objects) *yet*.
3. We can have the Review model, but can&apos;t obtain the Remote object at all *yet*.
4. We can have the Remote object, but not the Review model (!) simply because the model hasn&apos;t been populated yet. (This case should be handled by the framework, and shouldn&apos;t be a concern for consumers.)

&gt; &gt; 3) Think
&gt; &gt; about how we might dramatically simplify the life-cycle, by say making all
&gt; &gt; Gerrit reviews &quot;live&quot;, pre-empting the existing lazy updating scheme.
&gt; 
&gt; That sounds right to me. I would be careful about caching patch set content but
&gt; it seems reasonable to me to cache all other information as part of task
&gt; retrieval as it was done in 1.0. Even if we sacrifice some performance advantage
&gt; we will be much better of with a radically simplified refresh strategy.

Can you say a bit more about what the strategy would be here?

Originally I had it setup to just not get anything but the bare task id and so on that we don&apos;t show any of the cached model data when we don&apos;t have the remote. I&apos;d love to do it this way, though this could be a pretty big change at this stage and mean that we grabbed data for every single review in the queries, right?

At that point though, we could do away with the integration into the editor refresh cycle (which is really a bit hacky feeling if you look at refresh in the review task editor code you&apos;ll see what I mean)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266371</commentid>
    <comment_count>7</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-05-31 13:08:19 -0400</bug_when>
    <thetext>Miles, stepping way, way back, because I know very little about how the connector works, could you explain, at a high level, the reasons for having such a complex arrangement? Why not have all needed information (other than patch set contents) in the task data, like any other connector, and fetch the patch set contents on demand? What is special about Gerrit that requires this complexity in the connector, or what are we trying to achieve with it?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266403</commentid>
    <comment_count>8</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-31 13:57:39 -0400</bug_when>
    <thetext>(In reply to comment #7)
&gt; Miles, stepping way, way back, because I know very little about how the
&gt; connector works, could you explain, at a high level, the reasons for having such
&gt; a complex arrangement? Why not have all needed information (other than patch set
&gt; contents) in the task data, like any other connector, and fetch the patch set
&gt; contents on demand? What is special about Gerrit that requires this complexity
&gt; in the connector, or what are we trying to achieve with it?

It&apos;s a good question...

The issue is that we want/need to persist the patch sets as well. But even if we didn&apos;t, we&apos;d need a notification mechanism for that, we&apos;d have to put them in a model, and the communication would have to be asyncronous. It also has to work across views, so we need that notification there. The Gerrit API itself is also a strange mix of async and direct communication. And I think persistence is really valuable as it saves a tremendous amount of time for users who are reopening exsiting tasks -- but whether we persist it or not isn&apos;t the main issue anyway. Also, I think a decision was made that we didn&apos;t want to put the model handling within the Task Data side, but I can&apos;t remember offhand what the reasoning was there. It may have been that we don&apos;t have access to everything we need at that point. I can take another look at that -- though I&apos;d hate to tear a bunch of stuff out at this late date it would .</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266424</commentid>
    <comment_count>9</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-05-31 14:38:57 -0400</bug_when>
    <thetext>We would also like to have an offline cache for task attachments. I don&apos;t think persisting the patch sets should require this complexity. Is it just an unavoidable result of a complicated Gerrit API, or is it a result of some design decisions we&apos;ve made, e.g. using EMF?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266443</commentid>
    <comment_count>10</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-05-31 15:32:25 -0400</bug_when>
    <thetext>I was really unclear above. Let me try again. The first issue is that we&apos;d like to persist the patch sets (but we don&apos;t have to) -- the real issue is that we need to load the patch sets lazily, on user demand. And it&apos;s not like double-clicking on an attachment, it&apos;s much more tightly integrated into the user interactions -- sometimes you need to open them automatically (like the last one) sometimes you don&apos;t, sometimes it can fail (if you don&apos;t have a connection or if the patch set is missing, see bug 399434) and these all have to be coordinated across multiple reviews.

It is *not* a result of using EMF -- I can state that categorically -- any backing store would have these same complexities. Note that we&apos;re dealing essentially with both server side pull and server side push. So yes, the compleity of the Gerrit API, the complexity of the Mylyn Task Editor API and task life-cycle, added to this the new Rmeote API, they&apos;re all implicated.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266495</commentid>
    <comment_count>11</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-05-31 17:24:13 -0400</bug_when>
    <thetext>I see. Why does it have to be coordinated across multiple reviews?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266975</commentid>
    <comment_count>12</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-03 09:22:13 -0400</bug_when>
    <thetext>(In reply to comment #6)
&gt; (In reply to comment #5)
&gt; &gt; Is the review model refresh always driven by the task editor or does it hook
&gt; &gt; into the task refresh as well?
&gt; 
&gt; No, it is only manually refreshed through the task editor (the user can initiate
&gt; this from Review explorer as well). My understanding was that this was the
&gt; expected approach, i.e. the task framework should only refresh large sets of
&gt; data when the user explicitly requests.

Does that mean users have to press the refresh button in order to get the changes for a review regardless of task synchronizations (happening in the background)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2266981</commentid>
    <comment_count>13</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-03 09:27:25 -0400</bug_when>
    <thetext>(In reply to comment #6)
&gt; Well, the issue is that we don&apos;t know which buttons to provide. For example, you
&gt; can submit some patch sets only if you have credentials.. And if you don&apos;t have
&gt; a remote connection at all, it doesn&apos;t seem to make sense to do that. 

You would need a notion of an &quot;offline&quot; status in order to implement disabling/hiding of controls based on server availability but Mylyn does not have that by design. It seems strange to me to hide buttons based on connectivity at the time of opening the editor. User may reconnect later and wish to submit without having to reopen the editor. Generally, part of the value of caching data locally is that I don&apos;t have to waiting for a repository connection before triggering an interaction but that seems broken in the current review editor.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267187</commentid>
    <comment_count>14</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 13:06:12 -0400</bug_when>
    <thetext>(In reply to comment #12)
&gt; Does that mean users have to press the refresh button in order to get the
&gt; changes for a review regardless of task synchronizations (happening in the
&gt; background)?

Yes, which feels kind of weird and sub-optimal to me given that we can easily get that data, but seems consistent with the way other connectors handle &quot;non-partial&quot; data.

(In reply to comment #13)
&gt; (In reply to comment #6)
&gt; &gt; Well, the issue is that we don&apos;t know which buttons to provide. For example,  you
&gt; &gt; can submit some patch sets only if you have credentials.. And if you don&apos;t  have
&gt; &gt; a remote connection at all, it doesn&apos;t seem to make sense to do that.
&gt; 
&gt; You would need a notion of an &quot;offline&quot; status in order to implement
&gt; disabling/hiding of controls based on server availability but Mylyn does not
&gt; have that by design. It seems strange to me to hide buttons based on
&gt; connectivity at the time of opening the editor. User may reconnect later and
&gt; wish to submit without having to reopen the editor. Generally, part of the value

Yes, but then how do you distinguish between the case where you aren&apos;t showing a button because you&apos;re offline, and you&apos;re not showing a button because it isn&apos;t an available function? If I don&apos;t have a connection to the remote, there is no way to tell whether I should or should not be displaying a button! The only other approach I can think of is to create *all* buttons, including ones that the user will never be able to use, and then enable them when connectivity is restored. But as we can&apos;t really listen for a &quot;connection restored&quot; event, that&apos;s going to require the user to refresh or reopen anyway. Or, you could simply show all buttons and neable them all, but then you&apos;re not providing any cueing for the user about what it makes sense to do. 

This seems to be another case where you think there should be an easy answer but there isn&apos;t and perhaps our replication of the web UI is forcing us to mimic solutions that are much more complex than they need to be. This issue never comes up in a Web UI, because you never have the problem of having to support offline access!

&gt; of caching data locally is that I don&apos;t have to waiting for a repository
&gt; connection before triggering an interaction but that seems broken in the current
&gt; review editor.

Yeah, I see your point but see above; I&apos;m not sure even from a conceptual POV how to improve this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267235</commentid>
    <comment_count>15</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 13:52:04 -0400</bug_when>
    <thetext>In trying to come up with a simplification scenario, I&apos;ve had trouble designing something that makes sense, but this is the closest I can come..

1) Create all buttons regardless of whether users can use them or we have connectivity.
2) In case where we *don&apos;t* have access, enable them all? (Seems backward, but see Steffen&apos;s note above about not wanting to force user to refresh when connectivity is restored.) If user tries to connect without having a remote, we simply fail with a no remote connection error. ( We could try to get a remote after the user clicks Submit or whatever.. But we won&apos;t really be able to do that since we don&apos;t even know what to present to user w/o a connection in many cases and in any case it will be asynchronous, which introduces new complexities.)
3) In cases where we do have access, selectively enable buttons based on user actions.
4. When user refreshes the entire view, the button enablement state will also be refreshed without needing any update logic (I think, since the controls in this case will be rebuilt.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267261</commentid>
    <comment_count>16</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-06-03 14:30:07 -0400</bug_when>
    <thetext>In the task editor, the submit button is enabled reagardless of connectivity. If there is no connection when the user presses submit, or if the task can&apos;t be submitted because of incoming changes or workflow rules, the user gets an error. Should we follow the same principles for the review editor? I.e. create the buttons which make sense based on the state of the review when the editor is opened/refreshed, and if the state changes in the background, we detect an incoming when the user clicks the button and force them to refresh.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267269</commentid>
    <comment_count>17</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 14:42:04 -0400</bug_when>
    <thetext>(In reply to comment #16)
&gt; In the task editor, the submit button is enabled reagardless of connectivity. If
&gt; there is no connection when the user presses submit, or if the task can&apos;t be
&gt; submitted because of incoming changes or workflow rules, the user gets an error.
&gt; Should we follow the same principles for the review editor? I.e. create the
&gt; buttons which make sense based on the state of the review when the editor is
&gt; opened/refreshed, and if the state changes in the background, we detect an
&gt; incoming when the user clicks the button and force them to refresh.

So that works in some cases, but not in others. We may not even know the proper state until we actually have the remote data. But I&apos;m just going through all of the UI factories. Perhaps we can know this from the review data, which would be a great simplifying assumption, but might also require us to collect more information in the model, and I don&apos;t think we should make those kind of changes at this point.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267274</commentid>
    <comment_count>18</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 14:50:24 -0400</bug_when>
    <thetext>Here are two cases:

For Rebase, we need to check the change detail for whether a rebase can occur. There we&apos;re getting the information from the change. I have no idea what the rules are there, and I don&apos;t think we want an actual value in the model for this (?) as it seems that it could change based on external circumstances. I mean it seems that you can only rebase the latest change, but I&apos;m not sure and wouldn&apos;t want to make that assumption.

		GerritChange change = getChange();
		return change != null &amp;&amp; change.getChangeDetail() != null
				&amp;&amp; change.getChangeDetail().canRebase();
				
We have the same issue with restore:

		GerritChange change = getChange();
		return change != null &amp;&amp; change.getChangeDetail() != null
				&amp;&amp; change.getChangeDetail().canRebase();
				
OTOH, for submit, we *may* be able to discover that from the model, as we already are obtaining approvals and placing them in the model:

	public boolean isExecutable() {
		ChangeDetailX changeDetail = getChange().getChangeDetail();
		if (changeDetail != null) {
			if (changeDetail.getCurrentActions() != null) {
				return changeDetail.getCurrentActions().contains(ApprovalCategory.SUBMIT);
			} else if (changeDetail instanceof ChangeDetailX) {
				// Gerrit 2.2 and later
				return changeDetail.canSubmit();
			}
		}
		return false;
	}
	
But that&apos;s iffy.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267281</commentid>
    <comment_count>19</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 15:06:37 -0400</bug_when>
    <thetext>One other example of how the complexities exist. Note that because of the asynchronous nature of the call, we can&apos;t reliably determine what to do. Consider what happens when a user first opens a review.

1. In the case where we don&apos;t have a remote, we&apos;d want to build the entire form with all of the patch set sections and so on, creating the buttons and setting the actual contents from the model when the user expands.
2. In the case where we do have a remote, we want to first build the entire form. *But*, we also request an update, and fill in the details when that update arrives.

Note that we can&apos;t do that at Review load time for the patch set contents, because those will have new comments that come from PathSetContents. But we can do that for the buttons, because the PatchSetDetails have all of the information we need to do that. So we&apos;re faced with a situation where we have to create the buttons, and then recreate them again as soon as the update occurs.

Here&apos;s the problem: We don&apos;t know if we have case 1 or 2 when we build the form!  (We don&apos;t have the Remote Change the first time around.) This means that we cannot wait for the Review load to complete before we go on to create the buttons. Therefore, the first time we build the buttons, we can&apos;t make a good decision. We have to have a separate notification that occurs. But that notification comes from the Review model, *not* the patch set. So we have a situation where you actually have two separate async calls affecting the same controls! (Note that the simplifying assumption above doesn&apos;t really fix the complexity, it only makes it less error prone, as we wtill want to update button enablement when the review updates.)

Now, given how long the above has taken to explain, imagine how many things can go wrong with this picture. ;D My feeling is that we have to reduce the complexity of this. It&apos;s just too delicate. But, let&apos;s say we don&apos;t update anything at all, we just rely on the current model state when the user opens the editor. Well, that means that for example, we&apos;re not doing things like updating to show the current comments, which just seems wrong to me.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267297</commentid>
    <comment_count>20</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 15:41:24 -0400</bug_when>
    <thetext>Question: Is it the case that you can only abandon and rebase (and perhaps submit) the latest change? That is are these really review level actions as opposed to patch set level? If that&apos;s the case that would make a *great* simplifying assumption, and we could even move those buttons to the review section. Since everything else would be patch set specific, that would mean that we could simply build all of those buttons at run time and leave them. We could even do something nice like move them to the section header (I know, not for 2.0 :)).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267328</commentid>
    <comment_count>21</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-03 16:32:04 -0400</bug_when>
    <thetext>(In reply to comment #14)
&gt; (In reply to comment #12)
&gt; &gt; Does that mean users have to press the refresh button in order to get the
&gt; &gt; changes for a review regardless of task synchronizations (happening in the
&gt; &gt; background)?
&gt; 
&gt; Yes, which feels kind of weird and sub-optimal to me given that we can easily
&gt; get that data, but seems consistent with the way other connectors handle
&gt; &quot;non-partial&quot; data.

No, that is not correct. Other connectors retrieve partial data when the query runs and retrieve the full data in a separate task synchronization that runs for all tasks that were identified as having changed. No properly implemented connector that I know of *requires* explicit user interaction to 
fully synchronize tasks. The current Gerrit connector refresh design seems very broken to me.

&gt; This seems to be another case where you think there should be an easy answer but
&gt; there isn&apos;t and perhaps our replication of the web UI is forcing us to mimic
&gt; solutions that are much more complex than they need to be. 

I don&apos;t get why this is complicated. It&apos;s equivalent to the workflow state in the task editor: The valid operations are cached in task data. This was also the case for the patch set workflow in 1.0. I don&apos;t see any reason why this couldn&apos;t be cached in the reviews model in the same way.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267340</commentid>
    <comment_count>22</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-03 16:48:37 -0400</bug_when>
    <thetext>Ignore that last Q.. these are in fact all patch set specific according to API, even though Abandon is an action that makes sense only for the review as a whole.

 (In reply to comment #21)
&gt; No, that is not correct. Other connectors retrieve partial data when the query
&gt; runs and retrieve the full data in a separate task synchronization that runs for
&gt; all tasks that were identified as having changed. No properly implemented
&gt; connector that I know of *requires* explicit user interaction to
&gt; fully synchronize tasks. The current Gerrit connector refresh design seems very
&gt; broken to me.

My mistake -- I didn&apos;t think that through properly. I think this way because there are so many occasions where I do have to refresh task content manually, because a task editor is already open. Note for the Gerrit Connector though, somewhere along the line I *believe* that we did make the decision that it wasn&apos;t appropriate to grab the model for every open review task, IIRC because we weren&apos;t storing the data not in TaskData but in the model persistence layer. But I&apos;m more than happy to do it this way instead. However..that&apos;s almost a moot issue, as I know that we decided that we would not do this for patch sets, because of the number of patch set access we would need to make. Didn&apos;t we decide to do this in background, and isn&apos;t that consistent w/ original behaviour?

&gt; &gt; This seems to be another case where you think there should be an easy answer
&gt; but
&gt; &gt; there isn&apos;t and perhaps our replication of the web UI is forcing us to mimic
&gt; &gt; solutions that are much more complex than they need to be.
&gt; 
&gt; I don&apos;t get why this is complicated. It&apos;s equivalent to the workflow state in
&gt; the task editor: The valid operations are cached in task data. 

But they can&apos;t be in this case, because they&apos;re patch set specific. The 1.0 implementation was determining this at build time. The difference is that the 1.1 connector was using the neat trick of reconstitituing the Gerrit objects from the task data. That&apos;s something that for better or worse we aren&apos;t going to be doing anymore.

&gt; This was also the
&gt; case for the patch set workflow in 1.0. I don&apos;t see any reason why this couldn&apos;t
&gt; be cached in the reviews model in the same way.

Well, all of these issues arose essentially because I thought that we couldn&apos;t make this assumption and that Patch Set contents have to be updated based on explicit user interactions. Given that, that drives how we obtain Patch Sets, but design wise it also (quite arguably) called for a more model driven approach to the updates from remote in general, as otherwise we&apos;re maintaining two separate data/remote change notification approaches. But it turns out we&apos;re having to do that anyway, because we need to work with Editor life-cycle. Again, I see the issue as not that either approach is broken -- they both work very well in isolation -- but that they don&apos;t play well together.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267381</commentid>
    <comment_count>23</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-06-03 18:31:16 -0400</bug_when>
    <thetext>I think you can rebase any change, even though the web UI only shows the rebase button on the latest. But one can already get into a state where buttons are enabled that don&apos;t work, e.g. when trying to publish comments on what is no longer the latest patch set, you get an error that the change is closed.

(In reply to comment #19)
&gt; complexity of this. It&apos;s just too delicate. But, let&apos;s say we don&apos;t update
&gt; anything at all, we just rely on the current model state when the user opens the
&gt; editor. Well, that means that for example, we&apos;re not doing things like updating
&gt; to show the current comments, which just seems wrong to me.

When opening the task editor, a background sync happens and the user is prompted to refresh the editor if anything has changed. Why wouldn&apos;t we do the same thing for Gerrit reviews, with the background sync pulling down whatever info is needed to display the right buttons and so on?

I could see an argument that Gerrit reviews change so often that we want some more realtime sync to happen, but that seems like it should be addressed on the framework level rather than in this specific connector, e.g. by supporting &quot;progressive&quot; rendering of the task editor, where sections are created one at a time as the information is available, and allowing the editor to be refreshed without blowing away the state of the controls (expansion, etc.). The Gerrit connector seems to have an awkward mixture of this and the traditional approach.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2267879</commentid>
    <comment_count>24</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-04 12:42:30 -0400</bug_when>
    <thetext>(In reply to comment #23)
&gt; I think you can rebase any change, even though the web UI only shows the rebase
&gt; button on the latest. But one can already get into a state where buttons are
&gt; enabled that don&apos;t work, e.g. when trying to publish comments on what is no
&gt; longer the latest patch set, you get an error that the change is closed.

True enough. It would be nice to provide some cueing though so users don&apos;t think they can do all of these things and they can&apos;t. As a first-order though, I think we should just create them and handle whatever comes up on the backend.

&gt; (In reply to comment #19)
&gt; When opening the task editor, a background sync happens and the user is prompted
&gt; to refresh the editor if anything has changed. Why wouldn&apos;t we do the same thing
&gt; for Gerrit reviews, with the background sync pulling down whatever info is
&gt; needed to display the right buttons and so on?

That&apos;s exactly what we do, except that the model update isn&apos;t happening in the background Sync. This seems to work reasonably well.

I think I may have some good approaches to simplifying the update issues after taking a fresh look yesterday.

&gt; I could see an argument that Gerrit reviews change so often that we want some
&gt; more realtime sync to happen, but that seems like it should be addressed on the
&gt; framework level rather than in this specific connector, e.g. by supporting
&gt; &quot;progressive&quot; rendering of the task editor, where sections are created one at a
&gt; time as the information is available, and allowing the editor to be refreshed
&gt; without blowing away the state of the controls (expansion, etc.). The Gerrit
&gt; connector seems to have an awkward mixture of this and the traditional approach.

Yeah, it is incredibly awkward, but the whole point of this project has been as a pilot for a more model-based / progressive approach but not to actually implement that for Mylyn tasks as a whole. Framework level changes were really way out of scope.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2268032</commentid>
    <comment_count>25</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-04 17:06:27 -0400</bug_when>
    <thetext>Alright, thanks Steffen and Sam. Your comments have been extremely helpful in clarifying things. So I&apos;ve been experimenting with moving the update life-cycle into the Task Data update mechanism proper and so far so good, but I am concerned about making such a significant change in how things are set up. I&apos;m hoping to have a preliminary review up later today.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269538</commentid>
    <comment_count>26</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-06 16:58:01 -0400</bug_when>
    <thetext>Comments about https://git.eclipse.org/r/#/c/13154/7:

* The Restore button is shown even though Restore is not a valid action
* When Abandon or Restore are used and the dialog is cancelled it shows again, it seems that all actions are executed twice
* If I restore an abandoned review the editor refreshes but the status is still ABANDONED (the web ui shows it as restored)
* When a review changes and I refresh the query and incoming link is shown. Pressing the link has no effect. I have to reopen the editor to see the changes.
* If I change the URL of the Gerrit repository to something invalid, restart and refresh the task all data disappears from the editor and task list for the task. No error is displayed but several exceptions are logged.
* When I manually refreshed the task the job never finished. It was trying to fetch 5 patch sets while only 4 completed. It was looping forever around GerritTaskDataHandler:151. Canceling didn&apos;t have any effect.

This was the result of 20 min. of testing. Miles, how do you suggest we proceed? It doesn&apos;t even look like the automated tests are passing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269546</commentid>
    <comment_count>27</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-06 17:19:01 -0400</bug_when>
    <thetext>Steffen, that was just a WIP push to keep things relatvily up to date. I&apos;ve changed the way we&apos;re doing everything and I wanted you to be able to see where that&apos;s headed in code. I&apos;m going to be pushing a set of changes in next hour or two that should be a lot closer to where we need to be functionally.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269556</commentid>
    <comment_count>28</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-06 17:37:39 -0400</bug_when>
    <thetext>https://git.eclipse.org/r/#/c/13154/8 

This one is a much more solid cut at task handler approach -- which in general seems to work much better -- but expect significant issues still. I&apos;m not sure why the Sync tests are failing -- they pass when I run them directly, e.g. launching a local JUnit Test on gerritSynchronizationTest, but fail when I launch AllGerritTests with -Dorg.eclipse.mylyn.tests.all=true.

If we&apos;re able to get this working reliably, I&apos;m going to look into simplifying the code -- perhaps ripping out the RemoteEmfClient stuff -- then reverting  https://git.eclipse.org/r/#/c/12229/ and submitting it in more granular reviews.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269588</commentid>
    <comment_count>29</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-06 20:36:48 -0400</bug_when>
    <thetext>https://git.eclipse.org/r/#/c/13154/9 is much more functional. Review Explorer is working again.

Right now, I&apos;m working on backing out the changes in commit 85c80d97bc4e2f9bcc6df383eceaf56ede459d0c. This way we can replay with more bite sized changes.

See details below:

Author: Miles Parker &lt;milesparker@gmail.com&gt; 2013-05-01 20:33:22
Committer: Miles Parker &lt;milesparker@gmail.com&gt; 2013-05-21 20:52:51
Parent: d7bec6281ddafafc56a3b2e366a2d7232bfd84a8 (395059: update test repositories to Gerrit 2.5.4, 2.6-rc3, 2.7-rc1)
Child: 96a0e79969a85b6593c67b5bf78d70c740c3d6f0 (408737: [regression] RuntimeException (when opening multiple reviews?))
Branches: bug389944PatchSetCaching, bug409343LifeCycle, bugg409343NoProxies, master, rewind, origin/e_4_3_m_3_9_x, origin/master

394020: [model] Persist Review models across workbench..

	Adds Edit Factory Supporting Persistence
	Enriches Consumer and Observers to support complex remote requests
	Refactors Editors, Explorer and UI factories to implement above
	Ensure that model changes don&apos;t happen off of model thread
	Adds testing coverage</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269590</commentid>
    <comment_count>30</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-06 20:37:31 -0400</bug_when>
    <thetext>Forgot the reversion review link: https://git.eclipse.org/r/#/c/13631/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269596</commentid>
    <comment_count>31</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-06-06 21:42:53 -0400</bug_when>
    <thetext>I tried https://git.eclipse.org/r/#/c/13154/9:

* Rebase button is disabled for all patch sets
* Comment section kept collapsing by itself - can&apos;t reproduce this now
* Lots of errors about &quot;Parent and local keys must be specified&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269597</commentid>
    <comment_count>32</comment_count>
    <who name="Sam Davis">sam.davis</who>
    <bug_when>2013-06-06 21:43:55 -0400</bug_when>
    <thetext>It also seemed like this forced a refresh of all my reviews.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269599</commentid>
    <comment_count>33</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-06 21:55:49 -0400</bug_when>
    <thetext>
&gt; I tried https://git.eclipse.org/r/#/c/13154/9:
&gt; 
&gt; * Rebase button is disabled for all patch sets
&gt; * Comment section kept collapsing by itself - can&apos;t reproduce this now
&gt; * Lots of errors about &quot;Parent and local keys must be specified&quot;

Okay, hmm.. I&apos;m not seeing any of these things.

Please:

1. Go up against Eclipse Bugzilla Reviews (Just so we have a baseline to compare) -- I&apos;m using mylyn/org.eclipse.mylyn.context.mft or reviews because they&apos;re relatively small sets.
1. Delete current queries and tasks (after they got to Uncategorized) 
2. Exit
3. Do: rm -rf {workspace_location}/.metadata/.mylyn/model
4. Restart</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2269607</commentid>
    <comment_count>34</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-07 00:26:13 -0400</bug_when>
    <thetext>I just tried all of this in Windows, still unable to reproduce. Hopefully the steps above will sort it out.

(In reply to comment #32)
&gt; It also seemed like this forced a refresh of all my reviews.

Yes, the first time you open the reviews, you have to manually refresh. Should be able to fix that issues easily.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270139</commentid>
    <comment_count>35</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-07 17:56:15 -0400</bug_when>
    <thetext>I&apos;m stuck on the GerritSyncronizationTests. These are running fine stand-alone, but break when they&apos;re run as AllGerritTests w/ -Dorg.eclipse.mylyn.tests.all=true. I think there is an exception that might be getting buried here. When I try to create the client, I get:

Thread [Worker-0] (Suspended (exception NullPointerException))	
	ConcurrentHashMap&lt;K,V&gt;.get(Object) line: 922	
	GerritConnector.loadConfiguration(TaskRepository) line: 346	
	GerritConnector.createReviewClient(TaskRepository, boolean) line: 327	

These are the lines:

	protected GerritConfiguration loadConfiguration(TaskRepository repository) {
		GerritConfiguration configuration = configurationCache.get(repository);
		
I think there is some expectation of the harness that with these changes I&apos;m not meeting.

Steffen, any ideas about what might be going on here?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270583</commentid>
    <comment_count>36</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-10 10:49:34 -0400</bug_when>
    <thetext>I tested with patch set 14 and I&apos;m still missing buttons when expanding older patch sets. Sometimes they appear but most often not.

When I added a patch set through the console the refresh link on top of the task editor that appeared didn&apos;t work (nothing seemed to happen). Surprisingly the new patch set showed up in the Compare With drop down though but resulting in this exception when selected:

!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.mylyn.internal.gerrit.ui.factories.CompareWithUiFactory.execute(CompareWithUiFactory.java:151)
	at org.eclipse.mylyn.internal.gerrit.ui.factories.CompareWithUiFactory$3$1.widgetSelected(CompareWithUiFactory.java:132)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:240)
	
	
After adding a comment and then using Compare with Base I got this exception:

!MESSAGE An internal error occurred during: &quot;Retrieving Compare Patch Set 1 with Base&quot;.
!STACK 0
java.lang.NullPointerException
	at org.eclipse.mylyn.internal.gerrit.core.remote.PatchSetContentRemoteFactory.pull(PatchSetContentRemoteFactory.java:80)
	at org.eclipse.mylyn.internal.gerrit.core.remote.PatchSetContentCompareRemoteFactory.pull(PatchSetContentCompareRemoteFactory.java:38)
	at org.eclipse.mylyn.internal.gerrit.core.remote.PatchSetContentCompareRemoteFactory.pull(PatchSetContentCompareRemoteFactory.java:1)
	at org.eclipse.mylyn.reviews.core.spi.remote.emf.RemoteEmfConsumer.pull(RemoteEmfConsumer.java:164)
	at org.eclipse.mylyn.reviews.core.spi.remote.JobRemoteService$1.run(JobRemoteService.java:60)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)
	
Initially when I tried to the connector everything failed with an &quot;Problem performing query: OK&quot; or &quot;Problem updating repository: OK&quot;. I traced it to the login which was returning HTTP OK (200). Not sure if that&apos;s related to the changes or a problem that has been around for a while. A restart eventually fixed it.

I noticed that when I added a comment through the compare editor the comment count in the patch set header was updated (e.g. said 2 Comments) which is a bit confusing since the new comment was only a draft at that point. The decorations in the file list were not refreshed, only when the editor was reopened. It&apos;s minor but something that we should track to fix it later.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270589</commentid>
    <comment_count>37</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-10 10:56:37 -0400</bug_when>
    <thetext>(In reply to comment #35)
&gt; I&apos;m stuck on the GerritSyncronizationTests. These are running fine stand-alone,
&gt; but break when they&apos;re run as AllGerritTests w/
&gt; -Dorg.eclipse.mylyn.tests.all=true. I think there is an exception that might be
&gt; getting buried here. 

If I run AllGerritTests I get this dumped to the console (haven&apos;t investigated further whether it&apos;s related to the test failures):

!ENTRY org.eclipse.mylyn.tasks.core[2013-06-10T4-50-33] Status ERROR: org.eclipse.mylyn.tasks.core code=0 Synchronization failed java.lang.NullPointerException, Exception:
java.lang.NullPointerException
	at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:768)
	at org.eclipse.mylyn.internal.gerrit.core.GerritConnector.loadConfiguration(GerritConnector.java:346)
	at org.eclipse.mylyn.internal.gerrit.core.GerritConnector.createReviewClient(GerritConnector.java:327)
	at org.eclipse.mylyn.reviews.core.spi.ReviewsConnector.getReviewClient(ReviewsConnector.java:30)
	at org.eclipse.mylyn.internal.gerrit.core.GerritConnector.getClient(GerritConnector.java:144)
	at org.eclipse.mylyn.internal.gerrit.core.GerritConnector.hasTaskChanged(GerritConnector.java:223)
	at org.eclipse.mylyn.internal.tasks.core.data.TaskDataManager.putUpdatedTaskData(TaskDataManager.java:195)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.updateFromTaskData(SynchronizeTasksJob.java:312)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.synchronizeTask(SynchronizeTasksJob.java:247)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.runInternal(SynchronizeTasksJob.java:218)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.run(SynchronizeTasksJob.java:153)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.run(SynchronizeTasksJob.java:135)
	at org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeQueriesJob.run(SynchronizeQueriesJob.java:225)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270673</commentid>
    <comment_count>38</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 13:09:01 -0400</bug_when>
    <thetext>Please note btw that the patch sets I&apos;ll be updating while diagnosing the testing issue aren&apos;t necessarily the best current implementation. In some cases I&apos;ve modified the code in subtle ways to try to determine what is causing issues in the test configuration. I&apos;ve been noting that in commit comment when I post an update (&quot;DIAGNOSE TESTING ISSUES&quot;).

(In reply to comment #36)
&gt; I tested with patch set 14 and I&apos;m still missing buttons when expanding older
&gt; patch sets. Sometimes they appear but most often not.

Yep, I&apos;m seeing that as well.

&gt; When I added a patch set through the console the refresh link on top of the task
&gt; editor that appeared didn&apos;t work (nothing seemed to happen). 

I&apos;ll take a look. I&apos;m not actually sure btw what policy to use to grab patch set details in the Task Update. I&apos;d actually wrtitten code that could grab all patch sets, but I&apos;m not sure if that&apos;s a good idea. It can take a long time to get a single review, and users of often won&apos;t be interested in that. At the same time, it did sort of seem to make sense to grab the last one retrieved, and perhaps to update all of those patch sets that had *previously* been requested by the user. For now, I&apos;ve removed all of the patch set update code as I try to simplify things to test. 

&gt; Surprisingly the
&gt; new patch set showed up in the Compare With drop down though but resulting in
&gt; this exception when selected:

&gt; !MESSAGE Unhandled event loop exception
&gt; !STACK 0
&gt; java.lang.NullPointerException
&gt; at
&gt; org.eclipse.mylyn.internal.gerrit.ui.factories.CompareWithUiFactory.execute(CompareWithUiFactory.java:151)

Right, that makes sense, as we don&apos;t have the patch set there yet. I&apos;m going to look at some further simplification of this code.

&gt; I noticed that when I added a comment through the compare editor the comment
&gt; count in the patch set header was updated (e.g. said 2 Comments) which is a bit
&gt; confusing since the new comment was only a draft at that point. The decorations
&gt; in the file list were not refreshed, only when the editor was reopened. It&apos;s
&gt; minor but something that we should track to fix it later.

Ok, I&apos;ll keep that one in mind.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270675</commentid>
    <comment_count>39</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 13:15:35 -0400</bug_when>
    <thetext>(In reply to comment #37)
&gt; If I run AllGerritTests I get this dumped to the console (haven&apos;t investigated
&gt; further whether it&apos;s related to the test failures):

Yeah, I&apos;ve been seeing this too. What the heck is going on here? The code calling order is basically exactly the same. I&apos;ll try to isolate the change I made here from the rest of the code.

&gt; 
&gt; !ENTRY org.eclipse.mylyn.tasks.core[2013-06-10T4-50-33] Status ERROR:
&gt; org.eclipse.mylyn.tasks.core code=0 Synchronization failed
&gt; java.lang.NullPointerException, Exception:
&gt; java.lang.NullPointerException
&gt; at java.util.concurrent.ConcurrentHashMap.get(ConcurrentHashMap.java:768)
&gt; at
&gt; org.eclipse.mylyn.internal.gerrit.core.GerritConnector.loadConfiguration(GerritConnector.java:346)
&gt; at
&gt; org.eclipse.mylyn.internal.gerrit.core.GerritConnector.createReviewClient(GerritConnector.java:327)
&gt; at
&gt; org.eclipse.mylyn.reviews.core.spi.ReviewsConnector.getReviewClient(ReviewsConnector.java:30)
&gt; at
&gt; org.eclipse.mylyn.internal.gerrit.core.GerritConnector.getClient(GerritConnector.java:144)
&gt; at
&gt; org.eclipse.mylyn.internal.gerrit.core.GerritConnector.hasTaskChanged(GerritConnector.java:223)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.data.TaskDataManager.putUpdatedTaskData(TaskDataManager.java:195)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.updateFromTaskData(SynchronizeTasksJob.java:312)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.synchronizeTask(SynchronizeTasksJob.java:247)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.runInternal(SynchronizeTasksJob.java:218)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.run(SynchronizeTasksJob.java:153)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeTasksJob.run(SynchronizeTasksJob.java:135)
&gt; at
&gt; org.eclipse.mylyn.internal.tasks.core.sync.SynchronizeQueriesJob.run(SynchronizeQueriesJob.java:225)
&gt; at org.eclipse.core.internal.jobs.Worker.run(Worker.java:54)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270699</commentid>
    <comment_count>40</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-10 13:54:53 -0400</bug_when>
    <thetext>The reason tests are failing is that task synchronization now relies on stuff being executed on the UI thread:

Thread [Worker-5] (Suspended)	
	waiting for: Semaphore  (id=160)	
	Object.wait(long) line: not available [native method]	
	Semaphore.acquire(long) line: 43	
	UISynchronizer.syncExec(Runnable) line: 168	
	Display.syncExec(Runnable) line: 4613	
	RemoteUiService.modelExec(Runnable, boolean) line: 35	
	GerritRemoteFactoryProvider(AbstractRemoteFactoryProvider).modelExec(Runnable, boolean) line: 28	
	GerritRemoteFactoryProvider(AbstractRemoteEditFactoryProvider&lt;ERootObject,EChildObject&gt;).modelExec(Runnable, boolean) line: 315	
	GerritRemoteFactoryProvider.pullUser(IRepository, AccountInfoCache, Account$Id, IProgressMonitor) line: 72	
	GerritReviewRemoteFactory.pull(IRepository, String, IProgressMonitor) line: 91	
	GerritReviewRemoteFactory.pull(EObject, Object, IProgressMonitor) line: 1	
	RemoteEmfConsumer&lt;EParentObjectType,EObjectType,LocalKeyType,RemoteType,RemoteKeyType,ObjectCurrentType&gt;.pull(boolean, IProgressMonitor) line: 164	
	RemoteUiService(JobRemoteService).retrieve(AbstractRemoteConsumer, boolean) line: 93	
	RemoteEmfConsumer&lt;EParentObjectType,EObjectType,LocalKeyType,RemoteType,RemoteKeyType,ObjectCurrentType&gt;.retrieve(boolean) line: 289	
	GerritTaskDataHandler.updateModelData(TaskRepository, TaskData, ReviewObserver, IProgressMonitor) line: 146	
	GerritTaskDataHandler.getTaskData(TaskRepository, String, IProgressMonitor) line: 114	
	GerritConnector.getTaskData(TaskRepository, String, IProgressMonitor) line: 160	
	SynchronizeTasksJob.synchronizeTask(IProgressMonitor, ITask) line: 245	
	SynchronizeTasksJob.runInternal(Set&lt;ITask&gt;, IProgressMonitor) line: 218	
	SynchronizeTasksJob.run(Set&lt;ITask&gt;, IProgressMonitor) line: 153	
	SynchronizeTasksJob.run(IProgressMonitor) line: 129	
	Worker.run() line: 54	

This doesn&apos;t work for the current test design (since the test runs on the UI thread hence the event loop isn&apos;t spun and the executables run at the &quot;wrong&quot; time).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270705</commentid>
    <comment_count>41</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 14:02:56 -0400</bug_when>
    <thetext>Yes, that was one of the things I I was going to ask you about that. I had thought about changing this in any case, but it does introduce new (different) risks. Is this an issue with testing or with framework requirements themselves? In other words, should all well-designed connector implementations never use the UI thread, or is this just an incidental assumption of the framework?

I&apos;ve isolated another case of the testing issues to the following review though. I&apos;m not sure this is the same UI issue. 

https://git.eclipse.org/r/#/c/13710/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270708</commentid>
    <comment_count>42</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 14:07:22 -0400</bug_when>
    <thetext>(In reply to comment #40)
&gt; This doesn&apos;t work for the current test design (since the test runs on the UI
&gt; thread hence the event loop isn&apos;t spun and the executables run at the &quot;wrong&quot;
&gt; time).

And makes sense, because it explains why they *do* work when launched from a local unit test.

I&apos;m going to look at moving these changes to a non-UI thread. It would be cleaner on some sense, but then we have to be really careful about isolating these changes against changes from the editor, which was one of the complexities I was hoping to avoid with this design. I may be able to make a clean separation based on function here though.

Question: When a user asks for a refresh, is the editor completely locked down during the refresh?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270723</commentid>
    <comment_count>43</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-10 14:47:29 -0400</bug_when>
    <thetext>(In reply to comment #42)
&gt; Question: When a user asks for a refresh, is the editor completely locked down
&gt; during the refresh?

The controls are disabled but you can do things like closing that editor instance and reopening it (which gets you an editor with enabled controls). Users can also trigger task synchronizations directly from the task list at any time.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270733</commentid>
    <comment_count>44</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 15:06:36 -0400</bug_when>
    <thetext>(In reply to comment #43)
&gt; (In reply to comment #42)
&gt; &gt; Question: When a user asks for a refresh, is the editor completely locked down
&gt; &gt; during the refresh?
&gt; 
&gt; The controls are disabled but you can do things like closing that editor
&gt; instance and reopening it (which gets you an editor with enabled controls).
&gt; Users can also trigger task synchronizations directly from the task list at any
&gt; time.

Yeah, it&apos;s really not something to rely on for model access control. I think the basic policy of forcing discrete changes to occur on UI is still by far the most robust approach. Even thought there isn&apos;t that much that users can change, and we could probably work out a decent isolation if needed to, that would require all UI elements to check out and notify for access against Task Sync, and there is just a lot of stuff to maintain there that isn&apos;t really neccesary if we take the &quot;get in and get out quickly&quot; approach to model updating.

Note that because all of the reviews are actually seperate file resources, we could imagine a future scenario where we might support some kind of bulk update locking at the file/review level.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270747</commentid>
    <comment_count>45</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-10 15:27:29 -0400</bug_when>
    <thetext>(In reply to comment #36)
&gt; I tested with patch set 14 and I&apos;m still missing buttons when expanding older
&gt; patch sets. Sometimes they appear but most often not.

Actually, it turns out that they were actually there. They just weren&apos;t getting displayed because of a layout issue. :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2270890</commentid>
    <comment_count>46</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-11 00:23:24 -0400</bug_when>
    <thetext>And then there were 2. ;) I don&apos;t want to close these yet as they both report issues that occurred recently and I haven&apos;t had confirmation on the fixes for.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271227</commentid>
    <comment_count>47</comment_count>
    <who name="Tomasz Zarna">tomasz.zarna</who>
    <bug_when>2013-06-11 10:35:11 -0400</bug_when>
    <thetext>While testing master I found bug 410486, not sure if this is a regression, but looks like one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271269</commentid>
    <comment_count>48</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-11 11:15:23 -0400</bug_when>
    <thetext>It doesn&apos;t look SynchronizeTasksJob properly guards against runtime exceptions from connectors so bug 410486 could break synchronization leading to missed updates (even for other tasks that changed).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271299</commentid>
    <comment_count>49</comment_count>
    <who name="Steffen Pingel">steffen.pingel</who>
    <bug_when>2013-06-11 11:56:36 -0400</bug_when>
    <thetext>The majority of the issues has been addressed. Let&apos;s close this task and track the remaining work on new bugs. Thanks a lot for getting this into shape so close to the release, Miles!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>2271420</commentid>
    <comment_count>50</comment_count>
    <who name="Miles Parker">milesparker</who>
    <bug_when>2013-06-11 14:17:22 -0400</bug_when>
    <thetext>(In reply to comment #49)
&gt; The majority of the issues has been addressed. Let&apos;s close this task and track
&gt; the remaining work on new bugs. Thanks a lot for getting this into shape so
&gt; close to the release, Miles!

Next time I&apos;d like to do it as far away from the release as possible! :D</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>